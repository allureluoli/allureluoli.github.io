<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>孤独与爱</title>
    <url>/2023/03/15/2023-3-15-%E5%AD%A4%E7%8B%AC%E4%B8%8E%E7%88%B1/</url>
    <content><![CDATA[<p>如今的我，已经不再去问那是非对错。回归以往的故事，熄灭的是怒火，感受到的是凄凉。错误的付出，是错付，也不是错付。痛苦与悲伤，寂寞与孤独，充斥我的灵魂，使我麻木。逃避，不敢面对，自我慰藉。又因友人的鼓励，在劝告的话语中，在一步步的艰难的抉择中，我逐渐的找回勇气。得到的，是出乎预料的回答。心里的石头终于落地，呼吸也开始舒畅。但即便如此，我也仍然无法摆脱这份我自己选择的孤独，与世界疏离，收敛我的心性，长此以往。我寻觅着，又不敢触碰，远观着，幻想着，背驰而去，回到我的孤独之中去。</p>
<p>出乎意料的，一次偶然，联系又再次产生。我小心翼翼的，我观察着，不敢奢求的，深深的将爱隐藏着，只希望陪伴能够长久，未来能有未来。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 初学时旧笔记</title>
    <url>/2022/07/23/2022-7-23-C++-%E5%88%9D%E5%AD%A6%E6%97%B6%E6%97%A7%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">第一行代码</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream &gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<h2 id="C-的集成环境-《Code-blocks》"><a href="#C-的集成环境-《Code-blocks》" class="headerlink" title="C++的集成环境  《Code blocks》"></a>C++的集成环境  《Code blocks》</h2><h3 id="codeblocks可以使用MINGW作为编译器-下载地址：https-sourceforge-net-projects-mingw-w64-MinGW内置了python-java-等-各种语言的编译器，以及调试器，只需要配置到codeblocks之中使用即可"><a href="#codeblocks可以使用MINGW作为编译器-下载地址：https-sourceforge-net-projects-mingw-w64-MinGW内置了python-java-等-各种语言的编译器，以及调试器，只需要配置到codeblocks之中使用即可" class="headerlink" title="codeblocks可以使用MINGW作为编译器  下载地址：https://sourceforge.net/projects/mingw-w64/   MinGW内置了python java 等..各种语言的编译器，以及调试器，只需要配置到codeblocks之中使用即可,"></a>codeblocks可以使用MINGW作为编译器  下载地址：<a href="https://sourceforge.net/projects/mingw-w64/">https://sourceforge.net/projects/mingw-w64/</a>   MinGW内置了python java 等..各种语言的编译器，以及调试器，只需要配置到codeblocks之中使用即可,</h3><p>c++的难点：多维数组<br>7月24日<br> 例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string letters[<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">&#123;</span><br><span class="line">&#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span> &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&#123; <span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;G&quot;</span>, <span class="string">&quot;H&quot;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>[]的数量代表着这个数组是几维<br> []内部代表着维度的数量，由大块向小块去看<br> 怎么叫做由大块向小块去看?<br> 此代码中，ABCD是一个大块，是第一维的<br> AB和CD又被分为二维的两个小块<br> A和B，又被第三维再分<br> 如此理解数组的概念<br> 此外，数组还有一条特殊的性质，叫做空间的连续性<br> 举例：[0][0][2]可以得到C 原因是，数组超出了原本的空间，但是由于空间是一条带状的连续的，可以访问到其他空间里面的元素。<br> 不仅如此，如果超出空间的部分是一片空白的内存，只要不超出太多也是可以访问的，因为系统给程序分配的内存往往比实际上大很多。<br> 而通过空间连续去修改内存也是病毒的特征之一。</p>
<h5 id="C-学习的第三天，7-25-关于面向对象（OOP）"><a href="#C-学习的第三天，7-25-关于面向对象（OOP）" class="headerlink" title="C++学习的第三天，7.25      关于面向对象（OOP）"></a>C++学习的第三天，7.25      关于面向对象（OOP）</h5><p>首先我们需要清楚类是什么            class MyClass {       &#x2F;&#x2F; The class     public:             &#x2F;&#x2F; Access specifier       int myNum;        &#x2F;&#x2F; Attribute (int variable)       string myString;  &#x2F;&#x2F; Attribute (string variable)    };          这是我们创建的一个类，类内部拥有自己的属性，以及访问说明符（public）     MyClass myObj;      而类可以以这种形式给对象使用，在这里myObj就是我们的对象，这个对象属于这个分类。     而分类后，对象可以使用自己分类的属性了，并且可以为自己的各项属性赋值。</p>
<h6 id="C-学习的第四天-7-26-对此前笔记的整理"><a href="#C-学习的第四天-7-26-对此前笔记的整理" class="headerlink" title="C++学习的第四天 7.26 对此前笔记的整理"></a>C++学习的第四天 7.26 对此前笔记的整理</h6><p>#include <iostream>  &#x2F;&#x2F;而这里，是C++头文件，头文件中包含了大量的信息，   using namespace std;  &#x2F;&#x2F; main() 是程序开始执行的地方   int main()  &#x2F;&#x2F;每个程序都从这里开始执行，这里是主程序，每个程序最主要的部分。  {     cout &lt;&lt; “Hello World”; &#x2F;&#x2F; 输出 Hello World     return 0;      &#x2F;&#x2F;返回一个0的值，在这里起到终止函数的作用                       &#x2F;&#x2F;花括号内，是运行的函数体，   }       如何去跑一段C++代码？   答案是，先编译，再运行！   我们在编写的文件为cpp文件，首先将cpp文件进行构建为exe文件，再进行运行。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>被if语句给予一点小小震撼</title>
    <url>/2023/03/19/2023-3-19-%E8%A2%ABif%E8%AF%AD%E5%8F%A5%E7%BB%99%E4%BA%88%E4%B8%80%E7%82%B9%E5%B0%8F%E5%B0%8F%E9%9C%87%E6%92%BC/</url>
    <content><![CDATA[<p>#被if语句给予一点小小震撼</p>
<p>为什么是and 而不是or?</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">QQ=<span class="number">1252</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">int</span>(QQ) != <span class="number">3345483363</span> <span class="keyword">or</span> <span class="built_in">int</span>(QQ) != <span class="number">2060598058</span>:</span><br></pre></td></tr></table></figure>
<p>如果QQ号不等于3345483363或2060598058就是错误的，否则就输出正确的。<br>但是实际情况却是，QQ为任何数字都会错误！…而换成and就能达到我想要的效果，可and不是和吗？<br>or不是两边任何一个返回为真则为真吗，而and不是两边都为真才为真吗？啊啊啊，为森么<br>然后我踏马就想通了，如果QQ不等于前者，就返回一个真了，我需要的是两个其中一个是假则返回假。<br>卧槽</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;错误的&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正确的&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>包子店的童话</title>
    <url>/2023/03/14/2023-3-14-%E5%8C%85%E5%AD%90%E5%BA%97%E7%9A%84%E7%AB%A5%E8%AF%9D/</url>
    <content><![CDATA[<p>从前有一家包子店，包子物美价廉，但在噪杂的城市中并不显眼，生意平平。有一天，老板娘抱怨道：“只靠卖包子，什么时候才能赚够买房的钱啊？”老板顿了顿，说道：“只要一直卖下去，好好的包包子，肯定能赚够的。“虽后看了看店铺里冷清的现状，自言自语般的说道：”能卖一百万份包子，就好了。”</p>
<p>有一天，店里来了个奇怪的客人。穿着黑色的西装，戴着礼帽，像是从电影里走出来似的。最奇怪的一点是，无论老板怎么看他，都无法看清他的脸，简直是活见鬼了。老板强装淡定，认为自己一定是老花眼了，笑着问道：“个人，来吃包子吗？”</p>
<p>“不错不错，但我要的量有点大，不知道你们这小店吃不吃得下。”西装男以一副奇怪沙哑的嗓音开口，向着包子店的老板说道。</p>
<p>“放心放心，我们店虽小，但我们可勤快了，不知道客人您要多少包子。”老板心中一喜，连忙答应下来，询问道。</p>
<p>“这张支票你先拿着，明天开始我每天都来吃包子，你包够够我吃的即可。”西装男丢出一张支票，支票像变魔术似的，顺着风飘进了老板的口袋。</p>
<p>包子铺老板拿出支票一看，顿时吓了一跳，上面竟然有一大串的零。“个，拾，佰，仟，万，拾万，佰万，竟然有五…”老板激动的差点喊出来，看了一眼店铺里还在吃饭的食客，发现没有人注意到自己后，将支票收了起来，拿起毛巾擦了擦头上因为激动流出来的汗水。</p>
<p>“老婆，帮我看着点店，我出去办点事。”老板对厨房里忙活的妻子吩咐道，听到妻子嗯了一声后，急匆匆的打D来到了银行。</p>
<p>“先生，请问有什么需要帮助的吗？”</p>
<p>“我要兑支票。”</p>
<p>手续办的很快，在兑现完成后银行的工作人员给他推荐了一堆的投资和理财的业务，还有种种福利之类的，听的老板晕头转向。待到出了银行大门才回过神来，赶紧看了一眼自己的手机银行，一查，真的多了五百万，自己从未有过这么多钱！这一切让老板有些精神恍惚。久违的打了个平时不肯轻易坐的出租车回到了包子店。</p>
<p>老板强忍着，没有告诉妻子这个消息，担心钱财外露遭到觊觎。并且西装男的请求还没有完成，让老板心里有些没底，什么叫包够够他吃的包子，老板猜想肯定没有那么简单，便决定今晚多包50笼包子。心想：“这下肯定够吃的了吧。”</p>
<p>未完待续…</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>童话</tag>
        <tag>故事</tag>
      </tags>
  </entry>
  <entry>
    <title>使用got装饰器制作比赛抽图系统</title>
    <url>/2023/03/24/2023-3-24-%5BNonebot%5D-%E4%BD%BF%E7%94%A8got%E8%A3%85%E9%A5%B0%E5%99%A8%E5%88%B6%E4%BD%9C%E6%AF%94%E8%B5%9B%E6%8A%BD%E5%9B%BE%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>说实话，这段代码并不完美，got装饰器有专门的获取消息的方法，而我仍然在使用获取事件消息的方式。</p>
<p>而这种实现方法最明显的缺陷就是无法在群聊以外的环境中使用。</p>
<p>阅读了其他人的代码后，我深感自己的代码水平还是太低。尽管投机取巧的实现了一些功能，但很明显的存在诸多的缺陷。</p>
<p>我将在接下来的时间内多多参考佬们的代码，也更多的去理解Python。汲取前人的智慧，追寻前辈的脚步，而不是一直通过自己的方法闭门造车。</p>
<p>统计一下存在缺陷的功能：</p>
<p>​	教学系统：大量的使用json文件，占用的资源太多</p>
<p>​	持续性会话系统：发送了空消息，影响PC用户的使用</p>
<p>​	比赛系统：代码不完美</p>
<p>​	抽图系统：代码重复性高，宛若屎山</p>
<p>​	帮助系统：同上</p>
<p>总结：菜！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> nonebot <span class="keyword">import</span> on_command</span><br><span class="line"><span class="keyword">from</span> nonebot.adapters.onebot.v11 <span class="keyword">import</span> MessageSegment, Event</span><br><span class="line"><span class="keyword">from</span> nonebot.matcher <span class="keyword">import</span> Matcher</span><br><span class="line"><span class="keyword">from</span> nonebot.adapters <span class="keyword">import</span> Message</span><br><span class="line"><span class="keyword">from</span> nonebot.params <span class="keyword">import</span> CommandArg</span><br><span class="line"></span><br><span class="line">MatchMap = on_command(<span class="string">&#x27;比赛抽图模式启动&#x27;</span>, priority=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@MatchMap.handle()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_first_receive</span>(<span class="params">matcher: Matcher, args: Message = CommandArg(<span class="params"></span>)</span>):</span><br><span class="line">    plain_text = args.extract_plain_text()</span><br><span class="line">    <span class="keyword">if</span> plain_text:</span><br><span class="line">        matcher.set_arg(<span class="string">&quot;Map&quot;</span>, args)</span><br><span class="line">        <span class="comment"># 设置一个got消息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里Ban图</span></span><br><span class="line">MapList = os.listdir(os.getcwd() + <span class="string">&quot;/love/data/images/match/&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@MatchMap.got(<span class="params"><span class="string">&quot;Map&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="meta">              prompt=<span class="string">f&quot;当前地图池为<span class="subst">&#123;<span class="built_in">str</span>(MapList).replace(<span class="string">&#x27;.png&#x27;</span>, <span class="string">&#x27;&#x27;</span>)&#125;</span>\nBan图指【BanXXX】\nBan图结束请发送【开始抽图】&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_func</span>(<span class="params">event: Event</span>):</span><br><span class="line">    <span class="comment"># async def handle_city(Map: Message = Arg(), BanMap: str = ArgPlainText(&quot;Map&quot;)):</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        MapName = <span class="built_in">str</span>(event.get_message()).replace(<span class="string">&#x27;Ban&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> MapName != <span class="string">&#x27;开始抽图&#x27;</span>:</span><br><span class="line"></span><br><span class="line">            MapList.remove(MapName + <span class="string">&#x27;.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> MatchMap.reject(<span class="string">&quot;Ban图成功，地图池中还有：&quot;</span> + <span class="built_in">str</span>(MapList).replace(<span class="string">&#x27;.png&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">await</span> MatchMap.send(<span class="string">&quot;Ban图结束，最终地图池中还有：&quot;</span> + <span class="built_in">str</span>(MapList).replace(<span class="string">&#x27;.png&#x27;</span>, <span class="string">&#x27;&#x27;</span>) + <span class="string">&quot;这些地图&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">await</span> MatchMap.reject(<span class="string">&quot;请检查指令是否正确~&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@MatchMap.got(<span class="params"><span class="string">&quot;Number&quot;</span>, prompt=<span class="string">f&quot;请发送需要抽取地图的数量，如果抽1张图请发送 1 。&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_func</span>(<span class="params">event: Event</span>):</span><br><span class="line">    Number = <span class="built_in">eval</span>(<span class="built_in">str</span>(event.get_message()))</span><br><span class="line">    output_list = []</span><br><span class="line">    <span class="comment"># 判断数字大于列表索引就重来</span></span><br><span class="line">    <span class="comment"># try:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(output_list) &lt; Number:</span><br><span class="line"></span><br><span class="line">        MapN = random.choice(MapList)  <span class="comment"># 返回列表中的随机项</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> MapN <span class="keyword">not</span> <span class="keyword">in</span> output_list:</span><br><span class="line">            message = MapN</span><br><span class="line"></span><br><span class="line">            path = Path(os.getcwd() + <span class="string">f&quot;/love/data/images/match/<span class="subst">&#123;MapN&#125;</span>&quot;</span>).parent / <span class="string">f&quot;<span class="subst">&#123;MapN&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">            image = MessageSegment.image(path)</span><br><span class="line"></span><br><span class="line">            output_list.append(MapN)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">await</span> MatchMap.send(<span class="string">&quot;呐呐~你抽到的地图为：&quot;</span> + message.replace(<span class="string">&#x27;.png&#x27;</span>, <span class="string">&#x27;&#x27;</span>) + image)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> MatchMap.finish(<span class="string">&quot;抽图结束，祝您比赛愉快&quot;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Nonebot</tag>
      </tags>
  </entry>
  <entry>
    <title>浅尝C艹艹</title>
    <url>/2023/03/15/2023-3-6-%E6%B5%85%E5%B0%9DC%E8%89%B9%E8%89%B9/</url>
    <content><![CDATA[<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Microsoft.Win32;</span><br><span class="line"><span class="keyword">using</span> System;<span class="comment">//unsing指令 让我们的程序包含System的应用空间</span></span><br><span class="line"><span class="keyword">using</span> System.Threading.Channels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">HelloWorldApplication</span> &#123;<span class="comment">//声明了一个 命名空间</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Recttangle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">double</span> length;</span><br><span class="line">        <span class="built_in">double</span> width;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Acceptdetails</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            length = <span class="number">4.5</span>;</span><br><span class="line">            width = <span class="number">3.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">GetArea</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> length * width;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Length:&#123;0&#125;&quot;</span>, length);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Width:&#123;0&#125;&quot;</span>, width);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Area:&#123;0&#125;&quot;</span>, GetArea());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Helloworld</span><span class="comment">//声明了一个 类</span></span><br><span class="line">    &#123;                <span class="comment">//</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)<span class="comment">//这里是Main方法，C#程序的入口点</span></span></span><br><span class="line">        &#123;       <span class="comment">//顺带一提，Static 是静态 Void是空，也就输静态空</span></span><br><span class="line">            <span class="comment">//为什么用静态空？原因很简单，这里是主方法，TA不需要返回任何值给谁，所以使用静态空</span></span><br><span class="line">            <span class="comment">/* C#练习 */</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;你好，C#！&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;你好，Visual Studio!&quot;</span>);</span><br><span class="line">            <span class="comment">//vs直接敲cw就可以出现 Console.WriteLine了</span></span><br><span class="line">            <span class="comment">//WriteLine 是一个定义在 System 命名空间中的 Console 类的一个方法</span></span><br><span class="line">            Recttangle r = <span class="keyword">new</span> Recttangle();<span class="comment">//实例化这个类  盲猜是因为同一文件，所以就可以直接实例化上面那个类</span></span><br><span class="line">            r.Acceptdetails();<span class="comment">//调用方法</span></span><br><span class="line">            r.Display();<span class="comment">//方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//C#的数据类型</span></span><br><span class="line">            <span class="comment">//bool byte char decimal double float int long sbyte short uint ulong ushort</span></span><br><span class="line">            <span class="comment">//无符号整数被减会怎么样呢？</span></span><br><span class="line">            <span class="comment">//不同类型的数字可以一起运算吗？</span></span><br><span class="line">            <span class="built_in">bool</span> BoolOne = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">byte</span> ByteOne = <span class="number">6</span>, ByteTwo = <span class="number">5</span>;</span><br><span class="line">            <span class="built_in">char</span> CharOne = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="built_in">char</span> CharTwo = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            <span class="built_in">decimal</span> DecimalOne = <span class="number">0.0</span>M;</span><br><span class="line">            <span class="built_in">double</span> DoubleOne = <span class="number">111.111</span>;</span><br><span class="line">            <span class="built_in">float</span> FloatOne = <span class="number">111.111F</span>;</span><br><span class="line">            <span class="built_in">int</span> IntOne = <span class="number">111</span>;</span><br><span class="line">            <span class="built_in">long</span> LongOne = <span class="number">111</span>;</span><br><span class="line">            <span class="built_in">sbyte</span> SbyleOne = <span class="number">127</span>;</span><br><span class="line">            <span class="built_in">short</span> ShortOne = <span class="number">3456</span>;</span><br><span class="line">            <span class="built_in">uint</span> UintOne = <span class="number">111</span>;</span><br><span class="line">            <span class="built_in">ulong</span> ulongOne = <span class="number">222</span>;</span><br><span class="line">            <span class="built_in">ushort</span> ushortOne = <span class="number">333</span>;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是布尔类型:&quot;</span>+BoolOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是byte类型：&quot;</span>+ByteOne+ByteTwo);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是字符类型:&quot;</span>+CharOne+CharTwo);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是decimal类型：&quot;</span>+DecimalOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是Double类型：&quot;</span>+DoubleOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是Folat类型：&quot;</span>+FloatOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是Int类型：&quot;</span>+IntOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是long类型：&quot;</span>+LongOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是sbyte类型：&quot;</span>+SbyleOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是short类型：&quot;</span>+ShortOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是unit类型：&quot;</span>+UintOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是ulong类型:&quot;</span>+ulongOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这是ushort类型:&quot;</span>+ushortOne);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;\n&quot;</span>);<span class="comment">//由于本身WirteLine就自动带一个\n，这样子就一下子空两行了。</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">double</span> DoubleThree = <span class="number">3.3333</span>;</span><br><span class="line">            <span class="comment">//先声明再初始化是良好的写法。</span></span><br><span class="line">            <span class="built_in">int</span> NumberOne;</span><br><span class="line">            <span class="built_in">int</span> NumberTwo;</span><br><span class="line">            <span class="built_in">int</span> NumberThree;</span><br><span class="line"></span><br><span class="line">            NumberOne=<span class="number">111</span>;</span><br><span class="line">            NumberTwo=<span class="number">222</span>;</span><br><span class="line">            NumberThree=<span class="number">333</span>;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;随便输出几个数字:&quot;</span>+NumberOne+NumberTwo+NumberThree);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;随便输出一个强制类型转换的数字:&quot;</span>+(<span class="built_in">int</span>)DoubleThree);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;输出字符串&#123;0&#125;&quot;</span>, <span class="string">&quot;啊输出字符串&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;浅记一下逻辑运算符：&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">bool</span> BoolTwo = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">bool</span> BoolThree = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">bool</span> BoolFour = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (NumberThree&gt;NumberTwo)</span><br><span class="line">            &#123;</span><br><span class="line">                BoolTwo = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (NumberTwo&gt;NumberOne)</span><br><span class="line">            &#123;</span><br><span class="line">                BoolFour = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Console.WriteLine(BoolFour&amp;&amp;BoolTwo);</span><br><span class="line">            Console.WriteLine(BoolFour&amp;&amp;BoolThree);</span><br><span class="line">            Console.WriteLine(BoolFour||BoolThree);</span><br><span class="line">            Console.WriteLine(!(BoolTwo &amp;&amp; BoolThree));</span><br><span class="line">            <span class="comment">//差不多就这样了 ，接下来是位运算</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//One = 0011 1100</span></span><br><span class="line">            <span class="comment">//Two = 0000 1101</span></span><br><span class="line">            <span class="built_in">int</span> BitwiseNumberOne = <span class="number">60</span>;</span><br><span class="line">            <span class="built_in">int</span> BitwiseNumberTwo = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(BitwiseNumberOne&amp;BitwiseNumberTwo);<span class="comment">// 0000 1100 对每位执行AND运算符</span></span><br><span class="line">            Console.WriteLine(BitwiseNumberOne|BitwiseNumberTwo);<span class="comment">// 0011 1101 对每位执行OR运算符</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//什么是AND运算符 1 AND 1 = 1 1 AND 0 = 0 0 AND 1 = 0 0 AND 0 = 0</span></span><br><span class="line">            <span class="comment">//什么是OR运算符  1 OR 1 = 1 1 OR 0 = 1 0 OR 1 = 1 O OR O = 0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//浅浅的写一下switch语句</span></span><br><span class="line">            <span class="built_in">int</span> NumberFive = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">switch</span> (NumberFive)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;这个数字是1&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;传透过来了。&quot;</span>);<span class="comment">//这里像写一下穿透的示例，但是C#居然是禁止穿透的，233333</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;但是问题不大哦&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="literal">default</span>:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;233333&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//如果不满足以上任何标签的条件，则执行default块的内容</span></span><br><span class="line">                    <span class="comment">//switch语句最后一行也要记得加break语句，否则无法脱离开关</span></span><br><span class="line">                    <span class="comment">//是否可以return一个函数呢？</span></span><br><span class="line">            &#125;       <span class="comment">//我认为是有可能的。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (NumberFive)<span class="comment">//这里填变量就不会出现这个错误，如果直接填数字，编译器则会发现一个多余的case代码，它是不会被执行的，所以就会报一个警告</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;还有吗&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//这样写会有一个不影响编译的警告：warning CS0162: 检测到无法访问的代码</span></span><br><span class="line">                <span class="comment">//原因是：在switch语句中，没有匹配到执行的 case 中</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;哈哈哈&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">int</span> WhileNmuber = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">while</span> (WhileNmuber&gt;<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                WhileNmuber--;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;减减&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//接下来是for循环捏</span></span><br><span class="line">            <span class="comment">//for ( init; condition; increment )</span></span><br><span class="line">            <span class="comment">//语法如上，意思就是，for (初始化；判断；increment )</span></span><br><span class="line">            <span class="comment">//执行完 init 执行 condition 执行完 condition 执行循环主体 执行完循环主体 执行increment</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>;)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;原来是这样！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//foreach循环语句</span></span><br><span class="line">            <span class="comment">//使用foreach可以迭代数组或者一个集合对象。</span></span><br><span class="line">            <span class="comment">//什么是迭代？ 迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果......</span></span><br><span class="line">            <span class="comment">//说人话：执行程序中的循环，直到满足某条件为止，亦称为迭代。</span></span><br><span class="line">            <span class="built_in">int</span>[] fibarray = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span> &#125;;<span class="comment">//创建一个整型数组</span></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">int</span> element <span class="keyword">in</span> fibarray)<span class="comment">//变量elementu遍历整个数组</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                System.Console.WriteLine(element);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//元素计算器 ：很简单的实现方式</span></span><br><span class="line">            <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">int</span> element <span class="keyword">in</span> fibarray)</span><br><span class="line">            &#123;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">                System.Console.WriteLine(<span class="string">&quot;Element #&#123;0&#125;: &#123;1&#125;:&#123;2&#125;&quot;</span>, count, element, <span class="string">&quot;我去&quot;</span>, <span class="string">&quot;2333&quot;</span>);</span><br><span class="line">            &#125;                               <span class="comment">//两个占位符，表示后面有两个需要输出的代码，而且占位符无关位置</span></span><br><span class="line">                                            <span class="comment">//值得一提的是，如果多写了一个占位符，程序会直接崩溃，如果少写了一个占位符，仅仅只会少输出后面部分的内容</span></span><br><span class="line">                                            <span class="comment">//接下来是，Do while循环~</span></span><br><span class="line">                                            <span class="comment">//理解很简单，就是先执行一次，再从尾部检查条件，再判断是否执行。</span></span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;欸嘿我先执行一次辣~&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">while</span> (<span class="number">0</span>&gt;<span class="number">1</span>);<span class="comment">//逆天写法</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//哦对，C#中的循环也是可以嵌套的，不过我懒得写了。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//接下来是封装</span></span><br><span class="line">            <span class="comment">//神马是封装？封装 被定义为&quot;把一个或多个项目封闭在一个物理的或者逻辑的包中&quot;。</span></span><br><span class="line">            <span class="comment">//封装的意义：在面向对象程序设计方法论中，封装是为了防止对实现细节的访问。</span></span><br><span class="line">            <span class="comment">//抽象和封装是面向对象程序设计的相关特性。抽象允许相关信息可视化，封装则使开发者实现所需级别的抽象。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//如下是访问修饰符</span></span><br><span class="line">            <span class="comment">/*一个 访问修饰符 定义了一个类成员的范围和可见性。C# 支持的访问修饰符如下所示：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                   public：所有对象都可以访问；</span></span><br><span class="line"><span class="comment">                   private：对象本身在对象内部可以访问；</span></span><br><span class="line"><span class="comment">                   protected：只有该类对象及其子类对象可以访问</span></span><br><span class="line"><span class="comment">                   internal：同一个程序集的对象可以访问；</span></span><br><span class="line"><span class="comment">                   protected internal：访问限于当前程序集或派生自包含类的类型。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//public中，即使是在一个类中，也可以通过public将函数暴露给其他成员</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//Private 访问修饰符允许一个类将其成员变量和成员函数对其他的函数和对象进行隐藏。只有同一个类中的函数可以访问它的私有成员。即使是类的实例也不能访问它的私有成员。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//Protected 访问修饰符 Protected 访问修饰符允许子类访问它的基类的成员变量和成员函数。这样有助于实现继承。</span></span><br><span class="line">            <span class="comment">//什么是基类和成员函数呢？</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//Internal 访问修饰符 Internal 访问修饰符允许一个类将其成员变量和成员函数暴露给当前程序中的其他函数和对象。</span></span><br><span class="line">            <span class="comment">//当前函数的</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//接下来是 方法 捏~</span></span><br><span class="line">            <span class="comment">//&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)</span></span><br><span class="line">            <span class="comment">//格式如上</span></span><br><span class="line">            <span class="comment">//修饰符 返回类型 （不返回值的为void哦~） 方法名称 (括号里的参数捏)</span></span><br><span class="line">            <span class="comment">//欸嘿方法很简单辣</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//懒得写代码了~</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//递归方法调用</span></span><br><span class="line">            <span class="comment">//神马是递归呢 一个方法可以自我调用就是递归捏！</span></span><br><span class="line">            NumberManipulator n = <span class="keyword">new</span> NumberManipulator();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;6 的阶乘是： &#123;0&#125;&quot;</span>, n.factorial(<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> NmubernullOne;<span class="comment">//这个默认为0</span></span><br><span class="line">            <span class="built_in">int</span>? NmubernullTwo;<span class="comment">//进行Null赋值，这个默认为null</span></span><br><span class="line">            Console.WriteLine();</span><br><span class="line">            <span class="comment">//被赋予了null 值的类型，称为可空类型，就是可以变成null的类型</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//合并运算符 ??</span></span><br><span class="line">            <span class="comment">//如果第一个操作数的值为 null，则运算符返回第二个操作数的值，否则返回第一个操作数的值。下面的实例演示了这点：</span></span><br><span class="line">            <span class="built_in">double</span>? num1 = <span class="literal">null</span>;</span><br><span class="line">            <span class="built_in">double</span>? num2 = <span class="number">3.14157</span>;</span><br><span class="line">            <span class="built_in">double</span>? num3 = <span class="keyword">new</span> <span class="built_in">double</span>?();</span><br><span class="line">            num3 = num1 ?? num2;</span><br><span class="line">            Console.WriteLine(num3);</span><br><span class="line">            Console.WriteLine(num1 ?? num2);</span><br><span class="line">            <span class="comment">//C# 提供了一个特殊的数据类型，nullable 类型（可空类型），可空类型可以表示其基础值类型正常范围内的值，再加上一个 null 值。</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//正好想到了，C#中上半部分的程序是否可以调用下半部分程序的方法呢</span></span><br><span class="line">            <span class="comment">//可是程序都是逐行阅读的来着？</span></span><br><span class="line">            <span class="comment">//经过实验，C#中是可以的，Python中我忘了行不行了</span></span><br><span class="line">            <span class="comment">//经过实验，Python中是不行的，因为Python是逐行阅读代码的脚本语言</span></span><br><span class="line">            <span class="comment">//这是一个处理数字的类，可以用来计算数学中的阶乘</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//C#的数组</span></span><br><span class="line">            <span class="comment">//注意，数组不可以重复声明</span></span><br><span class="line">            <span class="comment">//声明一个数组</span></span><br><span class="line">            <span class="built_in">double</span>[] balanceOne;</span><br><span class="line">            <span class="comment">//声明一个数组不会在内存中初始化数组</span></span><br><span class="line">            <span class="built_in">double</span>[] balance = <span class="keyword">new</span> <span class="built_in">double</span>[<span class="number">10</span>];<span class="comment">//声明数组的长度</span></span><br><span class="line">            balance[<span class="number">0</span>] = <span class="number">4500.0</span>;<span class="comment">//然后单独赋值</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">double</span>[] balanceThree = &#123; <span class="number">2340.0</span>, <span class="number">4523.69</span>, <span class="number">3421.0</span> &#125;;<span class="comment">//声明的时候给数组赋值</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span>[] marksOne = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>] &#123; <span class="number">99</span>, <span class="number">98</span>, <span class="number">92</span>, <span class="number">97</span>, <span class="number">95</span> &#125;;<span class="comment">//可以创建并初始化一个数组</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span>[] marksTwo = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">99</span>, <span class="number">98</span>, <span class="number">92</span>, <span class="number">97</span>, <span class="number">95</span> &#125;;<span class="comment">//可以省略数组的大小</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span>[] marksThree = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">99</span>, <span class="number">98</span>, <span class="number">92</span>, <span class="number">97</span>, <span class="number">95</span> &#125;;<span class="comment">//可以将一个数组变量赋值给另一个数组变量</span></span><br><span class="line">            <span class="built_in">int</span>[] score = marksThree;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            创建字符串的五种方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            通过给 String 变量指定一个字符串</span></span><br><span class="line"><span class="comment">            通过使用 String 类构造函数</span></span><br><span class="line"><span class="comment">            通过使用字符串串联运算符（ + ）</span></span><br><span class="line"><span class="comment">            通过检索属性或调用一个返回字符串的方法</span></span><br><span class="line"><span class="comment">            通过格式化方法来转换一个值或对象为它的字符串表示形式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            String StringOne;</span><br><span class="line">            <span class="built_in">string</span> stringOne;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             Console.ReadKey();<span class="comment">//这使得程序会等待一个按键的动作，防止程序从 Visual Studio .NET 启动时屏幕会快速运行并关闭。</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//枚举</span></span><br><span class="line">        <span class="comment">//什么是枚举</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//包含很多变量的集合，可以调用集合</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         C#的枚举类型(Enum)是用来定义变量，这些变量表示一组人工定义的常量。使用枚举允许程序员有效地标识变量，并更容易地处理枚举值。例如，一个颜色枚举类型可以包括红、绿、蓝等常量值。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">enum</span> EnmuOne &#123; One, Two, Three, Four &#125;;</span><br><span class="line">        <span class="built_in">int</span> x = (<span class="built_in">int</span>)EnmuOne.One;</span><br><span class="line">        <span class="built_in">int</span> y = (<span class="built_in">int</span>)EnmuOne.Two;</span><br><span class="line">        <span class="comment">//枚举是这样的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">NumberManipulator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">factorial</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">            <span class="built_in">int</span> result;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">1</span>)<span class="comment">//仅在num等于1的时候返回1让循环终止</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result = factorial(num - <span class="number">1</span>) * num;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask[初见]</title>
    <url>/2023/07/03/2023-7-3-Flask-1/</url>
    <content><![CDATA[<h1 id="什么是Flask"><a href="#什么是Flask" class="headerlink" title="什么是Flask?"></a>什么是Flask?</h1><p>  Flask是一个使用 <a href="https://baike.baidu.com/item/Python?fromModule=lemma_inlink">Python</a> 编写的轻量级 Web 应用框架。其 <a href="https://baike.baidu.com/item/WSGI?fromModule=lemma_inlink">WSGI</a> 工具箱采用 Werkzeug ，<a href="https://baike.baidu.com/item/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/907667?fromModule=lemma_inlink">模板引擎</a>则使用 Jinja2 。Flask使用 BSD 授权。</p>
<p>​																																										——百度百科</p>
<p>如果看文章的你也同我一样，如此小白，便会觉得，听不懂。</p>
<p>什么是Web应用框架？</p>
<p>WSGI是什么？</p>
<p>模板引擎又是什么？</p>
<p>疑问很多，下面我将通过我的个人理解首先解答第一个问题。</p>
<h2 id="Web应用框架"><a href="#Web应用框架" class="headerlink" title="Web应用框架"></a>Web应用框架</h2><p>在接触Python之前我便对tomcat , Djongo 等，略有耳闻。这是两种知名的，Web应用框架。在实际操作之前，仅凭想象，或是其他渠道学习，理解总归是差些的。</p>
<p>Web应用框架，说白了，就是可以通过编写代码，实现一个运行在Web上的应用程序。什么是Web应用程序，即能通过Web访问，也就是HTTP或HTTPS访问使用的应用。</p>
<p>再通俗点讲，就是实现了网站的网页和网站的部署。实现了html和web服务器的功能。</p>
<h2 id="瞬间上手Flask"><a href="#瞬间上手Flask" class="headerlink" title="瞬间上手Flask"></a>瞬间上手Flask</h2><p>首先，我们先来安装一下Flask，只需要一条代码即可。（默认你电脑上有Python和pip）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install flask</span><br></pre></td></tr></table></figure>

<p>然后，打开你的IDE，编写一段超级精简的Python代码！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># __name__是python的一个内置类属性,它存储模块的名称。 python的模块既可以被调用,也可以独立运行。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>) </span><span class="comment"># 这是一个装饰器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用来装饰函数hello_world，当请求的path 是 / 时，程序用函数hello_world来处理这个请求</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>点击运行，得到以下输出。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure>

<p>然后访问其中的地址，即可得到一个网页。</p>
<p>网页中只有一行字，Hello World。本来这博文也是写给自己看的，就不多赘述了。</p>
<h2 id="name"><a href="#name" class="headerlink" title="name"></a><strong>name</strong></h2><p>不得不说一下  <code>__name__</code> 这玩意，比较的神奇。</p>
<p>如果不在本文件运行这个属性，它返回的值是文件名，但当在本文件运行时，它返回的值是 <code>__main__</code>。</p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器以 @ 开头 ，用以装饰后面的函数。</p>
<h2 id="app-run"><a href="#app-run" class="headerlink" title="app.run"></a>app.run</h2><p>我们可以指定监听的地址和端口，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">1122</span>)</span><br></pre></td></tr></table></figure>





<h1 id="Flask路由"><a href="#Flask路由" class="headerlink" title="Flask路由"></a>Flask路由</h1><p>在讲解最小的flask应用时，提到了装饰器route，它的作用就是将处理请求的函数绑定到URL上（URL必须以反斜杠开头），这种设计体现了解耦的思想。<br> <img src="http://www.coolpython.net/pictures/flask_tutorial/basic/route-1586299659-0.jpg" alt="img"><br> 不同的请求被路由到不同处理函数上，这个函数称之为视图。路由保存了URL和处理函数之间的映射关系，映射关系的建立是通过route装饰器完成的。</p>
<p>​																																							  ——COOLPython</p>
<h2 id="建立映射关系"><a href="#建立映射关系" class="headerlink" title="建立映射关系"></a>建立映射关系</h2><p>通过route装饰器，不同的请求被路由到不同处理函数上。路由保存了URL和处理函数之间的映射关系。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/books&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">books</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;books&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="变量规则"><a href="#变量规则" class="headerlink" title="变量规则"></a>变量规则</h2><p>实例中，无论是 <code>/hello</code> 还是 <code>/books/</code> 这种URL都是固定的，而在实际使用中，经常会用到不固定的URL。如：</p>
<blockquote><p>比如&#x2F;book&#x2F;1&#x2F;price 这种restful风格的URL。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<p>先不谈什么是restful风格，当务之急是我们需要实现一个动态变化的URL。</p>
<p>而Flask自带实现方法，允许给URL添加变量部分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/book/&lt;int:id&gt;/price&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">price</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">id</span>)</span><br></pre></td></tr></table></figure>

<p>变量部分的规则为 <a href="converter:variable_name">converter:variable_name</a> ,variable_name将作为参数传递给所绑定的函数，而且可以根据converter转换器对variable_name进行转换。</p>
<p>converter转换器有下面几种</p>
<table>
<thead>
<tr>
<th>转换器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>接受整数</td>
</tr>
<tr>
<td>float</td>
<td>接受浮点数</td>
</tr>
<tr>
<td>path</td>
<td>接受带斜线的path</td>
</tr>
</tbody></table>
<p>如果不标注转换器类型，则默认转为字符串，下面是这几种转换器的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不指定转换器</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/book/&lt;name&gt;/author&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">author</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换器为int</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/book/&lt;int:id&gt;/price&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">price</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(<span class="built_in">id</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换器为float</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/book/price-ge/&lt;float:price&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">books_by_price</span>(<span class="params">price</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(price)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换器为path</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/book/&lt;path:book_info&gt;&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">books_by_path</span>(<span class="params">book_info</span>):</span><br><span class="line">    <span class="keyword">return</span> book_info</span><br></pre></td></tr></table></figure>

<p>​																																							——COOLPYTHON</p>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>初见，Suki , 结婚！</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask[相识]</title>
    <url>/2023/07/03/2023-7-3-Flask-2/</url>
    <content><![CDATA[<h2 id="路由规则管理"><a href="#路由规则管理" class="headerlink" title="路由规则管理"></a>路由规则管理</h2><p>一般情况有两种添加路由规则的方式</p>
<p>1、使用route添加路由规则</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/add_url&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_rule</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;add url rule&#x27;</span></span><br></pre></td></tr></table></figure>

<p>2、使用add_url_rule添加路由规则</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_rule</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;add url rule&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.add_url_rule(<span class="string">&#x27;/add_url&#x27;</span>, <span class="string">&#x27;add_rule&#x27;</span>, add_rule)</span><br></pre></td></tr></table></figure>

<p>两种方式的结果是相同的，route装饰器中也是调用了 add_url_rule方法添加路由规则。</p>
<blockquote><p>更深层的学习可以参考todo。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<h2 id="设置method"><a href="#设置method" class="headerlink" title="设置method"></a>设置method</h2><p>一个URL可以用多种不同的方法请求，创建路由规则时，我们可以指定这个URL支持哪些请求方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/users&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">users</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ok&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在route装饰器中设置methods参数来决定支持的请求方法，不设置默认仅支持GET请求。</p>
<p>users函数既要处理GET请求，又要处理POST请求，那么如何区分它们呢？ 这就要用到请求对象request</p>
<p>通过获取requst的method属性，即可得到请求的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/users&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">users</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;get&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;post&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ok&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Flask视图"><a href="#Flask视图" class="headerlink" title="Flask视图"></a>Flask视图</h2><p>到底什么是视图呢？</p>
<h3 id="视图函数"><a href="#视图函数" class="headerlink" title="视图函数"></a>视图函数</h3><p>通过route装饰器，将url<code>/hello</code>与 函数<code>hello </code>关联在一起，我们称这个函数就是视图函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/hello&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>

<p>一个视图函数用来处理一个请求，最终返回数据。</p>
<h3 id="视图类"><a href="#视图类" class="headerlink" title="视图类"></a>视图类</h3><p>flask提供了两个两个视图类，我们可以继承这两个类中的一个，实现自己的类视图。</p>
<ol>
<li><p>flask.views.View</p>
<p> 继承flask.views.View，必须实现dispatch_request方法以处理请求，下面是一个简单的示例</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"><span class="keyword">from</span> flask.views <span class="keyword">import</span> View</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserView</span>(<span class="title class_ inherited__">View</span>):</span><br><span class="line">    methods = [<span class="string">&#x27;GET&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dispatch_request</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(request.method)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;ok&#x27;</span></span><br><span class="line"></span><br><span class="line">app.add_url_rule(<span class="string">&#x27;/users&#x27;</span>, view_func=UserView.as_view(<span class="string">&#x27;users&#x27;</span>)) <span class="comment">#将函数绑定到Userview</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># userrView类中并没有名为 users 的方法，那么这个字符串参数意义何在呢？</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p> as_view方法返回的是一个View类里的一个方法，类里的方法本质上仍然是函数， methods 规定这个视图类可以处理的请求方法。</p>
<p> 这样设计，我们可以把处理请求的相关代码抽象成不同的方法写在UserView类里，这样便于管理。</p>
</li>
<li><p>flask.views.MethodView</p>
</li>
</ol>
<blockquote><p>View类里，如果一个资源支持多种请求方式，get，post,put,delete等等，那么你不得不在dispatch_request方法里根据request.method对他们进行区分，然后调用不同的处理方法进行响应，对各种请求的路由是由你自己完成的。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<p>MethodView会自动的为视图类做好路由，不同的请求，会被路由到不同的处理方法上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"><span class="keyword">from</span> flask.views <span class="keyword">import</span> MethodView</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserView</span>(<span class="title class_ inherited__">MethodView</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;收到get请求&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;收到post请求&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.add_url_rule(<span class="string">&#x27;/users&#x27;</span>, view_func=UserView.as_view(<span class="string">&#x27;users&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>此设计与tornado的处理方式相同，MethodView是View的子类，它实现了dispatch_request方法，若请求的get请求，则路由到get方法。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask[探索]</title>
    <url>/2023/07/04/2023-7-4-Flask-3/</url>
    <content><![CDATA[<h1 id="请求对象request"><a href="#请求对象request" class="headerlink" title="请求对象request"></a>请求对象request</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>request是flask框架的全局对象，可以通过它来获得当前进入的请求数据。</p>
<p>而在多线程环境下，flask可以保证所使用的request对象为当前这个线程所处理的请求。</p>
<blockquote><p>关于request，最让人感到疑惑的地方在于，明明是一个全局变量，在使用时却提供了当前时刻的请求数据，而且，不同线程之间互不干扰，它是如何设计出来的呢。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<p>通过request可以获得当前请求的全部信息，例如请求的method,path, url, headers,cookies,请求的参数，请求的body…..</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>服务端代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/users&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">users</span>():</span><br><span class="line">    <span class="built_in">print</span>(request.method)       <span class="comment"># 请求方法</span></span><br><span class="line">    <span class="built_in">print</span>(request.headers)      <span class="comment"># 请求的headers</span></span><br><span class="line">    <span class="built_in">print</span>(request.path)         <span class="comment"># 资源路径</span></span><br><span class="line">    <span class="built_in">print</span>(request.url)          <span class="comment"># 完整的url</span></span><br><span class="line">    <span class="built_in">print</span>(request.remote_addr)  <span class="comment"># 客户端IP</span></span><br><span class="line">    <span class="built_in">print</span>(request.cookies)      <span class="comment"># 请求的cookie</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ok&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>客户端代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">cookie_dict = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;python&#x27;</span>&#125;</span><br><span class="line">res = requests.get(<span class="string">&#x27;http://127.0.0.1:5000/users&#x27;</span>, cookies=cookie_dict)</span><br></pre></td></tr></table></figure>

<p>使用客户端代码发出请求后，服务端程序会输出如下内容</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">GET              # 请求方法</span><br><span class="line">Content-Type: </span><br><span class="line">Content-Length: </span><br><span class="line">Host: 127.0.0.1:5000</span><br><span class="line">User-Agent: python-requests/2.22.0</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: */*</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cookie: name=python</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/users          # 资源路径</span><br><span class="line">http://127.0.0.1:5000/users     # 完整路径</span><br><span class="line">127.0.0.1                       # 客户端ip</span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;python&#x27;&#125;              # 请求的cookie</span><br></pre></td></tr></table></figure>

<blockquote><p>提醒一点，request.remote_addr并不一定能够准确的获得客户端的IP，因为在部署服务时，通常最前端用nginx做转发，这样，你获得其实是nginx的IP地址，而非用户的真实地址，如何准确获得客户端的IP地址，请参考文章<a href="https://www.cnblogs.com/mzhaox/p/11214747.html">https://www.cnblogs.com/mzhaox/p/11214747.html</a></p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<h1 id="解析请求数据"><a href="#解析请求数据" class="headerlink" title="解析请求数据"></a>解析请求数据</h1><p>客户端（浏览器）会向服务器提交HTTP请求；然后服务器向客户端返回响应；其中响应包含有关请求的状态信息，还可能包含请求的内容。</p>
<h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>get请求用于查询数据时，通常会带有参数，参数放在path的后面，中间用问号连接。</p>
<p>多个请求参数以key&#x3D;value的形式用&amp;连接起来。</p>
<p>下面是一个带参数的get请求的示例url：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:5000/users?name=poly&amp;age=14</span><br></pre></td></tr></table></figure>

<p>get请求的参数可以通过request.args 和 request.values 两种方法来获得</p>
<p>其中request.args 是包含解析过的get参数的MultiDict</p>
<blockquote><p>MultiDict 是werkzeug提供的一种多key字典，具体可参考 <a href="https://werkzeug.palletsprojects.com/en/0.16.x/datastructures/#werkzeug.datastructures.MultiDict">https://werkzeug.palletsprojects.com/en/0.16.x/datastructures/#werkzeug.datastructures.MultiDict</a> </p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<p>使用方法示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/users&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">users</span>():</span><br><span class="line">    name = request.args[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    age = request.args[<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(name, age)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ok&#x27;</span></span><br><span class="line"><span class="comment"># 获取到的参数一律都是字符串类型</span></span><br></pre></td></tr></table></figure>

<h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>post请求用于新增数据，它提交数据的格式有两种：form表单，json数据</p>
<p>requests.form里存储着post请求提交的form表单数据，下面是解析示例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/users&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">users</span>():</span><br><span class="line">    name = request.form[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    age = request.form[<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(name, age)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ok&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="request-values"><a href="#request-values" class="headerlink" title="request.values"></a>request.values</h3><p>request.args和request.form，其类型都是MultiDict。</p>
<p>因此，flask又提供了一个request.values，类型为CombinedMultiDict。</p>
<p>它包含了args和form,这样，在获取数据时，就不必在纠结到底用args还是用form了，request.values使用方法与args,form相同。</p>
<h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><p>post提交的json数据，应该用get_json()方法来获取</p>
<p>服务端示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/users&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">users</span>():</span><br><span class="line">    data = request.get_json()</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ok&#x27;</span></span><br></pre></td></tr></table></figure>

<p>客户端示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">res = requests.post(<span class="string">&#x27;http://127.0.0.1:5000/users&#x27;</span>, json=&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;poly&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">13</span>&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask[寻觅]</title>
    <url>/2023/07/04/2023-7-4-Flask-4/</url>
    <content><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>HTML代码复用</li>
<li>网页内容动态显示</li>
</ol>
<blockquote><p>使用模板技术，可以将那些可共用的代码放在基础模板里，其他的网页可以继承这个基础模板，也可以用include的方式加载进来。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<h3 id="Jinja2"><a href="#Jinja2" class="headerlink" title="Jinja2"></a>Jinja2</h3><p>使用Jinja2模板引擎，通过render_template函数返回一个html文件</p>
<p>这些html文件默认存储在项目根目录下的tempates文件夹中，这个目录是可以自定义的，创建Flask对象时，通过template_folder来设置。</p>
<blockquote><p>使用ajax技术，前端页面通过ajax向后端发送请求，后端返回用户的具体信息。使用模板，则可以不必使用ajax在前端请求数据，在使用render_template返回html时，会将用户的信息一起返回，由模板引擎根据用户的信息对html进行渲染，以达到相同的效果。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<h2 id="后端数据展示"><a href="#后端数据展示" class="headerlink" title="后端数据展示"></a>后端数据展示</h2><p>后端的数据放到前端展示，下面是项目的结构示意</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">flask_demo/</span><br><span class="line">├── __init__.py</span><br><span class="line">├── app.py</span><br><span class="line">└── templates</span><br><span class="line">    └── welcome.html</span><br></pre></td></tr></table></figure>

<p>app.py 的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/welcome&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">welcome</span>():</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;welcome.html&#x27;</span>, name=<span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.run(port=<span class="number">5500</span>)</span><br></pre></td></tr></table></figure>

<p>welcome.html的内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>北京欢迎你<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>北京欢迎你,<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="响应对象"><a href="#响应对象" class="headerlink" title="响应对象"></a>响应对象</h2><p>是几个常见的视图返回数据的方式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify, render_template, Response</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/text&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_text</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;返回文本&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/dict&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_dict</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;state&#x27;</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/json&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_json</span>():</span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;state&#x27;</span>: <span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/html&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_html</span>():</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/response&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_resonponse</span>():</span><br><span class="line">    <span class="keyword">return</span> Response(<span class="string">&#x27;Not Found&#x27;</span>, status=<span class="number">404</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(port=<span class="number">5566</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>get_text 返回一个字符串</li>
<li>get_dict 返回一个字典</li>
<li>get_json 返回一个json格式的字符串</li>
<li>get_html 返回一个模板</li>
<li>get_resonponse 返回一个Response对象</li>
</ol>
<blockquote><p>使用谷歌浏览器来查看这几个http响应的类型，1， 4， 5 的Content-Type 是  text&#x2F;html，2，3的Content-Type  是application&#x2F;json。这说明，flask会根据视图函数的返回值类型，来决定最终的Content-Type。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>Response是Flask中默认使用的响应对象</p>
<p>默认情况下设置为具有HTML mimetype。通常情况下，你不必自己创建这个对象，因为flask.flask.make_response会帮你处理这个问题。</p>
<p>如果你想替换所使用的响应对象，你可以将其子类化，并将 flask.flask.response_class设置为你的子类。</p>
<h2 id="1-make-response"><a href="#1-make-response" class="headerlink" title="1. make_response"></a>1. make_response</h2><p>视图函数的返回值，最终会传递给make_response方法，在该方法中，对返回值的类型进行判断，并根据返回值的不同做相应的处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_response</span>(<span class="params">self, rv</span>):</span><br><span class="line">    status = headers = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># unpack tuple returns</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(rv, <span class="built_in">tuple</span>):</span><br><span class="line">        len_rv = <span class="built_in">len</span>(rv)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># a 3-tuple is unpacked directly</span></span><br><span class="line">        <span class="keyword">if</span> len_rv == <span class="number">3</span>:</span><br><span class="line">            rv, status, headers = rv</span><br><span class="line">        <span class="comment"># decide if a 2-tuple has status or headers</span></span><br><span class="line">        <span class="keyword">elif</span> len_rv == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(rv[<span class="number">1</span>], (Headers, <span class="built_in">dict</span>, <span class="built_in">tuple</span>, <span class="built_in">list</span>)):</span><br><span class="line">                rv, headers = rv</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rv, status = rv</span><br><span class="line">        <span class="comment"># other sized tuples are not allowed</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(</span><br><span class="line">                <span class="string">&quot;The view function did not return a valid response tuple.&quot;</span></span><br><span class="line">                <span class="string">&quot; The tuple must have the form (body, status, headers),&quot;</span></span><br><span class="line">                <span class="string">&quot; (body, status), or (body, headers).&quot;</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># the body must not be None</span></span><br><span class="line">    <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> TypeError(</span><br><span class="line">            <span class="string">&quot;The view function did not return a valid response. The&quot;</span></span><br><span class="line">            <span class="string">&quot; function either returned None or ended without a return&quot;</span></span><br><span class="line">            <span class="string">&quot; statement.&quot;</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># make sure the body is an instance of the response class</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(rv, self.response_class):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(rv, (text_type, <span class="built_in">bytes</span>, <span class="built_in">bytearray</span>)):</span><br><span class="line">            <span class="comment"># let the response class set the status and headers instead of</span></span><br><span class="line">            <span class="comment"># waiting to do it manually, so that the class can handle any</span></span><br><span class="line">            <span class="comment"># special logic</span></span><br><span class="line">            rv = self.response_class(rv, status=status, headers=headers)</span><br><span class="line">            status = headers = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(rv, <span class="built_in">dict</span>):</span><br><span class="line">            rv = jsonify(rv)</span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">isinstance</span>(rv, BaseResponse) <span class="keyword">or</span> <span class="built_in">callable</span>(rv):</span><br><span class="line">            <span class="comment"># evaluate a WSGI callable, or coerce a different response</span></span><br><span class="line">            <span class="comment"># class to the correct type</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                rv = self.response_class.force_type(rv, request.environ)</span><br><span class="line">            <span class="keyword">except</span> TypeError <span class="keyword">as</span> e:</span><br><span class="line">                new_error = TypeError(</span><br><span class="line">                    <span class="string">&quot;&#123;e&#125;\nThe view function did not return a valid&quot;</span></span><br><span class="line">                    <span class="string">&quot; response. The return type must be a string, dict, tuple,&quot;</span></span><br><span class="line">                    <span class="string">&quot; Response instance, or WSGI callable, but it was a&quot;</span></span><br><span class="line">                    <span class="string">&quot; &#123;rv.__class__.__name__&#125;.&quot;</span>.<span class="built_in">format</span>(e=e, rv=rv)</span><br><span class="line">                )</span><br><span class="line">                reraise(TypeError, new_error, sys.exc_info()[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(</span><br><span class="line">                <span class="string">&quot;The view function did not return a valid&quot;</span></span><br><span class="line">                <span class="string">&quot; response. The return type must be a string, dict, tuple,&quot;</span></span><br><span class="line">                <span class="string">&quot; Response instance, or WSGI callable, but it was a&quot;</span></span><br><span class="line">                <span class="string">&quot; &#123;rv.__class__.__name__&#125;.&quot;</span>.<span class="built_in">format</span>(rv=rv)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># prefer the status if it was provided</span></span><br><span class="line">    <span class="keyword">if</span> status <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(status, (text_type, <span class="built_in">bytes</span>, <span class="built_in">bytearray</span>)):</span><br><span class="line">            rv.status = status</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rv.status_code = status</span><br><span class="line"></span><br><span class="line">    <span class="comment"># extend existing headers with provided headers</span></span><br><span class="line">    <span class="keyword">if</span> headers:</span><br><span class="line">        rv.headers.extend(headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rv</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看到，当视图返回一个字典时，flask会自动使用jsonify进行转换。通常情况下，我们不会在视图中直接返回Response对象，因为make_response会帮我们将返回值封装成Response。但如果你自己相对返回值进行特殊处理，那么直接返回Response对象是可行的，就像get_resonponse函数那样操作。</p>
<p>↑ 以上均复制自COOLPYTHON</p>
<h2 id="2-利用Response返回图片"><a href="#2-利用Response返回图片" class="headerlink" title="2. 利用Response返回图片"></a>2. 利用Response返回图片</h2><p>直接构造Response对象可以为接口返回图片数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/image&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">image</span>():</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;static/public/pic/coolpython.png&quot;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    resp = Response(f.read(), mimetype=<span class="string">&quot;image/jpeg&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure>

<p>若不直接创建Response对象，那么你就无法设置mimetype首部</p>
<h2 id="3-自定义Response"><a href="#3-自定义Response" class="headerlink" title="3. 自定义Response"></a>3. 自定义Response</h2><p>也可自定义Response类，进行个性化的处理，但这个类必须继承Response</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ImageResponse</span>(<span class="title class_ inherited__">Response</span>):</span><br><span class="line">    default_mimetype = <span class="string">&#x27;image/jpeg&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/image&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">image</span>():</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;static/public/pic/coolpython.png&quot;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    resp = ImageResponse(f.read())</span><br><span class="line">    <span class="keyword">return</span> resp</span><br></pre></td></tr></table></figure>

<p>上面定义的ImageResponse类里，default_mimetype 就是image&#x2F;jpeg， 因此在视图中创建ImageResponse对象时无需再设置mimetype。</p>
<h2 id="4-替换response-class"><a href="#4-替换response-class" class="headerlink" title="4. 替换response_class"></a>4. 替换response_class</h2><p>flask对象有一个response_class属性，默认是Response，可以将其替换成自定义的响应类。</p>
<p>假设需要实现一个图片服务，返回的数据都是图片，mimetype都是image&#x2F;jpeg，那么可以这样做</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ImageResponse</span>(<span class="title class_ inherited__">Response</span>):</span><br><span class="line">    default_mimetype = <span class="string">&#x27;image/jpeg&#x27;</span></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.response_class = ImageResponse</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/image&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">image</span>():</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;static/public/pic/coolpython.png&quot;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> f.read()</span><br></pre></td></tr></table></figure>

<p>在image函数，直接返回从图片中读取的数据返回，这些数据最终会被ImageResponse类处理。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask[相逢]</title>
    <url>/2023/07/06/2023-7-6-Flask-5/</url>
    <content><![CDATA[<h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><p>用户使用表单向服务器提交信息，例如最常见的登录。</p>
<p>那么如何在html页面里提交表单，以及flask如何处理表单数据？以及表单敏感信息如何存储。</p>
<p>HTML登录页面中的form表单</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>action 设置提交的url</li>
<li>method 设置请求的方法</li>
<li>input标签的type设置为password时，在页面输入信息时不会显示明文</li>
</ul>
<p>服务端接收表单信息的方式如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/login&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_login</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&#x27;login.html&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        name = request.form[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">        password = request.form[<span class="string">&#x27;password&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> name == <span class="string">&#x27;python&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>, name=name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;/login&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>通过request.form来获取表单信息，然后对用户输入的用户名和密码做校验。为了演示，这里省去了数据库查询的逻辑，简化了过程。</p>
<p>生产环境下，用户的密码也并不是明文存储，例子注册网站账号时，填写的密码是888888，网站不会明文存储这个密码，简易的方法为存储它的md5值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">password = <span class="string">&#x27;888888&#x27;</span></span><br><span class="line">bpwd = <span class="built_in">bytes</span>(password, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">m = hashlib.md5()</span><br><span class="line">m.update(bpwd)</span><br><span class="line"></span><br><span class="line">md5_pwd = m.hexdigest()</span><br><span class="line"><span class="built_in">print</span>(md5_pwd)</span><br></pre></td></tr></table></figure>

<p>888888的md5值是 21218cca77804d2ba1922c33e0151105，这样，即便你在数据库里看到这个数值，你也不知道它真实的密码是什么。</p>
<blockquote><p>关于md5：md5并非加密算法，而是密码散列函数，它是一种单向函数，也就是说极其难以由散列函数输出的结果，回推输入的数据是什么，但是同一个值经过md5计算后的值是不会发生变化的。</p>
<p>这样，你只要记住21218cca77804d2ba1922c33e0151105是888888的md5值，就可以对user表进行撞库处理了。</p>
<p>关于网上所谓的md5解密，其实就是事先掌握了海量的密码和与之对应的md5值，然后通过md5反向查找原始密码。</p>
<p>md5值作为密码不够安全，你可以使用werkzeug.security模块里的generate_password_hash和check_password_hash函数。</p>
<p>generate_password_hash是密码加盐哈希函数，对同一个密码，每一次加密都会得到不同的值。generate_password_hash是密码验证函数，而并非计算出原始密码。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>



<p>下面是一段示例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.security <span class="keyword">import</span> generate_password_hash, check_password_hash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对密码进行加密</span></span><br><span class="line">password = generate_password_hash(<span class="string">&quot;888888&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(password)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查密码是否正确</span></span><br><span class="line">result = check_password_hash(password, <span class="string">&#x27;888888&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>多次运行你就会发现，每次得到的password都是不同的，但是check_password_hash都能正确验证。</p>
<p>使用这两个函数，就绝对能够防止破解了么？并非如此，黑客还是可以在得到user表后进行暴力破解，但是暴力破解的难度和成本都增加了。</p>
<p>888888经过generate_password_hash函数处理后，会得到无数种加密结果，因此，就无法维护一个加密结果与原始密码的映射表，当你拿到一个加密后的密码后，你当然可以使用check_password_hash(password, ‘888888’)来判断这个密码是不是888888加密后的结果。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask[接洽]</title>
    <url>/2023/07/06/2023-7-6-Flask-6/</url>
    <content><![CDATA[<h1 id="Flask上传文件"><a href="#Flask上传文件" class="headerlink" title="Flask上传文件"></a>Flask上传文件</h1><p>文件上传功能需要学习的范围：</p>
<ul>
<li>文件类型，大小限制</li>
<li>多文件上传</li>
<li>文件名称安全检查</li>
</ul>
<h2 id="1-文件大小限制"><a href="#1-文件大小限制" class="headerlink" title="1.文件大小限制"></a>1.文件大小限制</h2><p>出于资源考虑，需要对用户上传的文件大小进行限制</p>
<p>flask中的实现代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, Request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config[<span class="string">&#x27;MAX_CONTENT_LENGTH&#x27;</span>] = <span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br></pre></td></tr></table></figure>

<p>此代码的作用是阻止超过16M大小的文件上传<br>如果使用nginx为你的flask服务做反向代理，那么nginx也需要进行配置，将nginx client_max_body_size 修改为合适的数值，该值默认是1M</p>
<h2 id="2-文件类型检查"><a href="#2-文件类型检查" class="headerlink" title="2. 文件类型检查"></a>2. 文件类型检查</h2><p>如果希望用户只上传jpg类型的图片，那么最简单的办法是对用户的文件名称后缀做检查</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ALLOWED_EXTENSIONS = <span class="built_in">set</span>([<span class="string">&#x27;jpg&#x27;</span>])</span><br><span class="line">file = request.files[<span class="string">&#x27;file&#x27;</span>]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allowed_file</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;.&#x27;</span> <span class="keyword">in</span> filename <span class="keyword">and</span> \</span><br><span class="line">           filename.rsplit(<span class="string">&#x27;.&#x27;</span>, <span class="number">1</span>)[<span class="number">1</span>] <span class="keyword">in</span> ALLOWED_EXTENSIONS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断文件类型是否符合要求</span></span><br><span class="line">file_ok = allowed_file(file.filename)</span><br></pre></td></tr></table></figure>

<p>此方法完全依赖用户上传的文件名称，无法应对简单的修改后缀名实现上传。</p>
<p>更准确稳妥的方法是通过检查文件内容来判断文件类型：</p>
<blockquote><p>python中有一个filetype库可以根据文件内容对文件类型进行判断，其原理是读取文件的前262字节的内容，而不同类型的文件拥有独特的文件头，关于文件头可以查阅这篇文章 <a href="https://blog.csdn.net/xiangshangbashaonian/article/details/80156865">https://blog.csdn.net/xiangshangbashaonian/article/details/80156865</a> ，filetype正是利用了不同文件头的内容不同进而判断一个文件的类型，下面是一段示例代码</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> filetype</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kind = filetype.guess(<span class="string">&#x27;1.jpeg&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;File extension: %s&#x27;</span> % kind.extension)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;File MIME type: %s&#x27;</span> % kind.mime)</span><br></pre></td></tr></table></figure>

<h2 id="3-文件上传示例"><a href="#3-文件上传示例" class="headerlink" title="3. 文件上传示例"></a>3. 文件上传示例</h2><p>常规上传操作示例</p>
<h3 id="upload-html"><a href="#upload-html" class="headerlink" title="upload.html"></a>upload.html</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>上传文件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;uploadfile&quot;</span> <span class="attr">method</span>=<span class="string">post</span> <span class="attr">enctype</span>=<span class="string">multipart/form-data</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">file</span> <span class="attr">name</span>=<span class="string">file</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">submit</span> <span class="attr">value</span>=<span class="string">Upload</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>处理文件上传的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ALLOWED_EXTENSIONS = &#123;<span class="string">&#x27;txt&#x27;</span>, <span class="string">&#x27;pdf&#x27;</span>, <span class="string">&#x27;png&#x27;</span>, <span class="string">&#x27;jpg&#x27;</span>, <span class="string">&#x27;jpeg&#x27;</span>, <span class="string">&#x27;gif&#x27;</span>&#125;</span><br><span class="line">UPLOAD_FOLDER = <span class="string">&#x27;./upload&#x27;</span> <span class="comment"># 保存文件的路径，需要手动创建这个文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">allowed_file</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;.&#x27;</span> <span class="keyword">in</span> filename <span class="keyword">and</span> \</span><br><span class="line">           filename.rsplit(<span class="string">&#x27;.&#x27;</span>, <span class="number">1</span>)[<span class="number">1</span>] <span class="keyword">in</span> ALLOWED_EXTENSIONS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/uploadfile&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_upload</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        file = request.files[<span class="string">&#x27;file&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> file <span class="keyword">and</span> allowed_file(file.filename):</span><br><span class="line">            filename = secure_filename(file.filename)</span><br><span class="line">            <span class="comment"># filename = file.filename</span></span><br><span class="line">            file.save(os.path.join(UPLOAD_FOLDER, filename))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;upload.html&#x27;</span>) <span class="comment"># 模板文件需要存在template文件夹里</span></span><br></pre></td></tr></table></figure>

<p>启动服务后，在浏览器里输入 <a href="http://127.0.0.1:5000/uploadfile">http://127.0.0.1:5000/uploadfile</a> ,然后选择一个文件并点击upload按钮，就完成一次上传，你可以在项目的upload文件夹中找到你上传的文件</p>
<h2 id="4-文件名称安全检查"><a href="#4-文件名称安全检查" class="headerlink" title="4. 文件名称安全检查"></a>4. 文件名称安全检查</h2><blockquote><p>黑客们会通过修改上传文件的名称来达到修改文件存储位置的目的，如此一来就可以覆盖掉你服务器上的一个文件，这是十分危险的事情。</p>
<p>使用页面的表单进行文件上传，你在服务端获得文件名字就是你上传的文件名字，但黑客可以直接向你的服务器发送文件上传的请求，进而绕过网页提交，这时，他就可以修改上传文件的名字了。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<p>使用requests上传文件并制定文件名称</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://127.0.0.1:5000/uploadfile&#x27;</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;1.jpeg&quot;</span>, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">files = &#123;<span class="string">&#x27;file&#x27;</span>: (<span class="string">&#x27;../new_name.jpg&#x27;</span>, file)&#125;</span><br><span class="line">response = requests.post(url, files=files)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>

<p>接下来，你需要修改第3节中的do_upload函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/uploadfile&#x27;</span>, methods=[<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_upload</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        file = request.files[<span class="string">&#x27;file&#x27;</span>]</span><br><span class="line">        <span class="keyword">if</span> file <span class="keyword">and</span> allowed_file(file.filename):</span><br><span class="line">            <span class="comment"># filename = secure_filename(file.filename)</span></span><br><span class="line">            filename = file.filename</span><br><span class="line">            file.save(os.path.join(UPLOAD_FOLDER, filename))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;upload.html&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>将原本使用secure_filename函数对文件名称做处理，改为直接使用file.filename</p>
<p>执行上传脚本发现，结果是存储到了upload的上一层文件夹中</p>
<p> <code>files = &#123;&#39;file&#39;: (&#39;../new_name.jpg&#39;, file)&#125;</code></p>
<p>原因为不使用secure_filename函数，filename的值就是上传脚本里设置的值 “..&#x2F;new_name.jpg”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.path.join(UPLOAD_FOLDER, filename)</span><br></pre></td></tr></table></figure>

<p>使用join函数得到的结果就是”.&#x2F;upload&#x2F;..&#x2F;new_name.jpg”,连续两个点表示跳跃到上一层目录，因此，文件就保存到了upload的上一层目录。</p>
<p>因此直接使用filename存在一定的缺陷，而使用secure_filename函数处理文件名称，则可以获得安全的文件名称。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(secure_filename(<span class="string">&#x27;../new_name.jpg&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h2 id="5-flask多文件上传"><a href="#5-flask多文件上传" class="headerlink" title="5. flask多文件上传"></a>5. flask多文件上传</h2><p>多文件上传，仅需要在form表单里增加一个file标签即可</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;uploadfile&quot;</span> <span class="attr">method</span>=<span class="string">post</span> <span class="attr">enctype</span>=<span class="string">multipart/form-data</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">file</span> <span class="attr">name</span>=<span class="string">file</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">file</span> <span class="attr">name</span>=<span class="string">file</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">submit</span> <span class="attr">value</span>=<span class="string">Upload</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>服务端的处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file_lst = request.files.getlist(<span class="string">&#x27;file&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>file_lst 存储的是上传的所有文件数据，剩下的，仅需要写一个for循环即可处理</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask[邂逅]</title>
    <url>/2023/07/06/2023-7-6-Flask-7/</url>
    <content><![CDATA[<h1 id="flask-下载文件"><a href="#flask-下载文件" class="headerlink" title="flask 下载文件"></a>flask 下载文件</h1><p>flask提供了两个可进行下载的函数：send_from_directory 和 send_file</p>
<h2 id="send-from-directory"><a href="#send-from-directory" class="headerlink" title="send_from_directory"></a>send_from_directory</h2><p>send_from_directory函数内部调用了send_file，可以认为，真正执行下载操作的其实是send_file，那么send_from_directory存在的意义是什么呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">send_from_directory</span>(<span class="params">directory, filename, **options</span>):</span><br><span class="line">    filename = safe_join(directory, filename)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isabs(filename):</span><br><span class="line">        filename = os.path.join(current_app.root_path, filename)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(filename):</span><br><span class="line">            <span class="keyword">raise</span> NotFound()</span><br><span class="line">    <span class="keyword">except</span> (TypeError, ValueError):</span><br><span class="line">        <span class="keyword">raise</span> BadRequest()</span><br><span class="line">    options.setdefault(<span class="string">&#x27;conditional&#x27;</span>, <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> send_file(filename, **options)</span><br></pre></td></tr></table></figure>

<p>上面为send_from_directory函数的全部代码，在调用send_file函数之前，它做的最重要的事情就是获得一个安全的filename。</p>
<blockquote><p>下载文件的名字，为用户发请求时传给后端的，如果直接使用客户端发送的文件名字，则存在安全隐患。</p>
<p>关于这个安全隐患，其本质都是利用地址拼接这个动作修改实际操作文件的地址，为了防止黑客恶意下载，函数第一行代码便是使用safe_join函数，防止黑客通过修改filename的值达到下载关键文件的目的。</p>
<p>因此，实际生产环境下，推荐使用send_from_directory函数</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/route.html">www.coolpython.net/flask_tutorial/basic/route.html</a></cite></footer></blockquote>

<h2 id="send-file"><a href="#send-file" class="headerlink" title="send_file"></a>send_file</h2><p>使用send_file例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> send_from_directory, send_file</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/download&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>():</span><br><span class="line">    <span class="keyword">return</span> send_file(<span class="string">&#x27;./data/3.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>send_file函数会调用guess_type函数获取文件的类型，设置响应头里的content-type。</p>
<p>在浏览器里打开 <a href="http://127.0.0.1:5000/download">http://127.0.0.1:5000/download</a> 这个url，会直接进行下载，但下载的文件名字并不是所期望的3.xlsx，浏览器在保存时用的名字是download.xlsx。 </p>
<p>如果希望浏览器下载保存文件时使用的名字是3.xlsx,则需要将参数as_attachment设置为True。</p>
<p>秘密藏在响应头的首部中，由于设置了as_attachment为True，flask会添加Content-Disposition</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Content-Disposition: attachment; filename=3.xlsx</span><br></pre></td></tr></table></figure>

<p>这样，浏览器便明白文件名是什么。</p>
<p>如果希望浏览器以其他的名字保存该文件，则可以单独设置attachment_filename 参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/download&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>():</span><br><span class="line">    <span class="keyword">return</span> send_file(<span class="string">&#x27;./data/3.xlsx&#x27;</span>,</span><br><span class="line">                     as_attachment=<span class="literal">True</span>,</span><br><span class="line">                     attachment_filename=<span class="string">&#x27;test.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这样，浏览器就会使用test.xlsx来保存文件。</p>
<h2 id="处理下载文件中出现中文的乱码问题"><a href="#处理下载文件中出现中文的乱码问题" class="headerlink" title="处理下载文件中出现中文的乱码问题"></a>处理下载文件中出现中文的乱码问题</h2><p>当attachment_filename参数设置为中文文件名时，flask会报错误</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">UnicodeEncodeError: &#x27;latin-1&#x27; codec can&#x27;t encode characters in position 43-44: ordinal not in range(256)</span><br></pre></td></tr></table></figure>

<p>引发这个问题的原因，可以一直追溯到http协议，按照协议规定，HTTP Header 中的文本数据必须是 ASCII 编码的，为了解决header出现其他编码的问题，浏览器各显神通，这里的原理与历史可以参考这篇文章<br> <a href="https://blog.csdn.net/u011090495/article/details/18815777">https://blog.csdn.net/u011090495/article/details/18815777</a></p>
<p>我这里直接给出解决办法 <code>COOLPYTHON NB</code> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/download&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download</span>():</span><br><span class="line">    filename = quote(<span class="string">&quot;测试表格.xlsx&quot;</span>)</span><br><span class="line">    rv = send_file(<span class="string">&#x27;./data/3.xlsx&#x27;</span>,</span><br><span class="line">                     as_attachment=<span class="literal">True</span>,</span><br><span class="line">                     attachment_filename=filename)</span><br><span class="line"></span><br><span class="line">    rv.headers[<span class="string">&#x27;Content-Disposition&#x27;</span>] += <span class="string">&quot;; filename*=utf-8&#x27;&#x27;&#123;&#125;&quot;</span>.<span class="built_in">format</span>(filename)</span><br><span class="line">    <span class="keyword">return</span> rv</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask[结交]</title>
    <url>/2023/07/07/2023-7-7-Flask-9/</url>
    <content><![CDATA[<h1 id="flask的-errorhandler装饰器实现应用错误处理"><a href="#flask的-errorhandler装饰器实现应用错误处理" class="headerlink" title="flask的 errorhandler装饰器实现应用错误处理"></a>flask的 errorhandler装饰器实现应用错误处理</h1><p>flask提供了一个专门用来处理应用错误的装饰器errorhandler。 使用此装饰器，可以轻松的实现对系统错误异常的捕捉和处理。</p>
<p>errorhandler可以传入http code,例如404，500。这是比较常见的请求错误，如果能够为这种错误提供专门的页面，无疑会提高用户的体验。除了http code， 也可以传入异常类，捕捉特定的异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="number">0</span>/<span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/user&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">user</span>():</span><br><span class="line">    <span class="keyword">raise</span> ValueError</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;user&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(<span class="params"><span class="number">404</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">error</span>(<span class="params">e</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;捕捉到404&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;error&#x27;</span>, <span class="number">404</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(<span class="params">ZeroDivisionError</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">catch_except</span>(<span class="params">e</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;捕捉到异常&#x27;</span>+ <span class="built_in">str</span>(e), <span class="number">500</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(<span class="params">Exception</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">catch_all_except</span>(<span class="params">e</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;捕捉任意异常&#x27;</span>+ <span class="built_in">str</span>(e), <span class="number">500</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<blockquote><p>可以捕捉特定的异常，做特定的处理，也可以捕捉任意异常，只需要传入参数Exception即可。</p>
<p>如果某个特定异常被抛出后，有专门处理的函数，那么优先由这个函数进行处理。</p>
<p>例如视图函数index抛出ZeroDivisionError，那么优先由catch_except函数进行处理，如果没有专门的处理函数，则由catch_all_except进行处理。</p>
<p>如果错误发生在蓝图里，则优先由在蓝图里注册的错误处理器进行处理，404错误不在其中，因为404错误发生的更早，蓝图里检测不到。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/flask-errorhandler.html">www.coolpython.net/flask_tutorial/basic/flask-errorhandler.html</a></cite></footer></blockquote>

<h1 id="flask-web开发中使用cookie"><a href="#flask-web开发中使用cookie" class="headerlink" title="flask web开发中使用cookie"></a>flask web开发中使用cookie</h1><p>在web编程中，cookie和session的区别与联系并不容易弄懂。cookie与session是一项只和终端用户联系紧密的技术。</p>
<h2 id="1-http协议无状态"><a href="#1-http协议无状态" class="headerlink" title="1. http协议无状态"></a>1. http协议无状态</h2><p>首先，http协议是一个无状态的协议。所谓的无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态，这意味着每个请求都是独立的。</p>
<p>无状态就会产生一些问题。假设你编写了一个网站，想要记录一下用户第一次访问你网站的时间，当用户下一次访问时，你在页面里显示他第一次登录的时间。</p>
<p>看起来似乎很简单，但现在要再追加一个条件，用户不会在网站上注册，下一次访问的时候也不会登录，就变难了。这个事情的难点在于，我们无法知道用户是否是第一次来访问你的网站。换一个角度看，用户发起的请求里，有没有什么数据是可以唯一代表这个用户的。</p>
<p>这就是对http协议无状态的理解，不知道用户的状态，每一次请求对于你来说都是独立的，全新的，当连续收到3个请求时，我们无法知道这3个请求是一个人发了3次还是3个人各自发了一次。</p>
<h2 id="2-cookie的作用"><a href="#2-cookie的作用" class="headerlink" title="2. cookie的作用"></a>2. cookie的作用</h2><p>cookie技术可以解决以上的问题。</p>
<p>cookie是在服务端生成的，发送给客户端（浏览器），浏览器会保存cookie数据，等客户端再发起请求时，会在请求头里带上cookie信息。</p>
<p>服务端收到请求后，可以从请求头里拿到cookie， cookie里的信息就可以帮助服务端做一些重要的事情。</p>
<h2 id="2-1-怎么判断用户是第一次访问"><a href="#2-1-怎么判断用户是第一次访问" class="headerlink" title="2.1 怎么判断用户是第一次访问"></a>2.1 怎么判断用户是第一次访问</h2><p>很简单，服务端收到请求后，从请求头里尝试获取cookie，如果有，说明不是第一次来，如果没有，那就是第一次来。</p>
<p>我们先考虑第一次来的情况，既然是第一次，服务端需要获取当前时间，在响应头的cookie里设置这个时间，这样就把第一次访问网站的时间发送给了用户。</p>
<h2 id="2-2-cookie信息的保存与使用"><a href="#2-2-cookie信息的保存与使用" class="headerlink" title="2.2 cookie信息的保存与使用"></a>2.2 cookie信息的保存与使用</h2><p>浏览器收到服务端的response后，会把cookie信息保存起来，保存的动作，你感知不到，浏览器自己完成，不过你可以查看。</p>
<p>最关键的步骤来了，当你再一次访问服务时，浏览器发送请求时会自动的把cookie信息带上，这个动作你也感知不到，浏览器自己完成。</p>
<h2 id="2-3-服务端收到cookie"><a href="#2-3-服务端收到cookie" class="headerlink" title="2.3 服务端收到cookie"></a>2.3 服务端收到cookie</h2><p>假设存在cookie，说明不是第一次访问（手动清除的情况除外）。从请求头里拿到cookie，得到的内容是这个用户第一次访问服务时的时间，服务端可以在返回的数据里加上这个时间，告诉用户第一次访问网站的时间。</p>
<p>http协议的无状态特性严重的影响了web服务功能的开发，很多的请求和响应是需要承上启下的，为此，发展出来了cookie和session。</p>
<h2 id="3-flask-cookie-实践"><a href="#3-flask-cookie-实践" class="headerlink" title="3. flask cookie 实践"></a>3. flask cookie 实践</h2><p>下面使用flask框架实现第一节里的功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, make_response, request</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="comment"># 尝试获取 first_access cookie</span></span><br><span class="line">    first_access = request.cookies.get(<span class="string">&#x27;first_access&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> first_access <span class="keyword">is</span> <span class="literal">None</span>:        <span class="comment"># 没有first_access cookie， 是第一次来</span></span><br><span class="line">        first_access = datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">        res = make_response(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">        res.set_cookie(<span class="string">&#x27;first_access&#x27;</span>, first_access)        <span class="comment"># 在响应头里设置cookie</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">else</span>:       <span class="comment"># 不是第一次来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;你第一次访问这个网页的时间是: <span class="subst">&#123;first_access&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>启动服务后，在浏览器里访问 http:&#x2F;&#x2F;127.0.0.1:5000&#x2F; ， 页面里显示的是 “hello world”， 通过浏览器的开发者功能可以查看到服务端响应头信息
 <img src="http://www.coolpython.net/pictures/flask_tutorial/basic/flask-web-cookie-1631107263-0.jpg" alt="img"></p>
<p>服务端就是通过<strong>Set-Cookie</strong>首部来传输cookie信息的，浏览器收到数据后，就会将其保存下来。</p>
<p>接下来，你再次在浏览器里访问http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;，页面里显示的内容是 “你第一次访问这个网页的时间是: 2021-09-03 11:31:00”，通过浏览器的开发者工具可以查看到http请求的首部信息
 <img src="http://www.coolpython.net/pictures/flask_tutorial/basic/flask-web-cookie-1631107263-1.jpg" alt="img"></p>
<p>可以看到，cookie里有first_access， 服务端就是根据这里的信息才知道你第一次访问的时间。</p>
<h2 id="4-遗留问题"><a href="#4-遗留问题" class="headerlink" title="4. 遗留问题"></a>4. 遗留问题</h2><p>本文的重点是讲述cookie的作用并使用flask框架实现一个简单的web服务实现显示用户第一次访问时间的功能，由于篇幅有限，还有一些遗留问题需等到后续的文章进行讲解：</p>
<ol>
<li>如果关闭浏览器，再次打开浏览器，就不能显示我第一次访问的时间了，这个问题涉及到cookie的过期时间问题</li>
<li>cookie里的信息都是明文保存的，这很危险，这个问题涉及到cookie加密</li>
<li>cookie与session有什么区别呢？</li>
</ol>
<p><code>本文均摘自COOLPYTHON，略有修改。</code></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask[认同]</title>
    <url>/2023/07/07/2023-7-7-Flask-8/</url>
    <content><![CDATA[<h1 id="使用蓝图-blueprint"><a href="#使用蓝图-blueprint" class="headerlink" title="使用蓝图 blueprint"></a>使用蓝图 blueprint</h1><h2 id="1-一个最小的应用"><a href="#1-一个最小的应用" class="headerlink" title="1. 一个最小的应用"></a>1. 一个最小的应用</h2><p>蓝图(blueprint)技术，可以实现flask应用的模块划分。</p>
<p>在组织flask代码时，有<strong>功能式架构</strong>和<strong>分区式架构</strong>两种模式，使用蓝图，可以让项目架构更有层次，模块划分更便捷..</p>
<p>下面这个示例非常的小巧，但是能提供的内容非常的少。</p>
<p>在实际开发大型的flask应用时，我们会需要划分许多模块，提供很多的功能 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(port=<span class="number">5678</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-一个稍大点的flask应用"><a href="#2-一个稍大点的flask应用" class="headerlink" title="2. 一个稍大点的flask应用"></a>2. 一个稍大点的flask应用</h2><p>下面的flask应用里，有一个user模块专门提供和用户有关的功能。</p>
<p>例如用户注册，登录，登出，修改密码。</p>
<p>还有一个admin模块，用来做后台管理。</p>
<p>这个示例展示了如何在一个脚本里编写所有的模块，但这些视图函数并没有具体的实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># user模块</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/user/register&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;register&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/user/login&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;login&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/user/modify_password&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modify_password</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;modify_password&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># admin模块</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/admin/alluser&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alluser</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;alluser&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/admin/deluser&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deluser</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;deluser&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(port=<span class="number">5678</span>)</span><br></pre></td></tr></table></figure>

<p>和最小的flask应用相比，这个应用多了两个模块，5个视图函数，但还是非常小。</p>
<p>在实践项目中，子模块和视图函数会更多。因此，我们应该尽量避免将这些都写在同一个脚本中。</p>
<p>否则，这个脚本会非常的大，难以维护。</p>
<h2 id="3-BluePrint-蓝图技术"><a href="#3-BluePrint-蓝图技术" class="headerlink" title="3. BluePrint 蓝图技术"></a>3. BluePrint 蓝图技术</h2><p>蓝图技术，可以帮助你实现flask应用的模块划分。如果不划分模块或者模块划分不合理，会带来很多麻烦。</p>
<p>第2小节的应用划分出两个模块，划分后，项目结构不再是一个单一的脚本，一个模块拥有一个属于自己的文件目录，与之相关的代码都将写在这里，项目结构如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">blue-example/</span><br><span class="line">├── admin</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── views.py</span><br><span class="line">├── app.py</span><br><span class="line">└── user</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    └── views.py</span><br></pre></td></tr></table></figure>

<p>以下展示脚本内容</p>
<h3 id="3-1-app-py"><a href="#3-1-app-py" class="headerlink" title="3.1 app.py"></a>3.1 app.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> admin <span class="keyword">import</span> admin_blue</span><br><span class="line"><span class="keyword">from</span> user <span class="keyword">import</span> user_blue</span><br><span class="line"></span><br><span class="line">app.register_blueprint(admin_blue)</span><br><span class="line">app.register_blueprint(user_blue)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(port=<span class="number">5678</span>)</span><br></pre></td></tr></table></figure>

<p>app.py 代码干净整洁</p>
<h3 id="3-2-user模块"><a href="#3-2-user模块" class="headerlink" title="3.2 user模块"></a>3.2 user模块</h3><p><strong>user&#x2F;<strong>init</strong>.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint</span><br><span class="line"></span><br><span class="line">user_blue = Blueprint(<span class="string">&#x27;user&#x27;</span>, __name__, url_prefix=<span class="string">&#x27;/user&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br></pre></td></tr></table></figure>

<p><strong>user&#x2F;views.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> user <span class="keyword">import</span> user_blue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># user模块</span></span><br><span class="line"><span class="keyword">from</span> user <span class="keyword">import</span> user_blue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># user模块</span></span><br><span class="line"><span class="meta">@user_blue.route(<span class="params"><span class="string">&#x27;/register&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;register&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@user_blue.route(<span class="params"><span class="string">&#x27;/login&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;login&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@user_blue.route(<span class="params"><span class="string">&#x27;/modify_password&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modify_password</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;modify_password&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-admin"><a href="#3-3-admin" class="headerlink" title="3.3 admin"></a>3.3 admin</h3><p><strong>admin&#x2F;<strong>init</strong>.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">admin_blue = Blueprint(<span class="string">&#x27;admin&#x27;</span>, __name__, url_prefix=<span class="string">&#x27;/admin&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br></pre></td></tr></table></figure>

<p><strong>admin&#x2F;views.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> admin <span class="keyword">import</span> admin_blue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># admin模块</span></span><br><span class="line"><span class="meta">@admin_blue.route(<span class="params"><span class="string">&#x27;/alluser&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alluser</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;alluser&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@admin_blue.route(<span class="params"><span class="string">&#x27;/deluser&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deluser</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;deluser&#x27;</span></span><br></pre></td></tr></table></figure>

<p>第3小节的项目代码，多了一些模块的划分和文件目录。</p>
<p>看上去，比第2小节的代码变复杂了些，但这种“复杂”是值得的， 能得到整个项目清晰的结构，很好的控制了单个脚本的代码规模。</p>
<h2 id="4-两种代码组织形式"><a href="#4-两种代码组织形式" class="headerlink" title="4. 两种代码组织形式"></a>4. 两种代码组织形式</h2><p>蓝图在组织flask代码时，有两种形式</p>
<ol>
<li>功能式架构</li>
<li>分区式架构</li>
</ol>
<p>前面所展示的就是功能式架构，一个功能，一个模块组织成一个蓝图，他们共用相同的静态资源，静态资源放在static目录下。</p>
<p>本文所举实例太简单，因此没有创建静态资源，功能式架构类似于下面的结构</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">__init__.py</span><br><span class="line">static/</span><br><span class="line">templates/</span><br><span class="line">    home/</span><br><span class="line">    control_panel/</span><br><span class="line">    admin/</span><br><span class="line">views/</span><br><span class="line">    __init__.py</span><br><span class="line">    home.py</span><br><span class="line">    control_panel.py</span><br><span class="line">    admin.py</span><br><span class="line">models.py</span><br></pre></td></tr></table></figure>

<p>home, control_panel,admin 都是蓝图，他们共用static和 templates。</p>
<p>分区式架构，适用于子模块有特殊需要的情况，在创建蓝图构造Blueprint对象时，可以指定static和templates。</p>
<p>结构示例：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">yourapp/</span><br><span class="line">    __init__.py</span><br><span class="line">    admin/</span><br><span class="line">        __init__.py</span><br><span class="line">        views.py</span><br><span class="line">        static/</span><br><span class="line">        templates/</span><br><span class="line">    home/</span><br><span class="line">        __init__.py</span><br><span class="line">        views.py</span><br><span class="line">        static/</span><br><span class="line">        templates/</span><br><span class="line">    control_panel/</span><br><span class="line">        __init__.py</span><br><span class="line">        views.py</span><br><span class="line">        static/</span><br><span class="line">        templates/</span><br><span class="line">    models.py</span><br></pre></td></tr></table></figure>

<blockquote><p>试想，如果admin, home， control_panel有各自不同的页面样式和风格，那么他们就需要不同的静态资源，css,  javascript,每个模块拥有各自的静态资源就是一个合理的选择。这样组织，还有一个好处，一个模块，或者说一个蓝图拥有自身全部的资源，包括static和templates，那么它可以很容易从一个项目里拆分出来放在另一个项目中使用。</p>
<p>具体使用哪种组织架构，并没有强制要求，完全是开发人员随心所欲的，重要的是从项目管理的角度出发，哪一种更利于你所项目的管理，就用哪一种。</p>
<footer><strong>@COOLPYTHON</strong><cite><a href="http://www.coolpython.net/flask_tutorial/basic/flask-blueprint.html">www.coolpython.net/flask_tutorial/basic/flask-blueprint.html</a></cite></footer></blockquote>

]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>速出文件扩展名</title>
    <url>/2022/10/26/2022-10-26-%E9%80%9F%E5%87%BA%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D/</url>
    <content><![CDATA[<h1 id="快速找出文件上传支持的扩展名"><a href="#快速找出文件上传支持的扩展名" class="headerlink" title="快速找出文件上传支持的扩展名"></a>快速找出文件上传支持的扩展名</h1><h2 id="1-抓包"><a href="#1-抓包" class="headerlink" title="1.抓包"></a>1.抓包</h2><p>使用BurpSuite将抓包的上传文件请求导出，存为譬如<strong>fuzz.txt</strong>的文件</p>

<h2 id="2-修改内容"><a href="#2-修改内容" class="headerlink" title="2.修改内容"></a>2.修改内容</h2><p>对其中进行<strong>模糊测试</strong>的内容修改</p>
<p>将其修改为 <strong>FUZZ</strong> 而在其后跑的字典会替换这里的<strong>FUZZ</strong>关键词</p>


<h2 id="3-字典小爆破"><a href="#3-字典小爆破" class="headerlink" title="3.字典小爆破"></a>3.字典小爆破</h2><p>使用一个包含各种后缀名的字典开始跑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffuf -request fuzz.txt -request-proto http -w /opt/SecLists/Fuzzing/extensions-most-common.fuzz.txt</span><br></pre></td></tr></table></figure>

<p>响应结果如图：</p>

<p>主要区别是Size的大小，这里有1115和1110两种。
可以看成1110是被允许的文件扩展名。</p>
<h2 id="4-优化命令"><a href="#4-优化命令" class="headerlink" title="4.优化命令"></a>4.优化命令</h2><p>增添 -ms 1110</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffuf -request fuzz.txt -request-proto http -w /opt/SecLists/Fuzzing/extensions-most-common.fuzz.txt -ms 1110</span><br></pre></td></tr></table></figure>
<p>现在仅显示支持的扩展名了</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/2022/10/26/2022-10-26-HTML/</url>
    <content><![CDATA[<h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><p>然后忘了要写什么了。</p>
]]></content>
  </entry>
  <entry>
    <title>CSS</title>
    <url>/2022/10/26/2022-10-26-CSS/</url>
    <content><![CDATA[<h1 id="什么是-CSS"><a href="#什么是-CSS" class="headerlink" title="什么是 CSS?"></a>什么是 CSS?</h1><ul>
<li><p>CSS 指层叠样式表 (Cascading Style Sheets)</p>
</li>
<li><p>1 样式定义如何显示 HTML 元素</p>
</li>
<li><p>2 样式通常存储在样式表中</p>
</li>
<li><p>3 把样式添加到 HTML 4.0 中，是为了解决内容与表现分离的问题</p>
<ul>
<li>外部样式表可以极大提高工作效率</li>
<li>外部样式表通常存储在 CSS 文件中</li>
<li>多个样式定义可层叠为一个</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全基础</title>
    <url>/2022/10/28/2022-10-28-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h1><p>1.网络协议本身的逻辑漏洞
2.通过网络分析工具，窃取
3.应用场景中网络协议的不同逻辑错误
4.基主机，操作系统，通信层，应用层</p>
<p>协议：
ARP协议：根据IP获取物理地址，无法在对等网络中解析数据包的来源</p>
<p>ARP欺骗：
通过MAC地址与目标IP相关联。以便于攻击者可以接收到与目标的任何？</p>
<p>2.DNS
 可将域名解析为IP
 缓存中毒，DNS欺骗</p>
<p>3.IP协议
  根据端到端的设计原则，IP为主机提供一种无连接、不可靠、尽力而为的数据包传输服务。
  吧发送的IP包中的源IP地址 改成被新人的友好主机的IP地址，进而实施攻击。</p>
<p>4.远程桌面协议 RDP
  RDP漏洞攻击，不用任何交互绕过认证，直接通过RDP协议进行连接，进而发送恶意代码。</p>
<p>5.简单邮件传输协议（SMTP）
通过电子邮件，发送垃圾软件和电子邮件。执行目录攻击，收集有效电子邮件。
根据漏洞进行缓冲区溢出攻击，特洛伊木马攻击和shell脚本攻击等，还可利用电子邮件发送垃圾邮件或恶意软件。</p>
<h1 id="软件和硬件的漏洞"><a href="#软件和硬件的漏洞" class="headerlink" title="软件和硬件的漏洞"></a>软件和硬件的漏洞</h1><p>1.软件
系统软件
应用软件
数据库软件</p>
<p>软件错误，软件缺陷，软件失效</p>
<ol start="2">
<li>硬件，通过通信线路传输，传输过程中也可能被截取</li>
<li>电磁波辐射中的信息也可能被接受
4.水电，空调，中断，会影响系统运行</li>
</ol>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 复习笔记（一）</title>
    <url>/2022/10/29/2022-10-29-Python%20%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="一、了解python"><a href="#一、了解python" class="headerlink" title="一、了解python"></a>一、了解python</h1><p>Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。</p>
<p>Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。</p>
<ul>
<li><p><strong>菜鸟教程的解释</strong>：</p>
</li>
<li><p><strong>Python 是一种解释型语言</strong>： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。</p>
</li>
<li><p><strong>Python 是交互式语言</strong>： 这意味着，您可以在一个 Python 提示符 &gt;&gt;&gt; 后直接执行代码。</p>
</li>
<li><p><strong>Python 是面向对象语言</strong>: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。</p>
</li>
<li><p><strong>Python 是初学者的语言</strong>：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。</p>
</li>
<li><p><strong>我的理解</strong>：首先python本身是一种高级语言，然后python的解释器会自动的将python源代码解释成计算机使用的机器语言运行。</p>
</li>
<li><p>Python 拥有自己的shell，可以交互式的调用解释器去运行自己的程序。</p>
</li>
<li><p>Python 是一个方便的面向对象语言，因为在设计之初便是一个面向对象的语言。</p>
</li>
<li><p>Python 是一门易上手的语言，他的语法和程序结构相对的简易，俗称简单易上手。</p>
</li>
</ul>
<h2 id="Python的缺点："><a href="#Python的缺点：" class="headerlink" title="Python的缺点："></a><strong>Python的缺点</strong>：</h2><ul>
<li>运转速度慢：Python的解释器需要在运行的适合去翻译自己的源代码，同时去管理底层细节，比如内存的管理，所以相对C和JAVA，Python要慢的多。</li>
<li>Python对多处理器的利用不充分：</li>
<li>由于具有名为全局解释器锁（global interpreter lock，GIL） 的特性，Python的标准版本并没有按照多内核来进行设计。尽管用Python可以运行并发进程，但如果需要“开箱即用”的并发能力，Python可能并不合适。</li>
<li>Python在编译时不检查变量类型</li>
<li>与某些其他编程语言不同，Python变量不像容器那样工作，而更像是引用整数、字符串、类实例等各类对象的标签。这表示这些对象本身虽然是有类型的，但引用它们的变量并没有与类型进行绑定。变量x可能在某一行代码中引用一个字符串，而在另一行代码中引用一个整数：Python将类型与对象关联，而不是与变量关联，这就导致Python解释器无法识别出变量类型不符的错误。假设变量count本来是用来保存整数的，但如果将字符串”two”赋给它，在Python里也完全没问题。这个问题让代码失去了一次免费的检错机会，但是实现了动态类型的灵活性。<blockquote><p>百度百科：Python解释器把源代码转换成称为字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行。</p>
<footer><strong>@百度百科</strong><cite><a href="https://baike.baidu.com/item/Python/407313?fr=aladdin">baike.baidu.com/item/Python/407313?fr=aladdin</a></cite></footer></blockquote></li>
</ul>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 </p>
<blockquote><p>UTF-8（8位元，Universal Character Set&#x2F;Unicode Transformation Format）是针对Unicode的一种可变长度字符编码。它可以用来表示Unicode标准中的任何字符，而且其编码中的第一个字节仍与ASCII相容，使得原来处理ASCII字符的软件无须或只进行少部分修改后，便可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。</p>
<footer><strong>@百度百科</strong><cite><a href="https://baike.baidu.com/item/UTF-8/481798?fr=aladdin">baike.baidu.com/item/UTF-8/481798?fr=aladdin</a></cite></footer></blockquote>


<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>标识符:</li>
<li>第一个字符必须是字母表中字母或下划线 _ 。</li>
<li>标识符的其他的部分由字母、数字和下划线组成。</li>
<li>标识符对大小写敏感。</li>
</ul>
<p>PS: 在 Python 3 中，可以用中文作为变量名，非 ASCII 标识符也是允许的了。 </p>
<p>#二、 Python基础语法</p>
<h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello,world"></a>Hello,world</h2><p>老规矩，对世界的第一声呼唤！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/python3 #这里说明了python解释器的路径（写死了）</span></span><br><span class="line"><span class="comment">#也可以写作#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#这样python文件会自动的去寻找解释器，增强了代码可移植性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python的输出语句，输出括号内的内容</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;Hello, World!&quot;</span>) <span class="comment">#这是一个注释</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello,World!</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>LOVE酱使用手册</title>
    <url>/2022/10/30/2022-10-30-LOVE_HELP/</url>
    <content><![CDATA[<ul>
<li><p>LOVE酱的使用文档</p>
</li>
<li><p>基础功能</p>
</li>
<li><p>聊天系统</p>
</li>
<li><p>教程系统</p>
</li>
<li><p>查询系统</p>
</li>
<li><p>约战系统</p>
</li>
<li><p>音乐系统</p>
</li>
<li><p>色图系统</p>
</li>
</ul>
]]></content>
      <categories>
        <category>LOVE酱</category>
      </categories>
      <tags>
        <tag>Bot</tag>
        <tag>LOVE酱</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 复习笔记（二）</title>
    <url>/2022/10/30/2022-10-30-Python%20%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本章主要简述了Python代码的写法和结构</p>
<h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><blockquote><p> Python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。
缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。</p>
<footer><strong>@菜鸟教程</strong><cite><a href="https://www.runoob.com/python3/python3-basic-syntax.html">www.runoob.com/python3/python3-basic-syntax.html</a></cite></footer></blockquote>

<p>  Python利用缩进来区分了代码块，在一段代码中，同一空格数的代码会被分为同一代码块中。</p>
<h2 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h2><p>  在Python中，我们可以将一段很长的代码利用反斜杠分为多行语句，这不会影响解释器的阅读。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">total = item_one + \</span><br><span class="line">       item_two + \</span><br><span class="line">       item_three</span><br></pre></td></tr></table></figure>

<p>  而如果语句被抱在例如 [], {}, 或 () 的这些括号中，则不需要使用\。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">otal = [<span class="string">&#x27;item_one&#x27;</span>, <span class="string">&#x27;item_two&#x27;</span>, <span class="string">&#x27;item_three&#x27;</span>,</span><br><span class="line">       <span class="string">&#x27;item_four&#x27;</span>, <span class="string">&#x27;item_five&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>懒得写了</p>
<blockquote><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。
空行与代码缩进不同，空行并不是 Python 语法的一部分。书写时不插入空行，Python 解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。
<strong>记住：空行也是程序代码的一部分。</strong></p>
<footer><strong>@菜鸟教程</strong><cite><a href="https://www.runoob.com/python3/python3-basic-syntax.html">www.runoob.com/python3/python3-basic-syntax.html</a></cite></footer></blockquote>

<h2 id="代码分隔符"><a href="#代码分隔符" class="headerlink" title="代码分隔符 ;"></a>代码分隔符 ;</h2><p>  在同一行中，我们也可以写多段代码，只需使用 ; 隔开即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;二月&quot;</span>);<span class="built_in">print</span>(<span class="string">&quot;NB&quot;</span>);<span class="built_in">print</span>(<span class="string">&quot;666~&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="代码组"><a href="#代码组" class="headerlink" title="代码组"></a>代码组</h2><p>  缩进相同的一个语句构成一个代码块，缩进相同的多个语句构成一个代码组。</p>
<blockquote><p>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。
我们将首行及后面的代码组称为一个子句(clause)。</p>
<footer><strong>@菜鸟教程</strong><cite><a href="https://www.runoob.com/python3/python3-basic-syntax.html">www.runoob.com/python3/python3-basic-syntax.html</a></cite></footer></blockquote>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>网络七层协议OSI</title>
    <url>/2022/10/31/2022-10-31-7%E5%B1%82/</url>
    <content><![CDATA[<h2 id="物理层（或称物理层，Physical-Layer）"><a href="#物理层（或称物理层，Physical-Layer）" class="headerlink" title="物理层（或称物理层，Physical Layer）"></a>物理层（或称物理层，Physical Layer）</h2><p>  是计算机网络OSI模型中最低的一层。物理层规定:为传输数据所需要的物理链路创建、维持、拆除，而提供具有机械的，电子的，功能的和规范的特性。简单的说，物理层确保原始的数据可在各种物理媒体上传输。局域网与广域网皆属第1、2层。物理层是OSI的第一层，它虽然处于最底层，却是整个开放系统的基础。物理层为设备之间的数据通信提供传输媒体及互连设备，为数据传输提供可靠的环境。如果您想要用尽量少的词来记住这个第一层，那就是“信号和介质”。OSI采纳了各种现成的协议，其中有RS-232、RS-449、X.21、V.35、ISDN、以及FDDI、IEEE802.3、IEEE802.4、和IEEE802.5的物理层协议。 </p>
<p>##数据链路层
  定义了在单个链路上如何传输数据。这些协议与被讨论的各种介质有关。示例：ATM，FDDI等。数据链路层必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧，帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。
物理链路（物理线路）：是由传输介质与设备组成的。原始的物理传输线路是指没有采用高层差错控制的基本的物理传输介质与设备。
数据链路（逻辑线路）：在一条物理线路之上，通过一些规程或协议来控制这些数据的传输，以保证被传输数据的正确性。实现这些规程或协议的硬件和软件加到物理线路，这样就构成了数据链路，从数据发送点到数据接收点所经过的传输途径。当采用复用技术时，一条物理链路上可以有多条数据链路。</p>
<p>##网络层
  是OSI参考模型中的第三层，介于传输层和数据链路层之间，它在数据链路层提供的两个相邻端点之间的数据帧的传送功能上，进一步管理网络中的数据通信，将数据设法从源端经过若干个中间节点传送到目的端，从而向传输层提供最基本的端到端的数据传送服务。主要内容有：虚电路分组交换和数据报分组交换、路由选择算法、阻塞控制方法、X.25协议、综合业务数据网（ISDN）、异步传输模式（ATM）及网际互连原理与实现。</p>
<p>##传输
  层是整个网络体系结构中的关键层次之一，主要负责向两个主机中进程之间的通信提供服务。由于一个主机同时运行多个进程，因此运输层具有复用和分用功能。传输层在终端用户之间提供透明的数据传输，向上层提供可靠的数据传输服务。传输层在给定的链路上通过流量控制、分段&#x2F;重组和差错控制来保证数据传输的可靠性。传输层的一些协议是面向链接的，这就意味着传输层能保持对分段的跟踪，并且重传那些失败的分段。</p>
<p>##会话层,表示层,应用层
  构成开放系统的高3层，面对应用进程提供分布处理，对话管理,信息表示,恢复最后的差错等. 会话层同样要担负应用进程服务要求，而运输层不能完成的那部分工作,给运输层功能差距以弥补.主要的功能是对话管理，数据流同步和重新同步。要完成这些功能,需要由大量的服务单元功能组合,已经制定的功能单元已有几十种.。如果您想要用尽量少的词来记住这第5层，那就是“对话和交谈”。</p>
<p>##表示层
  位于OSI分层结构的第六层，它的主要作用之一是为异种机通信提供一种公共语言，以便能进行互操作。这种类型的服务之所以需要，是因为不同的计算机体系结构使用的数据表示法不同。与第五层提供透明的数据运输不同，表示层是处理所有与数据表示及运输有关的问题，包括转换、加密和压缩。每台计算机可能有它自己的表示数据的内部方法，例如，ASCII码与EBCDIC码，所以需要表示层协定来保证不同的计算机可以彼此理解。</p>
<p>##网络七层协议（Open System Interconnection）
  简称OSI，是一个开放性的通行系统互连参考模型，他是一个定义的非常好的协议规范。OSI模型有7层结构，每层都可以有几个子层。 OSI的7层从上到下分别是 7 应用层 6 表示层 5 会话层 4 传输层 3 网络层 2 数据链路层 1 物理层 其中高层，即7、6、5、4层定义了应用程序的功能，下面3层，即3、2、1层主要面向通过网络的端到端的数据流。</p>
]]></content>
      <categories>
        <category>计算机网络技术</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>NoneBot设置教学功能</title>
    <url>/2022/11/01/2022-11-1-Nonebot%E8%AE%BE%E7%BD%AE%E6%95%99%E5%AD%A6%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<ul>
<li>话不多说，直接上代码
  在之前便设置了读取词库的方法，这样以来设计教学功能便简单许多了。
  原理：
  在事件响应的时候获取原消息纯文件，将命令与教学内容分割
  将教学内容直接写入文件</li>
</ul>
<p>问题：
    初步猜测由于异步编程问题，导致机器人必须重启才可以重新读取词库。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">start=on_command(cmd=<span class="string">&#x27;LOVE教学-&#x27;</span>,priority=<span class="number">50</span>)</span><br><span class="line"><span class="meta">@start.handle()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_func</span>(<span class="params">bot: Bot,event :Event</span>):</span><br><span class="line">   	<span class="keyword">try</span>:</span><br><span class="line">       	teaching=<span class="built_in">open</span>(FilePath(<span class="string">r&#x27;\introduce\cat.ini&#x27;</span>),<span class="string">&#x27;a+&#x27;</span>,encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">       	<span class="comment">#分割消息</span></span><br><span class="line">       	text = <span class="built_in">str</span>(event.get_message()).split(<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">       	teaching.write(<span class="built_in">str</span>(<span class="string">&#x27;\n&#x27;</span>+text[<span class="number">1</span>]))</span><br><span class="line">       	teaching.close()</span><br><span class="line">       	<span class="comment">#import os</span></span><br><span class="line">       	<span class="comment">#os.system(&#x27;exit&#x27;,r&#x27;cd C:\Users\33454\Desktop\LOVE&#x27;,&#x27;nb run&#x27;)</span></span><br><span class="line">       	<span class="keyword">await</span> start.send(<span class="string">&#x27;呐呐呐！教学成功~\n(被添加的新回复将在次日审核通过后才可使用哦~)&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">       	teaching.close()</span><br><span class="line">       	<span class="keyword">await</span> start.send(<span class="string">&#x27;教学失败，请检查命令格式&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Bot</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 复习笔记（三）</title>
    <url>/2022/10/31/2022-10-31-Python%20%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>  Python 中的变量不需要特意声明类型，只需要在使用前提前赋值。而变量所指向的内存中对象的类型会自动的根据变量所赋值的类型去自动声明。</p>
<p>  等号（&#x3D;）用来给变量赋值。</p>
<h2 id="多变量赋值"><a href="#多变量赋值" class="headerlink" title="多变量赋值"></a>多变量赋值</h2><p>  Python中可以同时给多个变量赋值同一个数，也可以给同时给多个不同的变量赋不同的值。
  如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a = b = c = <span class="number">1</span></span><br><span class="line">a,b,c=<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;三&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>基本数据类型</li>
</ul>
<p>Python3 中有六个标准的数据类型：</p>
<pre><code>-    Number（数字）
-    String（字符串）
-    List（列表）
-    Tuple（元组）
-    Set（集合）
-    Dictionary（字典）
</code></pre>
<p>其中，可分为不可变数据和可变数据:</p>
<ul>
<li><p>不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；</p>
</li>
<li><p>可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。</p>
</li>
</ul>
<hr>
<ul>
<li><p><strong>Number（数字）</strong>
int：整数
float：浮点数
bool：布尔值
complex：复数</p>
</li>
<li><p><strong>String（字符串）</strong></p>
</li>
<li><p><strong>List（列表）</strong></p>
</li>
<li><p><strong>Set（集合）</strong></p>
</li>
<li><p><strong>Dictionary（字典）</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>NoneBot读取猫猫词库方法</title>
    <url>/2022/11/01/2022-11-1-Nonebot%E8%AF%BB%E5%8F%96%E7%8C%AB%E7%8C%AB%E8%AF%8D%E5%BA%93%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>#话不多说，直接上代码#
##读取文件的方法##
为了保证Bot的可移植性，将词库文件存在机器人插件目录中，同时使用此函数读取根目录路径，与之相对路径合并，生成绝对路径，保证文件的可读性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getRootPath</span>():</span><br><span class="line">   	<span class="comment"># 获取文件目录</span></span><br><span class="line">   	curPath = os.path.abspath(os.path.dirname(__file__))</span><br><span class="line">   	<span class="comment"># 获取项目根路径，内容为当前项目的名字</span></span><br><span class="line">   	rootPath = curPath[:curPath.find(<span class="string">&#x27;love2&#x27;</span>) + <span class="built_in">len</span>(<span class="string">&#x27;love2&#x27;</span>)]</span><br><span class="line">   	<span class="keyword">return</span> rootPath</span><br><span class="line">FilePath_1=<span class="built_in">str</span>(getRootPath())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(FilePath_1)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">FilePath</span>(<span class="params">FilePath_2</span>):<span class="comment">#拼接捏</span></span><br><span class="line">   	FilePath_2=FilePath_1+FilePath_2</span><br><span class="line">   	<span class="keyword">return</span> FilePath_2</span><br></pre></td></tr></table></figure>

<p>##将文件生成字典##
主要分为三个步骤：
1.读取文件生成列表
2.读取每个列表利用分割符将每个列表再分成两个列表
3.遍历列表，将每两个列表生成一个字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">FG_2 = []</span><br><span class="line">Fi_1 = <span class="built_in">open</span>(FilePath(<span class="string">r&#x27;\introduce\cat.ini&#x27;</span>))</span><br><span class="line"><span class="comment">#第一步</span></span><br><span class="line">Fi_2 = Fi_1.readlines()</span><br><span class="line"><span class="comment">#第二步</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Fi_2)):</span><br><span class="line">   	FG_1 = Fi_2[i].split(<span class="string">&quot;=&quot;</span>)</span><br><span class="line">   	FG_2.append(FG_1[<span class="number">0</span>])</span><br><span class="line">   	FG_2.append(FG_1[<span class="number">1</span>])</span><br><span class="line">   	i = i + <span class="number">1</span></span><br><span class="line"><span class="comment">#第三步</span></span><br><span class="line">zd_1 = &#123;&#125;</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i&lt;=<span class="number">175</span>:</span><br><span class="line">   	i = i + <span class="number">2</span></span><br><span class="line">   	zd_1[FG_2[i]]=FG_2[i+<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>##无限响应器-处理所有的消息##
读取词库最大的问题在于，如何将每个消息文本都拿去和字典尝试。
经过尝试我找到了如此办法。</p>
<ul>
<li>将on_message的消息反应设置为空，并降低事件响应器优先级。</li>
<li>（降低优先级是为了防止将其他正常的事件响应器盖过）
为什么使用字典：
因为字典读取失败会返回 None,是不会发出任何消息的。
一旦Key找到了对应的键，消息就会返回出来。
基于此机制，代码获得实现，
原理并不复杂，但很好的避免了大量的使用代码设置回复语的代码厄余问题。
上代码：（这里的异常处理是多余的,,小声bb）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dialogue_1 = on_message(priority=<span class="number">100</span>)<span class="comment">#这里优先级的大小是数值越大便越小</span></span><br><span class="line"><span class="meta">@dialogue_1.handle() </span><span class="comment">#出错</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_func</span>(<span class="params">bot: Bot,event:GroupMessageEvent</span>):</span><br><span class="line">   jsq = zd_1.get(<span class="built_in">str</span>(event.get_message()))</span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">       <span class="keyword">await</span> dialogue_1.send(jsq)</span><br><span class="line">   <span class="keyword">except</span>:</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;不行喵&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Bot</tag>
      </tags>
  </entry>
  <entry>
    <title>Python多线程学习</title>
    <url>/2022/11/01/2022-11-1-Python%20%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="认识多线程"><a href="#认识多线程" class="headerlink" title="认识多线程##"></a>认识多线程##</h2><blockquote><p> 多线程类似于同时执行多个不同程序，多线程运行有如下优点：</p>
<ul>
<li>使用线程可以把占据长时间的程序中的任务放到后台去处理。</li>
<li>用户界面可以更加吸引人，比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。</li>
<li>程序的运行速度可能加快。</li>
<li>在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下我们可以释放一些珍贵的资源如内存占用等等。
每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li>
</ul>
<p>每个线程都有他自己的一组CPU寄存器，称为线程的上下文，该上下文反映了线程上次运行该线程的CPU寄存器的状态。</p>
<p>指令指针和堆栈指针寄存器是线程上下文中两个最重要的寄存器，线程总是在进程得到上下文中运行的，这些地址都用于标志拥有线程的进程地址空间中的内存。 </p>
<footer><strong>@菜鸟教程</strong><cite><a href="https://www.runoob.com/python3/python3-basic-syntax.html">www.runoob.com/python3/python3-basic-syntax.html</a></cite></footer></blockquote>

<p>总结：
  一、
    1.线程无法独立执行
    2.线程需要入口，执行序列，以及出口。
    3.线程需要主程序来控制。
  二、
    1.线程有独立的寄存器，称为上下文，反应了线程在CPU寄存器的状态。
    2.上下文中包含指令和指针（两个重要的寄存器）。
    3.线程在上下文中运行，内存地址都用于标志拥有线程的进程地址空间中的内存。 
  三、
    1.线程可以被抢占，即中断
    2.其他线程运行时，线程可以暂搁（睡眠）——线程的退让
  四、
    线程可以分为：
    - 内核线程
    - 用户线程
    Python3线程最常用的两个模块为：
    - _thread
    - threading</p>
<p>thread 模块已被废弃。用户可以使用 threading 模块代替。所以，在 Python3 中不能再使用”thread” 模块。为了兼容性，Python3 将 thread 重命名为 “_thread”。</p>
<ul>
<li>Pyton线程学习</li>
<li>Python使用线程的方式有两种：函数 或者 类 包装线程对象</li>
<li>函数式： 调用 _thread 模块中的start_new_thread()函数来产生新线程。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">_thread.start_new_thread ( function, args[, kwargs] )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参数说明:</p>
<ul>
<li><p>function : 线程函数。</p>
</li>
<li><p>args : 传递给线程函数的参数,他必须是个tuple类型。</p>
</li>
<li><p>kwargs - 可选参数。</p>
</li>
<li><p>线程模块</p>
</li>
<li><p>Python3 通过两个标准库 _thread 和 threading 提供对线程的支持。</p>
</li>
<li><p>_thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。</p>
</li>
<li><p>threading 模块除了包含 _thread 模块中的所有方法外，还提供的其他方法：</p>
</li>
</ul>
<p>threading.currentThread(): 返回当前的线程变量。 </p>
<p>threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。 </p>
<p>threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</p>
<p>除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:</p>
<p>run(): 用以表示线程活动的方法。</p>
<p>start():启动线程活动。</p>
<p>join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。</p>
<p>isAlive(): 返回线程是否活动的。</p>
<p>getName(): 返回线程名。</p>
<p>setName(): 设置线程名。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Python模块</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker多开RW-HPS</title>
    <url>/2022/11/17/2022-11-17-%E4%BD%BF%E7%94%A8docker%E5%A4%9A%E5%BC%80RW-HPS/</url>
    <content><![CDATA[<p>准备工作：</p>
<p>一台Linux服务器
安装docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker pull [最新版的docker镜像]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>1.由于Dr没有在1.0.0.x版本的docker镜像中准备res资源，我们需要进入docker后手动准备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">wget -c 下载链接</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.删除多余的sh脚本和jar，换成最新版的core和jar,并安装vim
ps: pull来的docker内部预置好了对RW-HPS兼容性最好的JAVA 11 JKD</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">rm -rf 你要删的文件</span><br><span class="line"></span><br><span class="line">apt update</span><br><span class="line"></span><br><span class="line">apt install sudo</span><br><span class="line"></span><br><span class="line">apt install vim</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.准备完成，退出镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ctrl + p + q</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.查看容器ID，进行构建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line">docker commit -a [作者信息] [容器id] [镜像名]:[TAG]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5.打包完成，指定端口启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker run --name 容器名称 -d -p 端口:端口 -v ~/rw-hps-data:/app/data [你的镜像ID]:[TAG]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6.进入容器，修改配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker exec -it [容器名称] bash</span><br><span class="line"></span><br><span class="line">cd data</span><br><span class="line"></span><br><span class="line">sudo vim Config.json</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>7.卸载多余组件，启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo dpkg --purge vim vim-common vim-addon-manager</span><br><span class="line"></span><br><span class="line">java -jar [你的jar包]	</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>ps:实际命令中所有[]都是不需要写的，仅在文中起到提示作用。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
        <tag>debian</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 模块重载</title>
    <url>/2022/11/03/2022-11-3-Python%20reload()%20%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<ul>
<li>Python 模块重载 更好的调用函数的方法</li>
<li>前言
  反复的去定义一个重复的代码会极大的降低我们的代码质量和工作效率，而Python本身模块目录结构的调用方式是有限的，在此之前先解释一下什么是Python包。</li>
</ul>
<blockquote><p>Python中的包
包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。</p>
<footer><strong>@菜鸟教程</strong><cite><a href="https://www.runoob.com/python3/python3-basic-syntax.html">www.runoob.com/python3/python3-basic-syntax.html</a></cite></footer></blockquote>

<p>而包自身的调用方式是由主到次的，也就是主模块可以调用(from import)所有子模块，而子模块只能调用自己下层的子模块，而当我们需要子模块去调用上层封装的函数或者类的时候，这就体现的极为不方便。
好在，Python为我们提供的一个函数 – reload() 函数</p>
<ul>
<li><p>使用第一步
  from importlib import reload
  将这个模块导入
  切记不要导成from imp import reload这样的形式
  imp中的reload是一个古老的且已经弃用的函数</p>
</li>
<li><p>函数说明
  reload的中文翻译为：重读  而它的用法也正如其名
  reload()的主要用途便是在子模块中加载先前已经加载过的模块。
  也因此，必须模块已经加载过才可以使用reload()进行重载。
  如果你使用reload()去重载一个子模块中的模块，或者说未载入过的模块，那很显然是不行的。加载子模块的函数请使用常规的导入方法。
  重载的形式就像是复制了代码段，将代码重新的在函数内执行一遍。</p>
</li>
<li><p>函数用法
  非常的简单，直接填写模块名
  例:
  reloda(funciton)
<br>  reloda(xxx)
  ps:中间的模块名并非是字符串的形式，请勿加引号或者双引号</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>英语的介词</title>
    <url>/2022/11/06/2022-11-6-%E8%8B%B1%E8%AF%AD%E4%BB%8B%E8%AF%8D%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<p>in，on，with，by，for，at，about，under，of</p>
<p>【介词】
介词是一种虚词，不能单独作为句子成分，通常用在名词或代词之前。
常用的英语介词有：in，on，with，by，for，at，about，under，of等。</p>
<p>表示在某时间时，常用at，on，in等介词。at用来表示在某一段时刻，如at six：在6点钟。
on用来表示在星期几或是某日，如：on Monday：在星期一。
in用来表示一天中的早中晚、月份、季节或年份。如：in Spring在春天。</p>
<p>during，for，over，within，throughout，from和to等介词表示期间。
before，after，since，until，till，between，up to等，也有时间概念。</p>
<p>在表示方位时，常用at，in，on，to，for，above，over，below，under，
in front of，in the front of，beside，behind等。</p>
<p>英语介词还可以表示进行，在作为表语时，at、on、under等可以表示正在进行的动作。
如：she is at work.她正在工作。</p>
<p>介词也可以表示原因，常用for等。在表示方法、手段的介词常用by，with，through等。
表示数量的时候常用介词有about，around，over等。</p>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>英语单词的构成</title>
    <url>/2022/11/06/2022-11-6-%E8%8B%B1%E8%AF%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%9E%84%E6%88%90/</url>
    <content><![CDATA[<p>【构词法】 
—转化法
动词转化为名词
名词转化为动词
形容词转化为动词
形容词转化为名词
形容词转化为副词
个别词分场合转化为名词
—合成法
合成名词
合成形容词
合成动词
合成副词
合成代词
合成介词
—派生法
前缀-单词的意义
形容词的后缀
名词的后缀
动词的后缀
副词的后缀
数词的后缀
—其他
拼缀法
缩略法
逆向构词法
拟声法
类比法
截短构词法
词根词缀构词法</p>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>英语的语型</title>
    <url>/2022/11/06/2022-11-6-%E8%8B%B1%E8%AF%AD%E7%9A%84%E5%8F%A5%E5%9E%8B/</url>
    <content><![CDATA[<p>一、句型1： Subject (主语) ＋ Verb (谓语)</p>
<p>二、句型2：Subject (主语) ＋ Link. V(系动词) ＋ Predicate(表语)</p>
<p>三、句型3：Subject(主语) ＋ Verb (谓语) ＋ Object (宾语)</p>
<p>四、句型4： Subject(主语)＋Verb(谓语)＋ Indirect object(间接宾语)＋Direct object (直接宾语)</p>
<p>五、句型5： Subject(主语)＋Verb (动词)＋Object (宾语)＋Complement(补语)</p>
<p>【主语】</p>
<p>主语是谓语的陈述对象，如“我写字”中的“我”就是主语，它做出“写”这个动作，“写”则是谓语，用来陈述主语的动作，
而“字”是接受谓语“写”这个动作的对象，它因此被称为宾语，有的语法书也称它为“客体”或“受体”。
主语是句子中的陈述对象，与英语语法也有相似之处。常常由名词、 代词、或 名词性短语充当。
形容词、动词、 谓语性短语和 主谓短语也可充当主语。 句子成分划分时，主语符号为双横线。</p>
<p>【谓语】</p>
<p>谓语(Predicate)是对主语动作状态或特征的陈述或说明，指出”做什么(what to do)” , “是什么(what is this)”。
谓语动词的位置一般在主语之后，经常用动词和形容词搭配来充当谓语动词。
在英语中，动词按作用和功能主要分为两大类，一类是谓语动词，另一类是非谓语动词。</p>
<p>【宾语】</p>
<p>宾语，也称受词，是指一个动作（动词）的接受者。
宾语分为直接宾语和间接宾语两大类，其中直接宾语指动作的直接对象，间接宾语说明动作的非直接，但受动作影响的对象。
一般而言，及物动词后面最少要有一个宾语，而该宾语通常为直接宾语，
有些及物动词要求两个宾语，则这两个宾语通常一个为直接宾语，另一个为间接宾语。</p>
<p>【句型一】
这种句型中的动词大多是不及物动词，所谓不及物动词，就是这种动词后不可以直接接宾语。
常见的动词如：work, sing, swim, fish, jump, arrive, come, die, disappear, cry, happen等。</p>
<p>如：</p>
<ol>
<li><p>Li Ming works very hard.李明学习很努力。</p>
</li>
<li><p>The accident happened yesterday afternoon.事故是昨天下午发生的。</p>
</li>
</ol>
<p>3）Spring is coming.</p>
<ol start="4">
<li>We have lived in the city for ten years.</li>
</ol>
<p>【句型二】
这种句型主要用来表示主语的特点、身份等。其系动词一般可分为下列两类：</p>
<p>(1)表示状态。这样的词有：be, look, seem, smell, taste, sound, keep等。如：</p>
<ol>
<li><p>This kind of food tastes delicious.这种食物吃起来很可口。</p>
</li>
<li><p>He looked worried just now.刚才他看上去有些焦急。</p>
</li>
</ol>
<p>(2)表示变化。这类系动词有：become, turn, get, grow, go等。如：</p>
<ol>
<li><p>Spring comes. It is getting warmer and warmer.春天到了，天气变得越来越暖和。</p>
</li>
<li><p>The tree has grown much taller than before.这棵树比以前长得高多了。</p>
</li>
</ol>
<p>【句型三】
这种句型中的动词一般为及物动词, 所谓及物动词，就是这种动词后可以直接接宾语，
其宾语通常由名词、代词、动词不定式、动名词或从句等来充当。</p>
<p>例：</p>
<ol>
<li><p>He took his bag and left.（名词） 他拿着书包离开了。</p>
</li>
<li><p>Li Lei always helps me when I have difficulties. (代词)当我遇到困难时，李雷总能给我帮助。</p>
</li>
<li><p>She plans to travel in the coming May Day.（不定式）她打算在即将到来的“五一”外出旅游。</p>
</li>
<li><p>I don?t know what I should do next. (从句)我不知道下一步该干什么。</p>
</li>
</ol>
<p>注意：英语中的许多动词既是及物动词，又是不及物动词。</p>
<p>【句型四】</p>
<p>这种句型中，直接宾语为主要宾语，表示动作是对谁做的或为谁做的，在句中不可或缺，常常由表示“物”的名词来充当；
间接宾语也被称之为第二宾语，去掉之后，对整个句子的影响不大，多由指“人”的名词或代词承担。
引导这类双宾语的&#96;常见动词有：buy, pass, lend, give, tell, teach, show, bring, send等。</p>
<p>如：</p>
<ol>
<li>Her father bought her a dictionary as a birthday present.她爸爸给她买了一本词典作为生日礼物。</li>
</ol>
<p>2）The old man always tells the children stories about the heroes in the Long March.</p>
<p>老人经常给孩子们讲述长征途中那些英雄的故事。 上述句子还可以表达为：</p>
<p>1）Her father bought a dictionary for her as a birthday present.</p>
<p>2）The old man always tells stories about the heroes to the children in the Long March.</p>
<p>【句型五】
这种句型中的“宾语 ＋ 补语”统称为“复合宾语”。宾语补足语的主要作用或者是补充、说明宾语的特点、身份等；
或者表示让宾语去完成的动作等。担任补语的常常是名词、形容词、副词、介词短语、分词、动词不定式等。</p>
<p>如：</p>
<p>1）You should keep the room clean and tidy. 你应该让屋子保持干净整洁。（形容词）</p>
<ol start="2">
<li><p>We made him our monitor.(名词)我们选他当班长。</p>
</li>
<li><p>His father told him not to play in the street.(不定式)他父亲告诉他不要在街上玩。</p>
</li>
</ol>
<p>4）My father likes to watch the boys playing basketball.(现在分词)</p>
<ol start="5">
<li>Yesterday I had a picture taken with two Americans.(过去分词)</li>
</ol>
<p>● 常见的动词有: tell, ask, advise, help, want, would like, order, force, allow等。</p>
<p>● 注意：动词have, make, let, see, hear, notice, feel, watch等后面所接的动词不定式作宾补时，不带to。如：</p>
<ol>
<li><p>The boss made him do the work all day.老板让他整天做那项工作。</p>
</li>
<li><p>I heard her sing in the next room all the time last night.昨天晚上我听见她在隔壁唱了一个晚上。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>英语小作文</title>
    <url>/2022/11/07/2022-11-7-%E5%B0%8F%E4%BD%9C%E6%96%87/</url>
    <content><![CDATA[<p>由于本人之前英语极差，所以此次小作文是本人第一次尝试英语写作。</p>
<p>This is book title will say light or dark.</p>
<p>All this because by my fast subdorsal 3000 English word.</p>
<p>One</p>
<p>“Blake … Blake..” A very weaking voice said.
Silent S city,clear night sky under a white hair young girl lying in the blood pool.
Her double eyes slightly tremble, like having seen tremendous terror.
“If can again attack,I certain win….”
Scene transformation in eyes front of us ,last is new
Sky.
That is bloody red sky. 
“girl, I am god.”
“Do you yearn force?”
“yes”
“Then I will achieve your went.”
boom!!!
···emmmmm
lan得写了</p>
<p>aaaaaaaaaaa~</p>
<p>QAQ</p>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title>Solarus</title>
    <url>/2022/11/13/2022-11-13-Solarus/</url>
    <content><![CDATA[<p><img src="https://solarus-games.org/data/en/entities/book-chapter/tutorial/solarus-official-guide/01-basics/01-introduction/engine-logo.png" alt="Solarus"></p>
<p>官方的介绍是这样的</p>
<blockquote><p>Solarus is a free and open-source game engine, licensed under GPL v3. It is written from scratch in C++ and uses SDL2. Consequently, it is compatible with a large set of platforms. You can explore the source code if you’re curious.</p>
<footer><strong>@Solarus</strong><cite><a href="https://solarus-games.org/en/development/tutorials/solarus-official-guide/basics/introduction">solarus-games.org/en/development/tutorials/solarus-official-guide/basics/introduction</a></cite></footer></blockquote>

<p>根据我的理解则是：
  Solarus是一个开源的，受保护的，功能强大的自由软件-2DRPG动作游戏引擎。
  他的底层由C++编写，这为游戏的运行效率打下了很好的基础。而在开发游戏的过程一般只需要用到LUA就可以做绝大多数事情，而引擎的内容对普通开发者来说不用去动。</p>
]]></content>
      <categories>
        <category>engine</category>
      </categories>
      <tags>
        <tag>Solarus</tag>
        <tag>engine</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 20.04 LTS 使用笔记</title>
    <url>/2022/08/20/2022-8-20-Ubuntu%2020.04%20LTS%20%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Ubuntu-20-04-LTS-使用笔记"><a href="#Ubuntu-20-04-LTS-使用笔记" class="headerlink" title="Ubuntu 20.04 LTS 使用笔记"></a>Ubuntu 20.04 LTS 使用笔记</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p> 服务器是在腾讯云购买的2G 1核轻量级服务器，使用SSH远程连接。</p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><ol>
<li><p>登录 su 用户名 （用户名默认为ubuntu） </p>
</li>
<li><p>输入密码 即可进入Home页面（在输入密码的过程中密码是隐藏的)</p>
</li>
</ol>
<h3 id="目录切换"><a href="#目录切换" class="headerlink" title="目录切换"></a>目录切换</h3><ol>
<li><p>使用CD命令：</p>
<ul>
<li><p>cd  目录名	进入指定目录</p>
</li>
<li><p>cd - 目录名   返回上一级命令</p>
</li>
</ul>
</li>
</ol>
<h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><p>使用命令 ls -a 查看当前目录下的文件</p>
<p>其中文件有不同的颜色，每个颜色都有独特的意义</p>
<p>绿色文件：可执行文件，可执行的程序 </p>
<p>红色文件：压缩文件或者包文件 如 （jar zip 后缀的文件）</p>
<p>蓝色文件：目录    （一般显示为 .. .）</p>
<p>白色文件：普通文件，如文本文件，配置文件，源码文件等</p>
<p>浅蓝色文件：链接文件，主要是使用ln命令建立的文件</p>
<p>红色闪烁：表示链接的文件有问题</p>
<p>黄色文件：表示设备文件</p>
<h3 id="mv-命令"><a href="#mv-命令" class="headerlink" title="mv 命令"></a>mv 命令</h3><p>格式 mv [选项] 源文件或者目录 目标文件或者目录</p>
<p>移动文件	举例： 将文件 233 移动到 666</p>
<p>mv 233 666</p>
<p>重命名文件	举例：将文件233 改名为 2333</p>
<p>mv 233 2333</p>
<h3 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h3><p>sudo 命令为是linux系统管理指令，是允许系统管理员让普通用户执行一些或者全部的root<em>命令</em>的一个工具。 –百度百科</p>
<p>简单来说就是给予其他命令管理员权限，就和windows中的用管理员权限打开是相似的。</p>
<p>举例 sudo wget -c xxxxxxxxxxxxx</p>
<h3 id="更新源"><a href="#更新源" class="headerlink" title="更新源"></a>更新源</h3><p>apt-get update</p>
<h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>apt-get install 软件名</p>
<p>apt install 软件名</p>
<p>其中apt 是合并了 apt-get 和 apt-cache 的简化命令</p>
<p>原理是先搜索再下载安装，搜不到不装</p>
<p><em><strong>其中使用了非常好用的分段下载llastest,得益于联合文件系统</strong></em></p>
<h3 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h3><p>Wget 常用于下载</p>
<p>格式: wget 参数 路径</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><hr>
<h2 id="Docker-的基本使用"><a href="#Docker-的基本使用" class="headerlink" title="Docker 的基本使用"></a>Docker 的基本使用</h2><p>Docker 名为容器，是挂载软件，子系统，诸如此类的不二选择。</p>
<h3 id="基本命令-1"><a href="#基本命令-1" class="headerlink" title="基本命令"></a>基本命令</h3><p>镜像命令
docker images 查看镜像
docker search +名称 搜索镜像 + ##–filter&#x3D;STARTS&#x3D;数字 收藏数搜索）
dockers pull #下载镜像:tag 版本</p>
<p>docker rmi +docker rmi +id +id +id 删除镜像
dockers rmi -f 删除全部 $(docker imgaes -aq) 
dockers rm (运行的不能删除)+id删除容器
dockers rm -f 强制删除全部  $(docker ps -aq)
docker ps -a -q|xargs docker rm 删除所有容器</p>
<h3 id="run-命令"><a href="#run-命令" class="headerlink" title="run 命令"></a>run 命令</h3><p>格式：docker run 参数 参数 参数</p>
<p>举例：</p>
<p>sudo docker run -it  -v ~&#x2F;txzz2&#x2F;docker:&#x2F;app&#x2F;data -p 5124:5124 5eaf4cfde9c5</p>
<p>解剖 sudo 获取权限 </p>
<p>docker run 为基本 </p>
<p>-it 为交互式运行 </p>
<p>-v ~&#x2F;路径  绑定容器数据卷 </p>
<p>-p 指定容器端口</p>
<p>后面为镜像名</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVASE _1</title>
    <url>/2022/07/20/2022-7-20-%E8%BF%99%E6%98%AF%E7%88%B7%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>C语言
贴近硬件，运行快，效率高
操作系统，编译器，数据库，网络系统  【非常严格】
指针和内存管理</p>
<p>1982 C++	【非常复杂的特性】【需要非常多的底层知识】
面向对象
兼容C
图形领域，游戏</p>
<p>JAVA
语法像C
没有指针
没有内存管理
真正的可移植性，到处运行（）
面向对象
类型安全
高质量类库
层叫 	C++ –</p>
<p>JAVA初生</p>
<p>图形界面程序 Applet</p>
<p>Java 2 桌面 J2SE</p>
<p>Java 2移动版 J2ME 占领手机</p>
<p>Java 2服务器 J2EE</p>
<hr>
<p>构建工具：Ant,Mavern,Jekins</p>
<p>应用服务器：Tomcat,Jetty,Jboss,Websphere,weblogic</p>
<p>Web开发：Struts,Spring,Hibernate,myBatis</p>
<p>开发工具：Eclipse,Netbean,intellij ideam,JbUILDER</p>
<p>2006： Hadoop</p>
<p>2008:	Android</p>
<hr>
<p>JAVA特性和优势</p>
<p>简单性</p>
<p>面向对象</p>
<p>可移植性</p>
<p>高性能</p>
<p>分布式</p>
<p>动态性	反射机制</p>
<p>多线程</p>
<p>安全性</p>
<p>健壮性	通过捕获异常来解决异常</p>
<p>【心态】：去学习的过程中爱上它，这样才能主动学习</p>
<p>JAVA的成功：实力 + 运气 找到了互联网发展的节奏</p>
<hr>
<p>JAVA三大版本</p>
<p>Write Once \Run Anywhere （虚拟机）</p>
<p>JavaSE：标准版 （桌面程序，控制台开发）</p>
<p>JavaME: 嵌入式开发 （手机，小家电） 【冷门】</p>
<p>JavaEE: E企业级开发 （web端，服务器开发）</p>
<hr>
<p>JDK包含 JRE 全称：Java Development Kit [工具]</p>
<p>JRE 全称 ： Java Runtime Environment [运行]</p>
<p>JVM: 全称 JAVA Virtual Machine [虚拟机]</p>
<p>通过虚拟机屏蔽了底层数据的差别</p>
<p>JAVA SE API 【接口】</p>
<hr>
<p>JAVA开发环境搭建</p>
<ul>
<li>JDK下载与安装</li>
<li>JDK 卸载 ：</li>
</ul>
<p>​	1.删除JAVA安装目录</p>
<p>​	2.删除变量 （电脑属性，环境变量，path）</p>
<p>​	3.java -version</p>
<ul>
<li><p>安装JAVA</p>
<ol>
<li><p>搞到安装包</p>
</li>
<li><p>设置JAVA_HOME</p>
</li>
<li><p>设置path变量</p>
</li>
<li><p>(%表示引用)</p>
</li>
</ol>
</li>
<li><p>测试 java -version</p>
</li>
<li><p>src.zip 中有java源码</p>
</li>
<li><p>lib为库</p>
</li>
<li><p>include为C的头文件目录</p>
</li>
</ul>
<hr>
<p>我的JAVA对世界的第一声呐喊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> java <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;  <span class="comment">//类名</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;  <span class="comment">//方法</span></span><br><span class="line">		System.out.print(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码如上</p>
<hr>
<p>承接上文	在搞完了之后爷就遇到了+编码问题</p>
<p>所幸在之前的RWmod开发中早已经遇到过类似的，便直接上网求证，很快解决了。</p>
<p>原因为txt的UFT-8中是带ROM的，而 javac是无法识别带ROM 的UFT-8</p>
<p>只好安装了一个Notepad++，将编码修改后，便可以正常运行了。</p>
<p>唔，以后池沼开发一个自己的编译器，这个用着真不舒服。。</p>
<hr>
<p>解决问题的网址</p>
<p>https:&#x2F;&#x2F;blog.csdn.net&#x2F;White_Idiot&#x2F;article&#x2F;details&#x2F;54670243</p>
<p>同时学到了一条新命令</p>
<p>javac -encoding “UTF-8” FirstSample.java</p>
<p>通过指定编码的方式运行javac</p>
<hr>
<p>注意事项</p>
<ul>
<li>大小写问题</li>
<li>中英文问题</li>
</ul>
<hr>
<p>使用IDEA开发环境</p>
<p>新建方法 -新建类 - 快捷键 (待补充)</p>
<hr>
<p>JAVA基本语法</p>
<ol>
<li>注释、标识符</li>
<li>数据类型</li>
<li>类型转换</li>
<li>变量、常量</li>
<li>运算符</li>
<li>包机制、JavaDoc</li>
</ol>
<hr>
<p>IDEA的项目设置五大类</p>
<ul>
<li><p>Project 项目</p>
<p>|name   |   SDK   |  Language level |  Compiler output ps:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">名称	  |   工具   |   语言等级 		  |   输出文件夹       </span><br></pre></td></tr></table></figure></li>
</ul>
<p>​    输出文件夹 ps: Used  for modules subdirectories, Production and Test directories for the corresponding sources.</p>
<p>​	翻译：用于相应源的模块子目录、生产目录和测试目录。</p>
<ul>
<li><p>Modules 模块</p>
<p>Name: 模块的名称														Add Content Root（添加新的内容根）</p>
<p>Sources   |  Paths   |   Dependencies</p>
<p>源			  |   路径     |  依赖关系</p>
</li>
</ul>
<p>Sources ： Language level </p>
<p>文件夹标记</p>
<p>Mark as:   Sources \blue\    Tests \green\  Resources\资源\   Test Resources\测试资源\  Excluded\排除\</p>
<p>Paths : Compiler Output （编译器输出）：Inherit project compile output path(和项目输出路径相同)</p>
<p>​																		：Use module compile output path （使用模块编译输出路径）</p>
<p>JavaDoc：Manage external JavaDocs attached to this module, External JavaDoc override Javadoc override Java DOc annotations you might have in your module.（管理附加到此模块的外部JavaDoc，外部JavaDoc覆盖模块中可能有的JavaDoc注释。）</p>
<ul>
<li>Libraries 图书馆</li>
</ul>
<p>​	   Nothing to show（没啥可展示的）	</p>
<p>​	   右侧  Select a library to view or edit its details here (在此处选择要查看或编辑其详细信息的库)</p>
<ul>
<li><p>Facets  面</p>
<p>No facets are configured(没有配置的面)</p>
<p>Detection (检查)</p>
<p>右侧 ：Enable framework detection（启用检测框架）</p>
<p>​			 Exclude from detection(排除在检测外) </p>
</li>
<li><p>Artifacts</p>
</li>
</ul>
<p>  即编译后的Java类，Web资源等的整合，用以测试、部署等工作。再白话一点，就是说某个module要如何打包，例如war exploded、war、jar、ear等等这种打包形式。某个module有了 Artifacts 就可以部署到应用服务器中了。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>&#x2F;&#x2F; 单行注释</p>
<p>&#x2F;*   *&#x2F; 多行注释</p>
<hr>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>| abstract | assert  | bollean | break   | byte  |
| :——: | ——- | ——- | ——- | —– |
| case     | catch   | char    | calss   | conse |
| continue | default | do      | double  | else  |
| enum     | extends | final   | finally | float |
|  for                | goto     |if|implements|import|
| instanceof  |int|interface|long|native|
| new             |package|private|protected|public|
| return|strictfp|short|static|super|
| switch|synchronized|this|throw|throws|
| transient|try|void|volatile|while|</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">calss1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">qwq</span> <span class="operator">=</span><span class="string">&quot;233&quot;</span>; <span class="comment">//qwq为标识符，以小写字母开头</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">QAQ</span> <span class="operator">=</span> <span class="string">&quot;233&quot;</span>;<span class="comment">//大写字母</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">$qwq</span> <span class="operator">=</span> <span class="string">&quot;233&quot;</span>;<span class="comment">//美元符号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">_QWQ</span> <span class="operator">=</span> <span class="string">&quot;233&quot;</span>;<span class="comment">//下划线</span></span><br><span class="line">        String 傻逼 = <span class="string">&quot;233&quot;</span>;<span class="comment">//中文命名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//标识符是大小写敏感得</span></span><br></pre></td></tr></table></figure>

<h2 id="JAVA-数据类型"><a href="#JAVA-数据类型" class="headerlink" title="JAVA 数据类型"></a>JAVA 数据类型</h2><h3 id="JAVA为强类型语言"><a href="#JAVA为强类型语言" class="headerlink" title="JAVA为强类型语言"></a>JAVA为强类型语言</h3><ul>
<li><p>要求变量的使用严格符合规定，所有变量必须先定义后使用</p>
<p>弱类型就反之了（例：VB，JS ）</p>
</li>
</ul>
<h4 id="JAVA的数据类型分为两大类"><a href="#JAVA的数据类型分为两大类" class="headerlink" title="JAVA的数据类型分为两大类"></a>JAVA的数据类型分为两大类</h4><ul>
<li><p>基本类型 primitive type</p>
<ol>
<li>整数类型: byte1个字节范围 short 2个字节范围 int 四个字节范围 long 8个字节范围</li>
<li>浮点类型 ： float 占四个字符范围 double 占8个字符范围</li>
<li>字符类型： char 占两个字节</li>
<li>boolean类型：占1位，只有true 和 false</li>
</ol>
</li>
<li><p>引用类型 reference type ：类、接口、数组</p>
</li>
</ul>
<hr>
<p>变量需要初始化 &#x3D; 变量需要定义</p>
<p>int 和 String 都是类型</p>
<p>int 整数  String 字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.SQLOutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">calss2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 整数扩展： 进制 二进制 八进制 十六进制</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">010</span>; <span class="comment">// 八进制</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0x10</span>; <span class="comment">//十六进制 0x开头</span></span><br><span class="line"></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(i2);</span><br><span class="line">        System.out.println(i3);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//-------------------------------------------</span></span><br><span class="line">        <span class="comment">//浮点数扩展： 有限 离散 舍入误差 大约 接近但不等于</span></span><br><span class="line">        <span class="comment">//最好减少使用浮点数进行表示和比较 ，由于浮点数字长有限所以有误差得</span></span><br><span class="line">        <span class="comment">//float（浮点数）</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span><span class="number">0.1f</span>; <span class="comment">//0.1</span></span><br><span class="line">        <span class="type">double</span> d= <span class="number">1.0</span>/<span class="number">10</span>; <span class="comment">//0.1</span></span><br><span class="line">        System.out.println(f==d);</span><br><span class="line">        <span class="comment">//字符扩展</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span><span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span><span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println((<span class="type">int</span>)c1);<span class="comment">//强制换行</span></span><br><span class="line">        System.out.println(c2);</span><br><span class="line">        System.out.println((<span class="type">int</span>)c2);<span class="comment">//强制换行</span></span><br><span class="line">        <span class="comment">//所有字符本质还是数字</span></span><br><span class="line">        <span class="comment">//编码 Unicode 表：97 = a 2字节 65 =A</span></span><br><span class="line">        <span class="comment">// U0000 UFFFF 为Unicode编码格式</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span><span class="string">&#x27;\u0061&#x27;</span>;  <span class="comment">//一个Unicode字符进行转换</span></span><br><span class="line">        System.out.println(c3);</span><br><span class="line">        <span class="comment">//转义字符 \t 制表符</span></span><br><span class="line">        <span class="comment">// \n 换行</span></span><br><span class="line">        <span class="comment">// 更多转义字符待查</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(sa==sb);<span class="comment">//判断相等 “==” //判断为不相等</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sd</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        System.out.println(sc==sd); <span class="comment">//识别为相等</span></span><br><span class="line">        <span class="comment">//对象</span></span><br><span class="line">        <span class="comment">//布尔值扩展</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag==<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;&#125;   <span class="comment">//默认是等于true</span></span><br><span class="line">        &#125; <span class="comment">//Less is more! 代码精简易读</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h4><p>位（bit）</p>
<p>字节（byte）</p>
<p>1B &#x3D; 8BIT</p>
<p>字母：指的是计算机中的字母、数字、字和符号。</p>
<p>电脑32位和64位的区别，寻指的能力，可以装的内存不同，</p>
<hr>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li><p>由于JAVA是强类型语言。所以进行有些运算的时候，需要用到类型转换。</p>
<p>低 ——————————————&gt;高</p>
<p>byte , short ,char -&gt; int -&gt; long -&gt; float -&gt; double</p>
<ul>
<li>运算中，不同类型的数据先转换为同一类型，然后进行运算。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">calss3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">128</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)i;<span class="comment">//强制转换 byet最大值为127 ，所以内存溢出了。输出值变成了-128 //高--&gt;低</span></span><br><span class="line">        <span class="comment">//自动转换  低--高</span></span><br><span class="line">        System.out.println(b);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.不能对布尔值进行转换</span></span><br><span class="line"><span class="comment">        2.不能把对象类型转换为不相干的类型</span></span><br><span class="line"><span class="comment">        3.在把大容量转换为低容量的时候，强制转换</span></span><br><span class="line"><span class="comment">        4.转换的时候可能存在内存溢出</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">        System.out.println((<span class="type">int</span>)<span class="number">23.7</span>); <span class="comment">//23 会导致精度问题</span></span><br><span class="line">        System.out.println((<span class="type">int</span>)-<span class="number">45.89f</span>); <span class="comment">//-45</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span><span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> c+<span class="number">1</span>;<span class="comment">//转换成了int形式，低向高自动转换</span></span><br><span class="line">        System.out.println(d);</span><br><span class="line">        System.out.println((<span class="type">char</span>)d);<span class="comment">//强制转换为字符，输出为b</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//操作比较大的数的时候，注意溢出问题</span></span><br><span class="line">        <span class="comment">//JDK7新特性，数字直接可以用下划线分割</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">10_0000_000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">years</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> money*years; <span class="comment">// 输出后返回的为数字，计算的时候溢出了</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">total2</span> <span class="operator">=</span> money*years;<span class="comment">//默认为Int，转换之前已经存在问题了，所以无用</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">total3</span> <span class="operator">=</span> money*((<span class="type">long</span>)years);<span class="comment">//先把一个数转换为long，则整个表达式提升，全部用Long计算，则不会内存溢出，就没事了。</span></span><br><span class="line">        System.out.println(tota3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量定义：可以把变化的量。</p>
<p>JAVA是一种强类型语言，每个变量都必须声明其类型。</p>
<p>JAVA变量是程序中最基本的存储单元，其要素包括变量名变量类型和作用域。</p>
<p>变量划分内存的空间</p>
<ul>
<li><p>作用域：</p>
<ul>
<li>类变量</li>
<li>实例变量</li>
</ul>
</li>
<li><p>局部变量</p>
</li>
</ul>
<hr>
<ul>
<li><p>格式 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  type varname	[=value] [&#123;,varName[=value]];</span><br><span class="line">  <span class="comment">//数据类型  变量名 =值；可以用逗号隔开来声明多个同类型变量。</span></span><br><span class="line">                             <span class="comment">//ps：老师不建议在一行里定义多个值，会看起来比较复杂。 </span></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//int a,b,c; //定义a b c 为int类型</span></span><br><span class="line">       <span class="comment">//int a=1,b=2,c=3; //定义a,b,c三个的量，但是程序可读性不好</span></span><br><span class="line">        <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> b=<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> c=<span class="number">3</span>; <span class="comment">//单独定义可读性会好</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span><span class="string">&quot;23333&quot;</span>; <span class="comment">//定义一个name为字符串</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&#x27;X&#x27;</span>; <span class="comment">//定义x为一个字符</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span><span class="number">3.4</span>; <span class="comment">//定义pi为一个数字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class08</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="variable">salary</span> <span class="operator">=</span> <span class="number">2500</span>;<span class="comment">//加前期变量都加static，这个static定义了一个变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例变量：从属于对象，如果不自行初始化，这个类型的默认值则为0 或0.0；所以14行输出了一个0</span></span><br><span class="line">    <span class="comment">//字符串初始化为16位的0000....，布尔值默认为false</span></span><br><span class="line">    <span class="comment">//除了以上的基本类型，其他的初始值都为null</span></span><br><span class="line">    String name; <span class="comment">//变量在类里</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//属性：变量</span></span><br><span class="line">    <span class="comment">//main 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i=<span class="number">10</span>;<span class="comment">//定义一个i为局部变量，只能在此处使用，且初始化值。</span></span><br><span class="line">        System.out.println();</span><br><span class="line">       <span class="comment">// 变量类型 变量名字 = new class08 ,相当于把自己拿到了。</span></span><br><span class="line">        <span class="type">class08</span> <span class="variable">class08</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">class08</span>();</span><br><span class="line">        System.out.println(class08);<span class="comment">//输出class08@1b6d3586</span></span><br><span class="line">        System.out.println(class08.age);<span class="comment">//输出0</span></span><br><span class="line">        System.out.println(class08.name);<span class="comment">//输出null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







<ul>
<li>常量 （Constant）:初始化 （initialize）后不能再改变值！不会编队的值。</li>
<li>所谓常量是一种特殊的变量，它的值被设定后，在程序运行过程中不允许被改变。</li>
</ul>
<p>格式：  ps:常量名一般使用大写字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> 变量名 值;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class09</span> &#123;</span><br><span class="line">    <span class="comment">//修饰符，不存在先后顺序 指final static double PI ,,等号之前的这些东西(但是谁=谁要定义好了)。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14</span>; <span class="comment">//定义了一个静态的常量PI</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h3><ul>
<li>所有变量、方法、类名：见名知意。</li>
<li>类成员变量：首字母小写和驼峰原则：monthSalary 除了第一个单词以外，后面的单词首字母大写<ul>
<li>例 lastname lastName</li>
</ul>
</li>
<li>局部变量：首字母小写和驼峰原则</li>
<li>常量：大写字母和下划线：MAX_VALUE</li>
<li>类名：首字母大写和驼峰原则：Man,GoodMan</li>
<li>方法名：首字母小写和驼峰原则：run(),runRun()</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="JAVA语言支持如下运算符："><a href="#JAVA语言支持如下运算符：" class="headerlink" title="JAVA语言支持如下运算符："></a>JAVA语言支持如下运算符：</h4><ul>
<li>算数运算符：+,-,*,&#x2F;,%（取余&#x3D;模运算）,++,–</li>
<li>赋值运算符： &#x3D;</li>
<li>关系运算符：&gt;,&lt;,&gt;&#x3D;,&lt;&#x3D;,&#x3D;&#x3D;（相等）,!&#x3D;（不等于），instanceof</li>
<li>逻辑运算符：&amp;&amp;,||,!  （与，或，如果是真则为假，如果是假则为真）</li>
<li>位运算符：&amp;，|,^，~,&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;(了解！！！）</li>
<li>条件运算符？：</li>
<li>扩展赋值运算符：+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;</li>
</ul>
<h2 id="IDEA创建包和MOVE"><a href="#IDEA创建包和MOVE" class="headerlink" title="IDEA创建包和MOVE"></a>IDEA创建包和MOVE</h2><p>点击src 右键 new —&gt; Package</p>
<p>此时弹出一个窗</p>
<p>Move :  项目名</p>
<p>To directory: 路径</p>
<p>Search in comments and strings （在字符串中搜索）</p>
<p>Search for text occurrences （所属出现的文本）  &#x2F;&#x2F;这两位默认勾选暂时不管</p>
<p>Open in editor（在编辑器中打开（也叫开放编辑））       &#x2F;&#x2F;此处勾选即可                       </p>
<pre><code>                                                         Refactor     Preview     Cancel
</code></pre>
<p>一次移动多个文件会出现 Refactoring Preview（重构预览）</p>
<p>点击 Do Refactor 即可 ps:原来这tm是个报错</p>
<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> base2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">long</span> a= <span class="number">12312345623156415L</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span><span class="number">123</span>;</span><br><span class="line">        <span class="type">short</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">byte</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        System.out.println(a+b+c+d);<span class="comment">//有一个数字类型为long则结果类型也为long，如果没有long则结果都为int，（待求证的理解）默认类型为int类型，加入其他类型后，加什么则跟什么，那么同时加了俩会怎么样呢?</span></span><br><span class="line">      <span class="comment">//  System.out.println((String) (c+d)); //触发报错：incovertible tpyes cannot cast &#x27;int&#x27; to &#x27;java.lang.String&#x27;</span></span><br><span class="line">                                                    <span class="comment">//无法将 int 类型转换为 String类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> base2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//++ -- 自增，自减  一元运算符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">//定义a为3</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span>a++; <span class="comment">//就是 a给自己加个1 （a+1）</span></span><br><span class="line">        System.out.println(a);<span class="comment">//这个回合自增了一下//输出4 因为此时的a已经加了个1</span></span><br><span class="line">        System.out.println(b); <span class="comment">//输出3  也就是说b的值就是a的值，但b的值不是a++的值，a++仅是为了给a再次赋值，让a加1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span>++a; <span class="comment">//自增后给c赋值 这个才是赋值回合</span></span><br><span class="line">        System.out.println(a);<span class="comment">//这个回合再次自增 输出5，c在原先a++的基础上，再次++a</span></span><br><span class="line">        System.out.println(b);<span class="comment">//输出3</span></span><br><span class="line">        System.out.println(c);<span class="comment">//输出5   ps: ++是自增，b = a++ b=a=3 和a++这个a的自增是没有关系的，只是++刚好在b=a这个赋值的时候</span></span><br><span class="line">        System.out.println(c);<span class="comment">//输出5   ps： 而 c =++a 将++放在了前面，则就是c = 再次自增的a</span></span><br><span class="line">        <span class="comment">//话不多说测试一波</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> ++c; <span class="comment">//那么这个f 按照我的理解，f等于 自增后的c，那么输出应该等于6。测试一波</span></span><br><span class="line">        System.out.println(f); <span class="comment">//输出为6 ，没有问题</span></span><br><span class="line">        <span class="comment">//接着测试一波，g = f ++ ，按照我的理解，g = 6 ,f 在这条语句后变成了7</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">g</span> <span class="operator">=</span> f++;</span><br><span class="line">        System.out.println(g);</span><br><span class="line">        System.out.println(f);<span class="comment">//over 没有问题~~~</span></span><br><span class="line">         <span class="comment">//幂运算 //这些运算可以使用工具【类】来进行操作，java中有很多的类</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">pow</span> <span class="operator">=</span> Math.pow(<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//Math类提供了很多的科学计算和常数捏</span></span><br><span class="line">        System.out.println(pow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> base2;</span><br><span class="line"><span class="comment">//逻辑运算符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 与（and） 或（or） 非（取反）</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">a</span> <span class="operator">=</span><span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span><span class="literal">false</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;a %% b ：&quot;</span>+(a&amp;&amp;b));<span class="comment">//逻辑与运算：两个变量都为真，结果才为真，因为只有a是真所以输出假</span></span><br><span class="line">        System.out.println(<span class="string">&quot; a || b：&quot;</span>+(a||b));<span class="comment">//逻辑或运算：两个变量有一个为真则结果为真，因为有一个a是真所以结果是真</span></span><br><span class="line">        System.out.println(<span class="string">&quot;!(a &amp;&amp; b：)&quot;</span>+!(a&amp;&amp;b));<span class="comment">//如果是真，则变为家，如果是假则变为真，因为只有a是真，所以应该输出假，但是取反，输出真</span></span><br><span class="line">        <span class="comment">//短路运算</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">d</span> <span class="operator">=</span> (c&lt;<span class="number">4</span>)&amp;&amp;(c++&lt;<span class="number">4</span>);</span><br><span class="line">        System.out.println(d);<span class="comment">//这里输出了假，由于短路运算，在检测到假后后面的就不去考虑了，所以c++并没有运行，c的值还是4</span></span><br><span class="line">        System.out.println(c);<span class="comment">//这里c仍然是5</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//字符串的连接</span></span><br><span class="line">        System.out.println(<span class="string">&quot;23333&quot;</span>+<span class="string">&quot;woc666&quot;</span>);<span class="comment">//字符串在输出中可以用加号连接捏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> base2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        A = 0011 1100</span></span><br><span class="line"><span class="comment">        B = 0000 1101</span></span><br><span class="line"><span class="comment">        A&amp;B = 0000 1100 //两个都是1 才能得1（和相乘差不多）</span></span><br><span class="line"><span class="comment">        A|B = 0011 1101 //只要一个为1，则就是1 1|0=1酱紫得</span></span><br><span class="line"><span class="comment">        A^B = 0011 0001 //两个位置，相同则为0，否则则为1</span></span><br><span class="line"><span class="comment">        ~B  = 1111 0010 //取反，就是反过来啦~</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        面试题：2*8 怎么运算最快？</span></span><br><span class="line"><span class="comment">        拆分到 2*2*2*2 正常运算需要电路，这个只需要增量（hhh记下来）</span></span><br><span class="line"><span class="comment">        &lt;&lt; 左移  相当于乘2</span></span><br><span class="line"><span class="comment">        &gt;&gt; 右移  相当于除2  （算法中效率贼高~~~）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        0000 0000 0</span></span><br><span class="line"><span class="comment">        0000 0001 1</span></span><br><span class="line"><span class="comment">        0000 0010 2</span></span><br><span class="line"><span class="comment">        0000 0011 3</span></span><br><span class="line"><span class="comment">        0000 0100 4</span></span><br><span class="line"><span class="comment">        0000 1000 8</span></span><br><span class="line"><span class="comment">        0001 0000 16</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展运算符（偷懒计算-bushi-）"><a href="#扩展运算符（偷懒计算-bushi-）" class="headerlink" title="扩展运算符（偷懒计算(bushi)）"></a>扩展运算符（偷懒计算(bushi)）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> base2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        a+=b; <span class="comment">//a+=的意思就是a= a+b</span></span><br><span class="line">        a-=b; <span class="comment">// 意思为a = a-b</span></span><br><span class="line">        <span class="comment">//字符串连接</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+a+b);<span class="comment">//如果字符串连接符出现了前面，则后面所有的都会转换为String类型</span></span><br><span class="line">        System.out.println(a+b+<span class="string">&quot;&quot;</span>);<span class="comment">//正常运算，因为字符串连接符在后面</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> base2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// x ? y : z</span></span><br><span class="line">        <span class="comment">// 意思为 如果 x==true,则结果为y,否则结果为z</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span><span class="number">80</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> score &lt;<span class="number">60</span> ? <span class="string">&quot;不及格&quot;</span>:<span class="string">&quot;及格&quot;</span>;</span><br><span class="line">        System.out.println(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ps :为了方便代码的使用和理解多打括号（）</p>
<h2 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h2><ul>
<li>为了更好的组织类，JAVA提供了包机制，用于区别类名的命名空间。</li>
<li>包语句的语法格式为：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg1[. pkg2[. pkg3...]];</span><br></pre></td></tr></table></figure>

<ul>
<li>一般利用公司域名倒置作为包铭；例：com.baidu.www</li>
<li>IDEA创建包会帮忙写好所属的包名：package xxxx;</li>
<li>import xxxx.xxx.xx;使用包</li>
</ul>
<h2 id="快捷键-Alt-回车-（生成错误信息）-然后自动找包-爱了爱了"><a href="#快捷键-Alt-回车-（生成错误信息）-然后自动找包-爱了爱了" class="headerlink" title="快捷键 Alt + 回车 （生成错误信息） 然后自动找包~~爱了爱了~"></a>快捷键 Alt + 回车 （生成错误信息） 然后自动找包~~爱了爱了~</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> base2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;<span class="comment">//这玩意必须在package的下面</span></span><br><span class="line">                        <span class="comment">//import xx.xx.xx就是路径，导入包，也可以导入自己的源码~~</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// x ? y : z</span></span><br><span class="line">        <span class="comment">// 意思为 如果 x==true,则结果为y,否则结果为z</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span><span class="number">80</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> score &lt;<span class="number">60</span> ? <span class="string">&quot;不及格&quot;</span>:<span class="string">&quot;及格&quot;</span>;</span><br><span class="line">        System.out.println(type);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="骚操作-import-xx-xx-xx-会将第四个包下的所有类全导入进来捏"><a href="#骚操作-import-xx-xx-xx-会将第四个包下的所有类全导入进来捏" class="headerlink" title="骚操作 import xx.xx.xx.* 会将第四个包下的所有类全导入进来捏"></a>骚操作 import xx.xx.xx.* 会将第四个包下的所有类全导入进来捏</h4><h2 id="Java-Doc"><a href="#Java-Doc" class="headerlink" title="Java Doc"></a>Java Doc</h2><ul>
<li><p>作用：生成自己的API文档</p>
</li>
<li><p>参数信息：</p>
<ul>
<li>@author 作者名</li>
<li>@version 版本号</li>
<li>@since 指明需要最早使用的jdk版本</li>
<li>@param 参数名</li>
<li>@return 返回值情况</li>
<li>@throws 异常抛出情况</li>
</ul>
</li>
<li><p>官方帮助文档得地址捏：docs.oracle.com&#x2F;javase</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> base2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> allure</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">doc</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**   //** +回车就星了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于DIEA右键的翻译</p>
<p>Find Usages             | 搜索用法 
Analyze 					|分析
Refactor					|重新构建
——					
Bookmarks			   |书签
——
Browse type Hierarchy|浏览类型层次结构
Reformat Code 			 |格式化代码
Optimize Imports		  |优化包引用
Delete 							 |删除
Override File Type		 |覆盖文件类型
——
Build Module 			     |构建模块 
——
Open in Right Split         |从右边打开
Open in							|打开</p>
<p>——
Local History					|历史记录
Repair IDE						 |修复IDE
Reload from Disk			 |从磁盘重新加载
——
Compare With    			   |与…比较
Compart File with Editor  |将文件与编辑器比较
——
Diagrams							 |图表
——
Convert java File to Kotlin File|将Java文件转换为Kotlin文件</p>
<h2 id="javadoc的CMD命令"><a href="#javadoc的CMD命令" class="headerlink" title="javadoc的CMD命令"></a>javadoc的CMD命令</h2><p>javadoc -encoding UFT-8 -charset UTF-8 xx.java</p>
<p>​				-编码  参数  -字符 参数  xxx.java</p>
<h2 id="使用IDEA生成javadoc"><a href="#使用IDEA生成javadoc" class="headerlink" title="使用IDEA生成javadoc"></a>使用IDEA生成javadoc</h2><ol>
<li>点击上方的Tool </li>
<li>点击Generate JavaDoc</li>
<li>Out put directory: 则是生成的文档的路径捏</li>
<li>设置各项参数 Loacale:填写zh_CN可以指定以中文格式生成捏</li>
<li>Other command line arguments: 输出配置 就是cmd javadoc 后面写的那些了~~呐呐</li>
</ol>
<h1 id="JAVA流程控制"><a href="#JAVA流程控制" class="headerlink" title="JAVA流程控制"></a>JAVA流程控制</h1><ol>
<li>用户交互Scanner</li>
<li>顺序结构</li>
<li>选择结构</li>
<li>循环结构</li>
<li>Break &amp; continue</li>
<li>练习</li>
</ol>
<ul>
<li><p><strong>Scanner 对象</strong></p>
</li>
<li><p>通过Java给我们提供的工具类，我们可以获取用户的输入。java.util.Sacnner 是Java5的新特征，我们可以通过Scanner类来获取用户的输入。</p>
</li>
<li><p>基本语法：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure>

<ul>
<li>通过Scanner类的next()与nextLine()方法获取输入的字符串，在读取前我们一般需要使用 hasNext()与hasNextLine()判断是否还有输入的数据。</li>
</ul>
<h3 id="next接收"><a href="#next接收" class="headerlink" title="next接收"></a>next接收</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个扫描器对象，用于接收键盘数据</span></span><br><span class="line">      <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">//接收用户的输入 并封装成scanner对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用next方式接收：&quot;</span>);</span><br><span class="line">        <span class="comment">///判断用户有没有输入字符串</span></span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNext()) &#123;<span class="comment">//默认这个里面为判断==true</span></span><br><span class="line">            <span class="comment">//使用next的方式接收</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.next(); <span class="comment">//程序等待用户输入完毕</span></span><br><span class="line">            System.out.println(<span class="string">&quot;用户输入的内容为&quot;</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//凡是始于IO流的类如果不关闭会一直占用资源，要养成好习惯用完就关掉。</span></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">calss2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;使用nextLine方式接收：&quot;</span>);</span><br><span class="line">        <span class="comment">//关闭程序的语句</span></span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNextLine())&#123;<span class="comment">//调用呐呐呐</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();<span class="comment">//等待语句运行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;输出的内容为：&quot;</span>+str);<span class="comment">//输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();<span class="comment">//关闭程序的语句</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>next()</p>
<ol>
<li>一定要读取到有效字符后才可以结束输出</li>
<li>对输入有效值字符之前遇到的恐怖，next()方法会自动将其去掉。</li>
<li>只有输入有效字符后才将其后面输入的恐怖作为分隔符或者结束符。</li>
<li>next() 不能得到带有空格的字符串。</li>
</ol>
</li>
<li><p>nextLine()</p>
<ol>
<li>以Enter为结束符，也就说nextLine（）方法是返回输入回车之前的所有字符。</li>
<li>可以获得空白。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">calss3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//从键盘接收数据</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入数据：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;输出的内容为:&quot;</span>+str);</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.security.sasl.SaslClient;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//从键盘接收数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0.0f</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入整数：&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNextInt())&#123;</span><br><span class="line">           i = scanner.nextInt();</span><br><span class="line">            System.out.println(<span class="string">&quot;整数数据：&quot;</span>+i);&#125;<span class="keyword">else</span> &#123; <span class="comment">//检测i是不是int类型，如果返回为false就走了else，如果不是就继续向下走</span></span><br><span class="line">            System.out.println(<span class="string">&quot;输入的不是整数数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入小数：&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNextFloat())&#123;</span><br><span class="line">            f = scanner.nextFloat();</span><br><span class="line">            System.out.println(<span class="string">&quot;小数数据：&quot;</span>+f);&#125;<span class="keyword">else</span> &#123; <span class="comment">//检测i是不是float类型，如果返回为false就走了else，如果不是就继续向下走</span></span><br><span class="line">            System.out.println(<span class="string">&quot;输入的不是小数数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVASE_2</title>
    <url>/2022/08/01/2022-8-1-%E8%BF%99%E6%98%AF%E7%88%B7%E7%9A%84%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<ol>
<li>通过函数访问到Scanner.java  （xxx.java）</li>
<li>通过左侧Structure 查看方法列表</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//我们可以输入多个数字，并求其总和与平均数，每输入一个数字用回车确认，通过输入非数字结束输入并输出执行结果。</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//和</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算输入了多少个数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="comment">//通过循环判断是否还有输入，并在里面对每一次进行求和统计</span></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextDouble())&#123;  <span class="comment">//whisle使用上感觉和if差不多，最重要的是理解java的程序结构</span></span><br><span class="line">            <span class="type">Double</span> <span class="variable">x</span> <span class="operator">=</span>scanner.nextDouble(); <span class="comment">//这条语句给x进行赋值，x是一个变量</span></span><br><span class="line">            System.out.println(<span class="string">&quot;你输入的x为：&quot;</span>+x);<span class="comment">//这里可以输出x的值，，而出了这个&#123;&#125;就不可以再输出x的值了</span></span><br><span class="line">            m = m +<span class="number">1</span>;<span class="comment">//可以写为m++</span></span><br><span class="line">            sum = sum + x; <span class="comment">//在这里将x的值加入到sum中</span></span><br><span class="line">            System.out.println(<span class="string">&quot;你输入了第&quot;</span>+m+<span class="string">&quot;个数据，&quot;</span>+<span class="string">&quot;当前结果为：&quot;</span>+sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println((double)x);//会导致出现报错，找不到符号，因为离开了上面的语句后x的没有得到赋值了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;输入数字的和为&quot;</span>+sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;一共输入了&quot;</span>+m+<span class="string">&quot;个数字&quot;</span>);</span><br><span class="line">        System.out.println(m+<span class="string">&quot;个数字的平均值为&quot;</span>+(sum/m));</span><br><span class="line"></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><ul>
<li><strong>JAVA的基本结构就是顺序结构，除非特别指明，否则就按照顺序一句一句执行。</strong></li>
<li>顺序结构是最简单那的算法结构</li>
<li>语句与语句之间，框与框之间是按照从上到下的顺序进行的，它是由若干个依次执行的处理步骤组成的，它是任何一共算法都离不开的一种基本算法结构。</li>
</ul>
<h2 id="if-单选择结构"><a href="#if-单选择结构" class="headerlink" title="if 单选择结构"></a>if 单选择结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package if233;</span><br><span class="line"></span><br><span class="line">import java.util.Scanner;   //if 单选择结构，表达式成立为true则输出再end</span><br><span class="line"></span><br><span class="line">public class class1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scanner = new Scanner(System.in);</span><br><span class="line">        System.out.println(&quot;请输入内容:&quot;);</span><br><span class="line">        String s = scanner.nextLine();</span><br><span class="line">        //s.equals:判断字符串是否相等</span><br><span class="line">        if (s.equals(&quot;Hello&quot;));&#123;//判断s和Hello这俩字符串是否相等捏</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        &#125; //不成立则直接End然后结束</span><br><span class="line">        System.out.println(&quot;End&quot;);</span><br><span class="line">        scanner.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="if-双选择结构"><a href="#if-双选择结构" class="headerlink" title="if 双选择结构"></a>if 双选择结构</h2><ul>
<li><p><strong>语法</strong></p>
</li>
<li><pre><code class="java">if (布尔表达式)&#123;
    //如果布尔表达式的值为true
&#125;else&#123;
    //如果布尔表达式的值为false
&#125;
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 实例\\</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h2 id="if多选择结构"><a href="#if多选择结构" class="headerlink" title="if多选择结构"></a>if多选择结构</h2><p><strong>语法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式 <span class="number">1</span>)&#123;</span><br><span class="line">	<span class="comment">//如果布尔表达式 1的值为true执行代码</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式 <span class="number">2</span>)&#123;</span><br><span class="line">	<span class="comment">//如果布尔表达式 2的值为true执行代码</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式 <span class="number">3</span>)&#123;</span><br><span class="line">	<span class="comment">//如果布尔表达式 3的值为true执行代码</span></span><br><span class="line">&#125;eles&#123;</span><br><span class="line">    <span class="comment">//如果以上布尔表达式都不为true执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;我日昨天的笔记没保存，呜呜呜呜呜呜呜呜呜</p>
<h1 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//考试分数&gt;60就是及格  &lt;60就是不及格</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入成绩：&quot;</span>);</span><br><span class="line">        scanner.nextInt();<span class="comment">//等待用户输入一个Int</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">//将输入的给score, score 等于 scanner.next里的int.</span></span><br><span class="line">        <span class="keyword">if</span> (score&gt;<span class="number">60</span>) &#123;<span class="comment">//如果score&gt;60则就执行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果不大于就走这个</span></span><br><span class="line">            System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class3</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if 语句至多有1一个else语句，else语句在所有的else if语句之后。</span></span><br><span class="line"><span class="comment">    if 语句可以有若干个else if 语句，他们必须在else语句之前。</span></span><br><span class="line"><span class="comment">    一旦其中一个 else if 语句检测为true,其他的else if 以及 else 语句都将跳过执行。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入成绩：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (score==<span class="number">100</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜满分！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score&gt;=<span class="number">90</span> &amp;&amp; score&lt;<span class="number">100</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score&gt;=<span class="number">80</span> &amp;&amp; score&lt;<span class="number">90</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score&gt;=<span class="number">70</span> &amp;&amp; score&lt;<span class="number">80</span>)&#123;<span class="comment">//会根据语句的先后执行，越靠前优先级越大</span></span><br><span class="line">            System.out.println(<span class="string">&quot;不戳&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score&gt;=<span class="number">60</span> &amp;&amp; score&lt;=<span class="number">70</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;海星&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (score&gt;=<span class="number">100</span> ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;开挂狗给爷爬&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;菜逼&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//考试分数&gt;60就是及格  &lt;60就是不及格</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入成绩：&quot;</span>);</span><br><span class="line">        scanner.nextInt();<span class="comment">//等待用户输入一个Int</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt(); <span class="comment">//将输入的给score, score 等于 scanner.next里的int.</span></span><br><span class="line">        <span class="keyword">if</span> (score&gt;<span class="number">60</span>) &#123;<span class="comment">//如果score&gt;60则就执行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果不大于就走这个</span></span><br><span class="line">            System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//Scanner scanner = new Scanner(System.in);</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">grade</span> <span class="operator">=</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">        <span class="keyword">switch</span> (grade)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//表示可选 ，如果没有break会出现case 穿透现象！如果没有匹配成功会一口气输出到最后。</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;海星&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;森么彩笔？&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;请不要搞事嗷！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">class6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;牛逼&quot;</span>;</span><br><span class="line">        <span class="comment">//JDK7新特性，表达式结果可以是字符串！！！</span></span><br><span class="line">        <span class="comment">//字符串本质还是数字捏</span></span><br><span class="line">        <span class="comment">//反编译 java---class(字节码文件)---反编译（IDEA）</span></span><br><span class="line">        <span class="keyword">switch</span> (name)&#123;<span class="comment">//将字符串name与各个对比</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;牛逼&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;卧槽果然牛逼！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//防止穿透</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;笑死&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;笑死我了什么垃圾&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;呵呵给爷爬！&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoWhile1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            sum = sum + i;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;<span class="keyword">while</span>(i&lt;<span class="number">100</span>);</span><br><span class="line">        System.out.println(sum);<span class="comment">//输出4950</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoWhile2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (a&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">            a++;</span><br><span class="line">        &#125;<span class="keyword">while</span> (a&lt;<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Do-while-如上"><a href="#Do-while-如上" class="headerlink" title="Do while 如上"></a>Do while 如上</h2><hr>
<h1 id="while-循环-和-for-的对比"><a href="#while-循环-和-for-的对比" class="headerlink" title="while 循环 和 for 的对比"></a>while 循环 和 for 的对比</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">For1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//初始化条件</span></span><br><span class="line">        <span class="keyword">while</span> (a&lt;=<span class="number">100</span>)&#123;<span class="comment">//条件判断</span></span><br><span class="line">            System.out.println(a);<span class="comment">//循环体</span></span><br><span class="line">            a+=<span class="number">2</span>;<span class="comment">//迭代</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;循环结束&quot;</span>);</span><br><span class="line">        <span class="comment">//初始化//条件判断//迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;for循环结束&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        关于for 循环有以下几点说明：</span></span><br><span class="line"><span class="comment">        最先执行初始化步骤。可以声明一种类型，但可初始化一个或多个循环控制变量，也可以是空语句。</span></span><br><span class="line"><span class="comment">        然后，检测布尔表达式的值。如果为true，循环体被执行。如果为flase,循环终止，开始执行循环体后面的语句。</span></span><br><span class="line"><span class="comment">        执行一次循环后，更新循环控制变量（迭代银子控制循环变量的增减）。</span></span><br><span class="line"><span class="comment">        再次检测布尔表达式。循环执行上面的过程。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//for 语句 死循环写法 for(; ;)&#123;  //因为没有初始值，没有判断，就会不停的跑下去</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">For2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//练习1：计算0到100之间的奇数和偶数的和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oddSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">evenSum</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i &lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">2</span>!=<span class="number">0</span>)&#123; <span class="comment">//奇数</span></span><br><span class="line">                oddSum+=i;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123; <span class="comment">//偶数</span></span><br><span class="line">                evenSum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(oddSum);</span><br><span class="line">            System.out.println(evenSum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">For3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//练习2：用while 或for循环输出1-1000之间能被5整除的数，并且每行输出3个</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i%<span class="number">5</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.print(i +<span class="string">&quot;\t&quot;</span>);<span class="comment">//不换行输出3个</span></span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span>(i%(<span class="number">5</span>*<span class="number">3</span>)==<span class="number">0</span>)&#123;<span class="comment">//如果 i%（5*3）==0的时候/5*3写15也行，写5*3貌似会更快（）</span></span><br><span class="line">                <span class="comment">//作用是如果输出三个就变成println，起到换行的作用，println和print的区别就是输出了</span></span><br><span class="line">                System.out.println();&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//方法二 System.out.print(\n);输出一个转义字符，\n 用来换行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">for7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]<span class="comment">/*这是个数组捏*/</span>args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> [] numbers = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;<span class="comment">//定义一个数组</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">            System.out.println(numbers[i]);<span class="comment">//在只有五个的数组中输出五个，如果输出的数量大于5则会报错</span></span><br><span class="line">        <span class="comment">//便利数组的元素</span></span><br><span class="line">        <span class="comment">//每次循环从x中取值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x:numbers)&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;上例为一个数组的测试</p>
<h2 id="break-continue-用来终止滴捏"><a href="#break-continue-用来终止滴捏" class="headerlink" title="break continue &#x2F;&#x2F;用来终止滴捏"></a>break continue &#x2F;&#x2F;用来终止滴捏</h2><ul>
<li>break在任何循环语句的主体部分，均可用Break控制循环的流程，break用于强行退出循环，不自行循环中小恒徐的语句。（break语句也在switch语句中使用）</li>
<li>continue 语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。</li>
<li>关于goto关键字 &#x2F;&#x2F;这是个锚，让你循环停的<ul>
<li>goto 关键字很早就mao在小恒徐设计语言中出现，尽管ogot仍是java的一个保留字，但未在语言中得到正是使用；Java没有goto.然而，在Break和continue这两个关键字的身上，我们仍能看出一些goto的影子—带标签的break和continue。</li>
<li>“标签”是指后面跟一个冒号的表示符，例如：label：</li>
<li>对Java来说唯一用到标签的敌方是在循环语句之前。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环，由于break和continue关键字通常只终端当前循环，但弱随同标签使用，它们就会中断到存在标签的地方。</li>
</ul>
</li>
</ul>
<h2 id="实例-打印三角形"><a href="#实例-打印三角形" class="headerlink" title="实例 打印三角形"></a>实例 打印三角形</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> if233;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lx1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//打印三角形</span></span><br><span class="line">        <span class="comment">//老子打印了个山，不管了就这样吧</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">5</span>; j &gt;= i; j--) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span><span class="number">0</span>; k &lt; i ; k++) &#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Debug-程序的断点"><a href="#Debug-程序的断点" class="headerlink" title="Debug 程序的断点"></a>Debug 程序的断点</h1><p>de虫虫~~~~虫虫！！！！！！！！~~~~~~~~~~</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>System.out.println(),那么它是什么呢？</li>
<li>System是一个类，out是输出对象，println是一个方法</li>
<li>意：&#x2F;&#x2F;调用系统内输出对象,out，里的println方法</li>
<li>命名规则：驼峰原则</li>
<li>Java方法是语句的集合，它们在一起执行一个功能。<ul>
<li>方法是解决一类问题的步骤的有序组合</li>
<li>方法包含于类或对象中</li>
<li>方法在程序中被创建，在其他地方被引用</li>
</ul>
</li>
<li>设计方法的原则：方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的原子性，就是一个方法只完成1个功能，这样利于我们后期的扩展。</li>
</ul>
<h1 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h1><ul>
<li><p>JAVA方法类似于其他语言的函数，是一段用来完成特定功能的代码片段，一般情况下，定义一个方法包含以下语法：</p>
</li>
<li><p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p>
<ul>
<li><p>修饰符：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</p>
</li>
<li><p>返回值类型：方法可能会返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字void。</p>
</li>
<li><p>方法名：是方法的实际名称。方法名和参数表共同构成方法签名。</p>
</li>
<li><p>参数类型：参数像一个占位符。当方法被调用时，传递值给参数。这个值被成为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。 参数是可选的，方法可以不包含任何参数。</p>
<ul>
<li><p>形式参数：在方法被调用时用于接收外界输入的数据</p>
</li>
<li><p>实参：调用方法时实际传给方法的数据</p>
</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>方法体：方法体包含具体的语句，定义该方法的功能。</li>
<li>例：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数类型 参数名）&#123;</span><br><span class="line">    ...</span><br><span class="line">   方法体</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="形式参数，用来定义作用"><a href="#形式参数，用来定义作用" class="headerlink" title="形式参数，用来定义作用"></a>形式参数，用来定义作用</h2><h2 id="实际参数，用来调用传递给他的参数"><a href="#实际参数，用来调用传递给他的参数" class="headerlink" title="实际参数，用来调用传递给他的参数"></a>实际参数，用来调用传递给他的参数</h2><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><ul>
<li>值传递：是指在调用函数时，将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，就不会影响到实际参数</li>
</ul>
<h3 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h3><ul>
<li><p>引用传递：是指在调用函数时，将实际参数的地址传递到函数中，那么在函数中对参数进行修改，将会影响到实际参数</p>
</li>
<li><p>引用数据类型分为两个部分，引用变量和对象，这两个部分放在不同的地方，引用变量在栈中，而对象是放在<a href="https://so.csdn.net/so/search?q=%E5%A0%86%E5%86%85%E5%AD%98&spm=1001.2101.3001.7020">堆内存</a>中的，引用变量指向对象。
如下图所示，当传递参数之前会将参数进行复制，但是复制的是引用变量，复制后的引用变量还是指向内存中的同一对象，所以引用传递中，函数修改了参数会影响实际参数</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201029230018688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N0YXJ0MTIzNDU2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>引用传递是对于引用数据类型而言，例如对于User类姓名的修改，会改变对象的name。</p>
<h5 id="注意点，引用类型中的String的值是放在常量池中，我们改变副本的值不会影响到原来的值。"><a href="#注意点，引用类型中的String的值是放在常量池中，我们改变副本的值不会影响到原来的值。" class="headerlink" title="注意点，引用类型中的String的值是放在常量池中，我们改变副本的值不会影响到原来的值。"></a><strong>注意点，引用类型中的String的值是放在常量池中，我们改变副本的值不会影响到原来的值。</strong></h5><p><img src="https://img-blog.csdnimg.cn/20201130214011215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1N0YXJ0MTIzNDU2Nw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><ul>
<li>例如在change放发中改变了副本的值，但是原来的str字符串不会改变。</li>
</ul>
</li>
</ul>
<h3 id="方法的重装"><a href="#方法的重装" class="headerlink" title="方法的重装"></a>方法的重装</h3><ul>
<li><p>在一个类中，有相同的函数名称，但形参不同的函数。</p>
</li>
<li><p>方法的重装的规则：</p>
</li>
<li><p>方法名称必须相同</p>
</li>
<li><p>参数列表必须不同（个数不同、或类型不同、参数排列顺序不同等。）</p>
</li>
<li><p>方法的返回类型可以相同也可以不相同</p>
</li>
<li><p>仅仅返回类型不同不足以成为方法的重载</p>
</li>
<li><p>实现理论:</p>
</li>
<li><p>方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。</p>
</li>
</ul>
<p>个人理解：相当于重新载入了一个同名的，不同的方法。</p>
<h3 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h3><p>程序运行的时候，用命令行传递给程序信息</p>
<p>注意点：1，路径找对，找到包的路径从包外面运行</p>
<p>注意点：2，实际上是通过定义命令行的参数运行程序</p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><ul>
<li>JKD 1.5 开始，Java支持传递同类型的可变参数给一个方法。</li>
<li>在方法声明中，在指定参数类型后加一个省略号（…）。</li>
<li>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Fangfa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo04</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMax</span><span class="params">(<span class="type">double</span>... numbers)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.length == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;23333&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">//懒得写了捏</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul>
<li>A方法调用A方法！自己调用自己</li>
<li>利用递归可以用简单的程序解决一些复杂的问题。它通常把一个大型复杂的问题层层华为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出接替过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对线的无限集合。</li>
<li>递归结构包括两个部分：</li>
<li><ul>
<li>递归头：什么时候不调用自身方法。如果没有头，将陷入死循环。</li>
<li>递归体：什么时候需要调用自身方法。</li>
</ul>
</li>
</ul>
<h2 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h2><p>前阶段：</p>
<p>返回阶段 n*(n-1)</p>
<p>（递归非常的耗内存）存在大量的函数调用捏</p>
<p><img src="C:\Users\Administrator.DESKTOP-PJMKVVR\AppData\Roaming\Typora\typora-user-images\image-20220505191817653.png" alt="image-20220505191817653"></p>
<h1 id="栈机制"><a href="#栈机制" class="headerlink" title="栈机制"></a>栈机制</h1>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>你说的对</title>
    <url>/2023/01/11/2023-1-11-nonebot/</url>
    <content><![CDATA[<p>你说的对，但是《NoneBot2》是由NoneBot团队自主研发的一款全新开放世界冒险游戏。游戏发生在一个被称作「QQ」的幻想世界，在这里，被神选中的人将被授予「go-cqhttp」，导引OneBotv11之力。你将扮演一位名为「插件开发者」的神秘角色，在自由的旅行中邂逅ModuleNotFoundError: No module named ‘nonebot.adapters.onebot’、ImportError: cannot import name ‘State’ from ‘nonebot.params’，和他们一起breaking change，找回失散的插件——同时，逐步发掘「NoneBot2 是一个跨平台的 Python 聊天机器人框架」的真相。</p>
]]></content>
      <categories>
        <category>Nonebot</category>
      </categories>
      <tags>
        <tag>Bot</tag>
      </tags>
  </entry>
  <entry>
    <title>这段时间的所感所想</title>
    <url>/2023/01/23/2023-1-23-%E8%BF%99%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E6%89%80%E6%84%9F%E6%89%80%E6%83%B3/</url>
    <content><![CDATA[<p>  导航制作一事任重而道远，暂时技术力不足以复刻bootstarp5的完美响应式布局部署内容，但PC端勉强看的过去固将计划延后。
  由于域名备案一事的问题，CDN的添加也暂缓。国外免费域名freenom不支持代理服务器连接有点生草，我以前是怎么登的？（大雾）
  但是没有CDN就意味着真实IP的暴露，我可不想服务器每天被打爆几个端口，所以网址暂不公开。
  再统计一下最近的计划中的项目，&#x3D;&#x3D;挖的坑是真多。
  首先是打算基于龙卷风实现的铁锈战争服务器，服务器是战网的基础。为什么要用Python写呢，因为最近很久我没办法重拾其他语言，如果可以的话我想用C++实现。这款应用主要是写网络层的东西，但是我唯一能参考的代码是Dr用Kotlin写的那玩意，我根据IDEA读了很久的代码，根据项目结构倒是推断出了其中实现原理的一部分，但是&#x3D;&#x3D;，我特喵真的不太懂这项目具体咋实现的，我无法推断自己的理解是否有误。简单来说我目前就是个有源码读也不一定能仿写成功的废材。也许我该多试试Debug吧，但是gradle那玩意真的很烦啊，为什么相同的源码会别人可以我却构建失败啊。&#x3D;&#x3D;真搞不懂java和kotlin!
  还有就是LOVE酱的开发，一款基于Nonebot框架实现的机器人。之前倒是写出个雏形来了，但是数据库以及AI模型还有RW接口我都一直在搁置，还有许诺群友写的小游戏写了一半又封存了。
  最后是答应文游圈群友打算实现的SLG游戏&#x3D;&#x3D;，不过我才新建文件夹呢，具体怎么实现八字没一撇。</p>
]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>gs被二月斯诺克 86：32</title>
    <url>/2023/01/12/2023-1-12-gs%E8%A2%AB%E4%BA%8C%E6%9C%88%E5%90%8A%E6%89%93/</url>
    <content><![CDATA[<p>gs被二月斯诺克 86：32
gs被二月斯诺克 86：32
gs被二月斯诺克 86：32
重要的事情说三遍</p>
]]></content>
      <tags>
        <tag>精彩记录</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端数据交流的实现方法</title>
    <url>/2023/02/20/2023-2-20-%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93/</url>
    <content><![CDATA[<p>前后端数据交流的实现方法</p>
<p>【关于笨蛋想出来的跨域请求的前后端方法】
这种方法比较笨，理解起来也不太容易。
第一步：
先通过web服务器部署一个前端页面。
可以使用apache,nginx，此类通用服务器，或者tomcat ,tornado，这类服务器，也可以手动用socket部署。
使用socket部署也很简单，只要监听请求，就将页面数据发送过去就可以了。
ps:第一步是为了将页面呈现出来，实现外部的访问，也就是我们的前端。
第二步：
使用编程语言写一个程序，监听一个端口，将此端口受到的数据进行处理。
而第一步部署的页面的表单，向此端口进行发送。
ps:思考一下，后端将数据发送回来，前端的程序又该如何写呢。这时候我产生了一些想法，前端只需要根据后端传来的数据判断，返回不同的页面就可以了。
ps:预防中间人攻击，TLS证书对双方传输的数据进行加密，这样被抓到数据包也无法将其破解。
ps:这种方法叫做跨域请求，因为端口不同的问题，会影响数据的传输。</p>
<p>【关于Djongo和正常的前后端方法】
这个方法的实现原理比方法一简单一些，但是更抽象一些。
这个方法就是通过web服务器框架直接进行前后端分离。
例如，Djongo，flask。
web服务器本身会监听一个端口，而传输数据则只需要传输到自己监听的端口就可以？
ps:众所周知Djongo是一个MVC架构的框架，但是因为使用了http协议，比起应用程序，要多一层浏览器的交互，这一层还是比较难理解的。
ps:实际上Djongo是通过内部的API和MongoDB进行交互的，表单将通过令牌验证后将数据发送到我们在Django中定义的视图。
ps:实际上Djongo等服务器的职能于方法一相同的，而仿写这个职能也很简单，只需要将数据发送给自身端口进行处理即可。
ps:实现方法：当端口接到http访问请求，呈现页面。接到数据请求，进行数据处理。</p>
<p>【关于CGI】
CGI：网关接口，可以直接编译并运行程序，将程序输出的内容呈现为页面。
猜测：网关接口的主要用途在于一个服务器支持多种编程语言写的web程序，并且减少端口资源的使用。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Python</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>一场记忆还算清楚的梦境</title>
    <url>/2023/03/11/2023-3-11-%E6%A2%A6%E5%A2%83/</url>
    <content><![CDATA[<p>忘记了是什么原因，也许是受人指使。我来到了一个酷似刑房的地方，这个刑房架在高空中，我必须踩着纤细木条移动，就像在走独木桥一样。我跳上的绞肉机上方的木条，从断头台走过到了另一端，面前只剩下了几个更为纤细和脆弱的木条在眼前。我明白，我必须踩着木条移动过去。眼前纤细的木条飘在空中我没有半分的惊诧。我义无反顾的走了上去，快速的到了最纤细的那根上，也是最后的一根，眼前没有了道路，脚下是深渊。而木条在我踩上去顷刻之间便如被咬碎的花生糖一般变成碎片，虽然花生糖这个形容并不恰当，但我感觉这些最贴合的【口感】。紧接着，我向下坠落而去，坠下深渊。下方是数不清的触手，神秘莫幻的色彩，以及我无法形容出来的，潜藏在阴影之中的生物。但我没有完全的坠下去，我落到了深渊中心的木条上，我紧紧的抱着木条，而木条的两端似乎和这个世界的天空有绳索相连，就这样我抱着木条缓缓地向下，越来越接近怪物。终于我直视了一眼天空，却只看到早已经被如海葵般舞动的触手遮挡了起来。触手是黑暗主色调的，却又掺杂着一丝光亮的彩色。全程中毫无恐惧之意，似乎一切都理所当然。而到达深渊底部后的一些记忆全部都缺失，我不明白发生了什么。今天的故事，就此收尾。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>故事</tag>
        <tag>梦境</tag>
      </tags>
  </entry>
  <entry>
    <title>抛心之人的寻心之词</title>
    <url>/2023/01/03/2023-1-3-%E4%BD%9C%E8%AF%8D/</url>
    <content><![CDATA[<h2 id="曾几何时，我伤透了心我以为，是感情导致我的失败我试图冷漠无情藐视一切的情感，自认为这会使我更强而实际上就如同人失去了血肉一样将骨骸裸露只让我变得更脆弱"><a href="#曾几何时，我伤透了心我以为，是感情导致我的失败我试图冷漠无情藐视一切的情感，自认为这会使我更强而实际上就如同人失去了血肉一样将骨骸裸露只让我变得更脆弱" class="headerlink" title="曾几何时，我伤透了心
我以为，是感情导致我的失败
我试图冷漠无情
藐视一切的情感，自认为这会使我更强
而实际上
就如同人失去了血肉一样
将骨骸裸露
只让我变得更脆弱"></a>曾几何时，我伤透了心
我以为，是感情导致我的失败
我试图冷漠无情
藐视一切的情感，自认为这会使我更强
而实际上
就如同人失去了血肉一样
将骨骸裸露
只让我变得更脆弱</h2><h2 id="我不再感情用事纠结利益的得失我希望能堕入黑暗在万劫不复的深渊中重生得到的仅仅是绝望"><a href="#我不再感情用事纠结利益的得失我希望能堕入黑暗在万劫不复的深渊中重生得到的仅仅是绝望" class="headerlink" title="我不再感情用事
纠结利益的得失
我希望能堕入黑暗
在万劫不复的深渊中重生
得到的仅仅是绝望"></a>我不再感情用事
纠结利益的得失
我希望能堕入黑暗
在万劫不复的深渊中重生
得到的仅仅是绝望</h2><h2 id="我希望我能重新追逐光血肉生长长出心脏我明白，血肉生长的同时弱点会伴随而生但即便如此我至少是个人而不是骸骨"><a href="#我希望我能重新追逐光血肉生长长出心脏我明白，血肉生长的同时弱点会伴随而生但即便如此我至少是个人而不是骸骨" class="headerlink" title="我希望我能重新追逐光
血肉生长
长出心脏
我明白，血肉生长的同时
弱点会伴随而生
但即便如此
我至少是个人
而不是骸骨"></a>我希望我能重新追逐光
血肉生长
长出心脏
我明白，血肉生长的同时
弱点会伴随而生
但即便如此
我至少是个人
而不是骸骨</h2><p>题：抛心之人的寻心之词
2023.1.3</p>
]]></content>
      <categories>
        <category>寻心</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>寻心</tag>
      </tags>
  </entry>
  <entry>
    <title>饺子店的童话</title>
    <url>/2023/03/14/2023-3-14-%E9%A5%BA%E5%AD%90%E5%BA%97%E7%9A%84%E7%AB%A5%E8%AF%9D/</url>
    <content><![CDATA[<p>从前有一家饺子店，饺子物美价廉，但在噪杂的城市中并不显眼，生意平平。有一天，老板娘抱怨道：“只靠卖饺子，什么时候才能赚够买房的钱啊？”老板顿了顿，说道：“只要一直卖下去，好好的包饺子，肯定能赚够的。“虽后看了看店铺里冷清的现状，自言自语般的说道：”能卖一百万份饺子，就好了。”</p>
<p>有一天，店里来了个奇怪的客人。穿着黑色的西装，戴着礼帽，像是从电影里走出来似的。最奇怪的一点是，无论老板怎么看他，都无法看清他的脸，简直是活见鬼了。老板强装淡定，认为自己一定是老花眼了，笑着问道：“个人，来吃饺子吗？”</p>
<p>“不错不错，但我要的量有点大，不知道你们这小店吃不吃得下。”西装男以一副奇怪沙哑的嗓音开口，向着饺子店的老板说道。</p>
<p>“放心放心，我们店虽小，但我们可勤快了，不知道客人您要多少饺子。”老板心中一喜，连忙答应下来，询问道。</p>
<p>“这张支票你先拿着，明天开始我每天都来吃饺子，你包够够我吃的即可。”西装男丢出一张支票，支票像变魔术似的，顺着风飘进了老板的口袋。</p>
<p>饺子铺老板拿出支票一看，顿时吓了一跳，上面竟然有一大串的零。“个，拾，佰，仟，万，拾万，佰万，竟然有五…”老板激动的差点喊出来，看了一眼店铺里还在吃饭的食客，发现没有人注意到自己后，将支票收了起来，拿起毛巾擦了擦头上因为激动流出来的汗水。</p>
<p>“老婆，帮我看着点店，我出去办点事。”老板对厨房里忙活的妻子吩咐道，听到妻子嗯了一声后，急匆匆的打D来到了银行。</p>
<p>“先生，请问有什么需要帮助的吗？”</p>
<p>“我要兑支票。”</p>
<p>手续办的很快，在兑现完成后银行的工作人员给他推荐了一堆的投资和理财的业务，还有种种福利之类的，听的老板晕头转向。待到出了银行大门才回过神来，赶紧看了一眼自己的手机银行，一查，真的多了五百万，自己从未有过这么多钱！这一切让老板有些精神恍惚。久违的打了个平时不肯轻易坐的出租车回到了饺子店。</p>
<p>老板强忍着，没有告诉妻子这个消息，担心钱财外露遭到觊觎。并且西装男的请求还没有完成，让老板心里有些没底，什么叫包够够他吃的饺子，老板猜想肯定没有那么简单，便决定今晚多包50笼饺子。心想：“这下肯定够吃的了吧。”</p>
<p>未完待续…</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>童话</tag>
        <tag>故事</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 模块重载</title>
    <url>/2023/03/06/2023-3-6%20234624-Python%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>在使用Nonebot框架进行的开发中，我接触到了许多新的概念，也了解了更多知识。
大概有，如下：</p>
<ul>
<li>async 异步语句</li>
<li>python程序模块化的更深概念</li>
<li>线程的阻塞</li>
<li>装饰器</li>
<li>json数据的处理</li>
<li>类的实际使用</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Gitee搭建Page的一些注意事项</title>
    <url>/2023/03/06/2023-3-6-%E5%85%B3%E4%BA%8EGitee%E6%90%AD%E5%BB%BAHexo%E7%9A%84%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h1 id="关于Gitee搭建Page的一些注意事项"><a href="#关于Gitee搭建Page的一些注意事项" class="headerlink" title="关于Gitee搭建Page的一些注意事项"></a>关于Gitee搭建Page的一些注意事项</h1><p>此文章专门为从Github使用者转国内Gitee开源平台的人而写，作者纯小白，如有误区欢迎指正。
此前我的个人博客部署在Github，但因地域问题国内访问速度太过尴尬，在发现国内开源社区后我便探寻有无类似的功能，答案是有的。但在探寻的过程中我发现一些差异，与国外的Github并不是完全一样，也因此踩了不少坑。故写下此文章，希望能帮到有类似情况的人，也便于我进行记忆。
整个步骤一共分为三步：
        0. 实名认证（国内政策需要）
        1. 建立代码仓：我们需要代码仓储存我们静态网站的源代码文件
        2. 开源代码仓：Gitee已停止对闭源代码仓提供Page服务
        3. 在PUSH完成后在Page服务页面进行选择更新
 看似几乎没有区别，仅仅多了第0步和第3步，其实每一步的背后都有着存在的意义。
 主要踩坑还是第三步，因为github的Page页面是实时的更新的，会自动的读取代码仓中的内容。而Gitee必须选择手动提交，以至于我因为用惯了Github，便在测试的时候反复刷新页面和Push代码，一直没找到问题。</p>
<h2 id="关于误区"><a href="#关于误区" class="headerlink" title="关于误区"></a>关于误区</h2><p>网上的几乎都是以自己名字当作代码仓运行GiteePage的教程，甚至有的教程说不可以在其他名称的仓库搭建hexo架构的博客。后者简直是误人子弟，我这个博客便是最好的证明。
 只需要解决其中一个小细节即可，那就是修改 _config.yml 之中的文件</p>
<pre><code class="yml">    index_generator:
  path: &#39;myblog&#39;
  per_page: 10
  order_by: -date




&amp;ensp修改path的字符串为仓库名称即可，实际上path指向的是网站开始的目录。


---

经过实践证明以上纯几把扯淡！！！！！！！！！！！

##最后一点
Gitee有一套审查系统，会在网站进行部署/更新的时候，检查网页中是否含有敏感内容，若是出现则无法通过审核会自动的终止部署。







</code></pre>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask[携行]</title>
    <url>/2023/07/07/2023-7-7-Flask-10/</url>
    <content><![CDATA[<h1 id="flask-设置cookie过期时间"><a href="#flask-设置cookie过期时间" class="headerlink" title="flask 设置cookie过期时间"></a>flask 设置cookie过期时间</h1><p>如果不设置cookie的过期时间，则默认关闭浏览器时cookie过期。</p>
<p>flask设置过期时间，遵循下面的三条规则：</p>
<ol>
<li>max_age: 规定多少秒以后过期</li>
<li>expires：datatime类型，使用此参数，需参照格林尼治时间，即北京时间-8个小时</li>
<li>如果max_age和expires都设置，则以max_age为主</li>
</ol>
<p>设置了cookie过期时间，即便浏览器都关闭了，只要没有cookie还在有效期内，再次打开浏览器，cookie依然有效。</p>
<p>如果超过了cookie的过期时间，即便浏览器没有关闭，cookie也会失效。</p>
<p>只要设置了cookie的过期时间，是否失效就已经和浏览器是否关闭无关。</p>
<h2 id="1-通过max-age设置cookie有效期"><a href="#1-通过max-age设置cookie有效期" class="headerlink" title="1. 通过max_age设置cookie有效期"></a>1. 通过max_age设置cookie有效期</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, make_response, request</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="comment"># 尝试获取 first_access cookie</span></span><br><span class="line">    first_access = request.cookies.get(<span class="string">&#x27;first_access&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> first_access <span class="keyword">is</span> <span class="literal">None</span>:        <span class="comment"># 没有first_access cookie， 是第一次来</span></span><br><span class="line">        first_access = datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">        res = make_response(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">        res.set_cookie(<span class="string">&#x27;first_access&#x27;</span>, first_access, max_age=<span class="number">60</span>)        <span class="comment"># 在响应头里设置cookie</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">else</span>:       <span class="comment"># 不是第一次来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;你第一次访问这个网页的时间是: <span class="subst">&#123;first_access&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>设置了cookie的过期时间是60秒，那么一分钟以后，再次访问时，页面里显示的内容就是hello world， 服务以为我是第一次来，原因是cookie已经失效，能够记录我第一次来访问的信息已经不存在了。</p>
<h2 id="2-通过expires-设置过期时间"><a href="#2-通过expires-设置过期时间" class="headerlink" title="2. 通过expires 设置过期时间"></a>2. 通过expires 设置过期时间</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, make_response, request</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="comment"># 尝试获取 first_access cookie</span></span><br><span class="line">    first_access = request.cookies.get(<span class="string">&#x27;first_access&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> first_access <span class="keyword">is</span> <span class="literal">None</span>:        <span class="comment"># 没有first_access cookie， 是第一次来</span></span><br><span class="line">        first_access = datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">        res = make_response(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">        expires_time = datetime(year=<span class="number">2021</span>, month=<span class="number">9</span>, day=<span class="number">7</span>, hour=<span class="number">18</span>)</span><br><span class="line">        res.set_cookie(<span class="string">&#x27;first_access&#x27;</span>, first_access, expires=expires_time)        <span class="comment"># 在响应头里设置cookie</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">else</span>:       <span class="comment"># 不是第一次来</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;你第一次访问这个网页的时间是: <span class="subst">&#123;first_access&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>我设置cookie的过期时间是9月7日的18点，但通过浏览器查看cookie信息，显示过期时间是9月8日的凌晨2点，相差了8个小时，这是因为浏览器里会主动加8个小时，想要和我们的北京时间保持一致，在设置的时候就要减去8个小时。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">expires_time = datetime(year=<span class="number">2021</span>, month=<span class="number">9</span>, day=<span class="number">7</span>, hour=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>现在的cookie过期时间是9月7日下午18点。</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Nonebot创建聊天教学功能</title>
    <url>/2023/03/08/2023-3-8-Nonebot%E5%88%9B%E5%BB%BA%E8%81%8A%E5%A4%A9%E6%95%99%E5%AD%A6%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><p>  在阅读前辈代码的时候我发现前辈们会专门的分出一个类专门进行数据处理相关的操作，于是我便顺着这个想法改进了我的代码。</p>
<p>  这使我项目代码的结构更为规整和简化，也提高了代码的可读性，在节省代码量的同时并没有影响工作效率。</p>
<h4 id="一、实现简易的教学功能"><a href="#一、实现简易的教学功能" class="headerlink" title="一、实现简易的教学功能"></a>一、实现简易的教学功能</h4><p>构建思路：制造一个词库，无非就是，将获取的消息存入指定的json文件中，在需要响应消息的时候查询是否有相关的消息，如果有则回复。</p>
<p>实现：在BOT收到 @LOVE酱 教学-XX&#x3D;XX 格式的消息时，会自动的分割消息，将教学内容和需要回复的词分开传参。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> nonebot.adapters.onebot.v11 <span class="keyword">import</span> Event</span><br><span class="line"><span class="keyword">from</span> nonebot.adapters.onebot.v11.bot <span class="keyword">import</span> Bot</span><br><span class="line"><span class="keyword">from</span> nonebot.plugin.on <span class="keyword">import</span> on_command</span><br><span class="line"><span class="keyword">from</span> nonebot.rule <span class="keyword">import</span> to_me</span><br><span class="line"><span class="keyword">from</span> love.db <span class="keyword">import</span> JsonDB <span class="comment">#这一段尤为重要，正是在这一段中引入了我们处理数据库的类</span></span><br><span class="line"></span><br><span class="line">study = on_command(cmd=<span class="string">&#x27;教学-&#x27;</span>, rule=to_me(), priority=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@study.handle()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_func</span>(<span class="params">bot: Bot, event: Event</span>):</span><br><span class="line">    QQ = event.get_session_id().split(<span class="string">&#x27;_&#x27;</span>)[<span class="number">2</span>]  <span class="comment"># 获取QQ号</span></span><br><span class="line">    message = <span class="built_in">str</span>(event.get_message()).split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;=&#x27;</span>)  <span class="comment"># 事件消息内容</span></span><br><span class="line">    send = message[<span class="number">0</span>]</span><br><span class="line">    Reply = message[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    Save = JsonDB(QQ=QQ, send=send, Reply=Reply)</span><br><span class="line">    Save.Save()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> study.send(<span class="string">&#x27;教学成功！(请等待主人审核哦~)&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现操作json数据的类，起到心脏的作用。</p>
<p>将消息名作为文件名进行保存，再将消息存入json中，并记录时间和教学者的信息，</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JsonDB</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, QQ, send, Reply</span>):</span><br><span class="line">        self.QQ = QQ</span><br><span class="line">        self.send = send</span><br><span class="line">        self.Reply = Reply</span><br><span class="line"><span class="comment">#初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#保存消息的方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">Save</span>(<span class="params">self</span>):</span><br><span class="line">        now = datetime.now()</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&quot;教学人&quot;</span>: self.QQ,</span><br><span class="line">            <span class="string">&quot;时间&quot;</span>: now.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>),</span><br><span class="line">            self.send: self.Reply</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">#构建json消息段</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;curPathTwo + self.send&#125;</span>.json&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">            json.dump(data, json_file)</span><br><span class="line">        <span class="comment">#将消息存入</span></span><br></pre></td></tr></table></figure>

<p>解决了保存，那么如何响应呢。</p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Reply = on_command(cmd=<span class="string">&#x27;&#x27;</span>, rule=to_me(), priority=<span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Reply.handle()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_func</span>(<span class="params">bot: Bot, event: Event</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">str</span>(event.get_message())) &gt;= <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">        Load = JsonDB(QQ=<span class="string">&#x27;&#x27;</span>, Reply=<span class="string">&#x27;&#x27;</span>, send=event.get_message())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> Reply.send(Load.Load())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        message = [<span class="string">&quot;你好，这里是LOVE酱，发送 帮助 可以查看我的功能哦！&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;你好呀，我是LOVE酱，一个专为铁锈战争服务的虚拟少女！&quot;</span>,</span><br><span class="line">                   <span class="string">&quot;你好~有什么需要帮助的吗？&quot;</span>]</span><br><span class="line">        rnd = random.Random()</span><br><span class="line">        Num = rnd.randint(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span>  Reply.send(message[Num])</span><br></pre></td></tr></table></figure>

<p>上面这段代码的作用是：在被艾特的时候随机响应一段回复词，而检测到字符串的时候便将字符串传参，实例化类并调用我们的写的查询方法，以此得到我们的回复词。</p>
<p>查询方法的代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Load</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 从JSON文件中读取数据并解码为Python对象</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;curPath + self.send&#125;</span>.json&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">            data = json.load(json_file)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> data[<span class="string">f&quot;<span class="subst">&#123;self.send&#125;</span>&quot;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;LOVE酱现在还听不懂哦~可以教我吗？&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里用到了一段异常处理：</p>
<ul>
<li><p>如果用户访问的文件存在，则会返回json中对应的键的值，也就是之前写入的字符串。</p>
</li>
<li><p>如果用户访问的文件并不存在，则说明这个词汇并没有被教学过，同时会引发异常，方法就会返回 “LOVE酱现在还听不懂哦~可以教我吗？” 这段字符串。</p>
</li>
</ul>
<h4 id="二、实现简易的审核功能"><a href="#二、实现简易的审核功能" class="headerlink" title="二、实现简易的审核功能"></a>二、实现简易的审核功能</h4><p>写到这里可能就会有人会问了，教学实现了，要是被教学了奇怪的话怎么办呀？能不能写一个审核机制？</p>
<p>当然是可以的。</p>
<p>我实现审核机制的原理是，将新教学的词先暂放到一个文件夹里，这个文件夹称为待审核文件夹，而这个文件夹里面的词汇是待审核词汇。在Master同意某个词汇后，就将词汇转移到过审文件夹中，而我们的响应方法只会去响应过审后文件夹里的词汇。这样，便成功的实现了简易的审核机制。</p>
<p>代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Examine = on_command(cmd=<span class="string">&#x27;查看待审核词汇&#x27;</span>, priority=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Examine.handle()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_func</span>(<span class="params">bot: Bot, event: Event</span>):</span><br><span class="line">    QQ = event.get_session_id().split(<span class="string">&#x27;_&#x27;</span>)[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">int</span>(QQ) != <span class="number">3345483363</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> Examine.send(<span class="string">&quot;你不是LOVE的主人哦~&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        curPath = os.path.abspath(os.path.pardir) + <span class="string">&quot;/LOVE/love/data/Examine/&quot;</span></span><br><span class="line">        listFiles = os.listdir(curPath)  <span class="comment"># 获取文件目录</span></span><br><span class="line">        message = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        QQ = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(listFiles)):</span><br><span class="line">            Load = JsonDB(QQ=QQ, Reply=<span class="string">&#x27;&#x27;</span>, send=listFiles[i])</span><br><span class="line">            Text = listFiles[i].split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>] + <span class="string">&#x27;:&#x27;</span> + Load.ExamineLoad()</span><br><span class="line">            message += Text + <span class="string">&#x27;|&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> Examine.send(<span class="string">f&quot;待审核的词汇如下：<span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>以上代码中，我们通过查看待审核文件夹中的文件，将文件名和文件中键对应的值提取出来组成字符串。就可以看到待审核的教学词汇。</p>
<p>实现移动文件和读取审核文件夹内名称的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">curPathTwo = <span class="built_in">str</span>(os.path.abspath(os.path.pardir) + <span class="string">&quot;/LOVE/love/data/Examine/&quot;</span>).replace(<span class="string">&#x27;db/&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ExamineLoad</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;读取待审核文件夹内的文件名&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;curPathTwo + self.send&#125;</span>&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">            data = json.load(json_file)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> data[<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">str</span>(self.send).split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>]&#125;</span>&quot;</span>]  <span class="comment"># 将文件名返回</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">MOVE</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;将文件转移实现通过审核&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            shutil.move(curPathTwo + self.send, curPath)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            os.unlink(curPath + self.send)</span><br><span class="line">            shutil.move(curPathTwo + self.send, curPath)  <span class="comment"># 发现文件重复则删除文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="实现让用户自行撤回提交错误的词汇的功能"><a href="#实现让用户自行撤回提交错误的词汇的功能" class="headerlink" title="实现让用户自行撤回提交错误的词汇的功能"></a>实现让用户自行撤回提交错误的词汇的功能</h4><p>为了减轻Master的工作量，也为了提高用户体验。</p>
<p>我们考虑到用户有时候可能打错字，便增加了一个撤回的功能。</p>
<p>如果没用这个功能，而用户又想要删去这个提交错误的词汇，差不多就只能联系Master了，这样子很不方便。</p>
<p>而在实现功能中，我们需要考虑一点，那就是，需要实现只有发送这个词汇的人才能撤回这个词汇。</p>
<p>还记得我们存储数据使用的格式吗？忘了没关系，我们一起看看：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;教学人&quot;</span><span class="punctuation">:</span> self.QQ<span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;时间&quot;</span><span class="punctuation">:</span> now.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)<span class="punctuation">,</span></span><br><span class="line">    self.send<span class="punctuation">:</span> self.Reply</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在我们存储的每一个词汇的json文件里，我们有三个键，教学人、时间、以及接受词。分别对应QQ、时间、回复词。</p>
<p>而解决用户直接身份甄别的关键就在此处，那就是json中的教学人，只要我们将其于发送消息者的QQ进行对比，就可以看出这个词是不是教学人创建的。</p>
<p>ps: 有一个BUG可以卡，就是下一个人创建的词会覆盖上一个人的内容。）</p>
<p>话不多说，上代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">recall = on_command(cmd=<span class="string">&#x27;撤回-&#x27;</span>, rule=to_me(), priority=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@recall.handle()</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">handle_func</span>(<span class="params">bot: Bot, event: Event</span>):</span><br><span class="line">    QQ = event.get_session_id().split(<span class="string">&#x27;_&#x27;</span>)[<span class="number">2</span>]  <span class="comment"># 获取QQ号</span></span><br><span class="line">    message = <span class="built_in">str</span>(event.get_message()).split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">1</span>]  <span class="comment"># 事件消息内容</span></span><br><span class="line">    send = message</span><br><span class="line"></span><br><span class="line">    REC = JsonDB(QQ=QQ, send=send, Reply=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> recall.send(REC.recall())</span><br></pre></td></tr></table></figure>

<p>然后是在类中实现的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recall</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 从JSON文件中读取数据并解码为Python对象</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;curPathTwo + self.send&#125;</span>.json&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">            data = json.load(json_file)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.QQ == data[<span class="string">&#x27;教学人&#x27;</span>]:</span><br><span class="line">            os.remove(curPathTwo + self.send+<span class="string">&#x27;.json&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;已成功撤回词汇&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;您并不是这个词汇的教学人哦~&#x27;</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;您并没有提交过这个词汇哦~&#x27;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/09/25/2023-7-8-Flask-11/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Android项目文件目录分析</title>
    <url>/2023/08/27/2023-8-27-Android%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>相信对第一次接触安卓开发的人来说，安卓应用的项目结构很令人疑惑。</p>
<p>  刚巧，我也是，才下载了 <code>Android Studio</code>不久。看了不少的安卓教程，然后创建了一个示例项目准备摸索摸索。我去，怎么这么多代码，这么多文件，瞬间傻眼了。</p>
<p>  不再傻眼，也为了更多和我一样的小白开发者不再傻眼，跟着我的视角，我们一起走进这个安卓App，看看它到底是个什么构造。</p>
<p>  首先复制项目路径，打开文件管理器，进入我们的安卓项目文件夹。</p>
<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/%E8%B7%AF%E5%BE%84.png" class="">

<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95.png" class="">

<p>  来到这个页面后，我们看到前缀没有 <code>.</code> 的正常目录有 <code>app</code> 和 <code>gradle</code> 两个文件夹。能走到这一步的同学，必然是创建了项目了，也就安装好了<code>gradle</code>了，所以不再赘述，我们进入<code>app</code>文件夹。</p>
<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/app%E7%9B%AE%E5%BD%95.png" class="">

<p>  在此之前我已经编译过一次app，因此目录下有</p>
<ul>
<li><p><code>build</code> ：存放着构建后的内容</p>
</li>
<li><p><code>libs</code> : 存放着引用的外部库（因为没有使用里面试试空的）</p>
</li>
<li><p><code>src</code> : 源代码文件夹。</p>
<p>三个文件夹。</p>
</li>
</ul>
<p>因此，我们进入 <code>src</code> 这个文件夹。</p>
<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/src%E7%9B%AE%E5%BD%95.png" class="">

<p>  <code>src</code> 目录下，有三个文件夹：</p>
<ul>
<li><code>androidText</code> ：存放着Instrumented测试代码。Instrumented测试与单元测试不同，它们可以运行在整个Android应用或框架上，并可以访问Android系统服务和API。 </li>
<li><code>main</code>：存放着主程序。</li>
<li><code>test</code>：存放着单元测试代码。单元测试是软件开发中的一种实践，用于确保代码的各个单元按照预期工作。</li>
</ul>
<p>  很显然我们当务之急需要的是去了解<code>main</code>文件夹中的内容。</p>
<hr>
<p>  访问进去，有两个文件夹和一个<code>AndroidManifest.xml</code>文件。</p>
<p><code>AndroidManifest.xml</code>：在Android程序中，所有的Activity都需要在<code>AndroidManifest.xml</code>中声明，才能够被用户通过INTENT找到。除了Activity以外，服务（Service）、广播接收者（BroadcastReceiver）、ContentProvider都需要在<code>AndroidManifest.xml</code>中声明。</p>
<p>关于这两个文件夹：java |  res</p>
<ul>
<li>java：存放着java代码。（我选择了java项目示例，我选择在深度学习过java开发安卓后再转koutlin）</li>
<li>res : 存放着各种资源文件。（稍后将一一的解释。）</li>
</ul>
<hr>
<p>  下面我将列举一下示例项目中已存在的文件</p>
<p>  <code>java\com\example\magichome</code> 在这个路径下有：<code>data</code>,<code>ui</code>,两个文件夹。</p>
<p>  <code>data</code>文件夹中包含一个<code>model</code>文件夹,还有:</p>
<ol>
<li><p><code>LoginDataSource.java</code>：该类用于处理用户登录和注销的操作。</p>
</li>
<li><p>&#96;&#96;LoginRepository.java&#96;：用于处理用户登录和注销的操作，并维护一个内存中的登录状态和用户凭证信息缓存。</p>
</li>
<li><p><code>Result.java</code>：用于封装处理结果，包括成功的结果和错误的结果。</p>
</li>
</ol>
<p>  总共三个文件。</p>
<p><code>model文件夹</code>：</p>
<ul>
<li><code>LoggedInUser.java</code>：一个数据类，主要用于存储已登录用户的用户信息。这个类是从<code>LoginRepository</code>中获取的。</li>
</ul>
<hr>
<p><code>  ui</code>文件夹中包含一个<code>login</code>文件夹，其中包含:</p>
<ol>
<li><code>LoggedInUserView.java</code>：主要用于将已登录用户的详细信息暴露给用户界面（UI）。</li>
<li><code>LoginActivity.java</code>：实现一个登录活动的 Android 应用程序的一部分。该活动使用数据绑定和<code>ViewModel </code>来管理用户输入和登录状态。</li>
<li><code>LoginFormState.java</code>：主要用于表示登录表单的数据验证状态。</li>
<li><code>LoginResult.java</code>：主要用于封装登录操作的结果。</li>
<li><code>LoginViewModel.java</code></li>
<li><code>LoginViewModelFactory.java</code>：创建并返回一个特定的ViewModel。</li>
</ol>
<p>  总共六个文件。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>安卓 XML 文件 分析</title>
    <url>/2023/08/28/2023-8-28-Android%20XML%20File%20Analysis/</url>
    <content><![CDATA[<h1 id="安卓-XML-文件-分析"><a href="#安卓-XML-文件-分析" class="headerlink" title="安卓 XML 文件 分析"></a>安卓 XML 文件 分析</h1><p>本文以深度分析安卓的XML文件为主，了解XML文件的作用，以便于更好的理解开发的各个概念。</p>
<p>学而不思则罔，思而不学则殆。</p>
<p>要学习，先思考。</p>
<p>首先定义三个问题：</p>
<ol>
<li>为什么要用到XML？</li>
<li>XML文件是如何被引用的？</li>
<li>XML的各个元素在java文件中又是如何表示的？</li>
</ol>
<h2 id="问题解答环节-（一）"><a href="#问题解答环节-（一）" class="headerlink" title="问题解答环节 （一）"></a>问题解答环节 （一）</h2><h3 id="问题一：为什么要用到XML？"><a href="#问题一：为什么要用到XML？" class="headerlink" title="问题一：为什么要用到XML？"></a>问题一：为什么要用到XML？</h3><p>答：主要出于以下几个原因</p>
<ul>
<li><p>方便定义用户界面</p>
<ul>
<li>XML非常的适合描述界面的视图元素，这使得开发人员能够以声明的形式定义界面元素，而不必在代码中直接构建和布局。</li>
</ul>
</li>
<li><p>方便逻辑与布局分离</p>
<ul>
<li>XML文件描绘布局，java或kotlin文件实现逻辑，就这么简单。</li>
</ul>
</li>
<li><p>代码简化</p>
<ul>
<li>代码分开写，看起来更简单。</li>
</ul>
</li>
<li><p>支持可扩展性</p>
<ul>
<li>XML被设计为可扩展的标记语言</li>
</ul>
</li>
<li><p>与安卓API集成</p>
<ul>
<li>可以通过使用XML布局文件和Android的API，开发人员可以轻松地创建动态的用户界面，响应用户的操作。（似懂非懂）</li>
</ul>
</li>
</ul>
<h3 id="问题二：XML代码是如何被引用的？"><a href="#问题二：XML代码是如何被引用的？" class="headerlink" title="问题二：XML代码是如何被引用的？"></a>问题二：XML代码是如何被引用的？</h3><p>首先，看代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.demoproject1.databinding.FragmentFirstBinding;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.Fragment;</span><br><span class="line"><span class="keyword">import</span> androidx.navigation.fragment.NavHostFragment;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewCreated</span><span class="params">(<span class="meta">@NonNull</span> View view, Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="comment">// 实现xml导航</span></span><br><span class="line">        <span class="built_in">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line"></span><br><span class="line">        binding.buttonFirst.setOnClickListener(<span class="keyword">new</span> <span class="title class_">View</span>.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view)</span> &#123;</span><br><span class="line">                NavHostFragment.findNavController(FirstFragment.<span class="built_in">this</span>)</span><br><span class="line">                        .navigate(R.id.action_FirstFragment_to_SecondFragment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上图代码中 <code>R.id.action_FirstFragment_to_SecondFragment</code> 这行代码，可以直接访问到<code>nav_graph.xml</code></p>
<p>文件。</p>
<p>实质: <code>action</code>  作用: First Fragment to Second Fragment</p>
<p>解释: 将 第一片 Fragment导航到了 第二片 Fragment</p>
<p>通过<code>NavHostFragment.findNavController()</code>这个方法,实现了Fragment之间的导航管理.</p>
<p>看到这里,还没明白?没关系,来看看<code>nav_graph.xml</code>这个文件的内容.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">navigation</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/nav_graph&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:startDestination</span>=<span class="string">&quot;@id/FirstFragment&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/FirstFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.example.demoproject1.FirstFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/first_fragment_label&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:layout</span>=<span class="string">&quot;@layout/fragment_first&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_FirstFragment_to_SecondFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:destination</span>=<span class="string">&quot;@id/SecondFragment&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/SecondFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:name</span>=<span class="string">&quot;com.example.demoproject1.SecondFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/second_fragment_label&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">tools:layout</span>=<span class="string">&quot;@layout/fragment_second&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_SecondFragment_to_FirstFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:destination</span>=<span class="string">&quot;@id/FirstFragment&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--我们可以看到这里有一个action标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>也就是说,我们通过 <code>R.id</code>可以直接引用到此<code>id</code>,访问到其下的<code>action_SecondFragment_to_FirstFragment</code>这段内容,也就没有那么难理解了吧.</p>
<p>而<code>NavHostFragment</code>的<code>findNavController</code>方法,直译为<strong>寻找导航控制器</strong>.</p>
<p>实际上是在告诉系统：“请在 <code>FirstFragment</code> 的上下文中找到与之关联的 <code>NavController</code>”。通过传入 <code>FirstFragment.this</code> 作为参数，为系统提供了找到正确 <code>NavController</code> 的必要上下文信息。</p>
<p>navigate的本质:<code>navigate()</code>方法是Android Navigation组件中的一个方法，用于执行导航动作。该方法接受一个导航动作的ID作为参数，并触发与该动作关联的导航。</p>
<p>而在XML文件中 <code>app:destination=&quot;@id/FirstFragment&quot; </code>这行代码的作用不可小觑.</p>
<p>上文很重要的一句话是: <strong>并出发与该动作关联的导航</strong>.</p>
<p>而<code>app:destination=&quot;@id/FirstFragment&quot; </code>,所提供的,就是关联!</p>
<ul>
<li><p>在导航XML中，<code>app:destination=&quot;@id/FirstFragment&quot;</code>的作用是指定一个目标页面的标识符，该标识符与FirstFragment类相关联。</p>
<p>具体来说，<code>@id/FirstFragment</code>是一个资源标识符，它指定了目标页面的名称。在这种情况下，目标页面被指定为FirstFragment类，这意味着当应用程序需要跳转到FirstFragment时，可以参考这个标识符来找到正确的目标页面。</p>
</li>
</ul>
<p><code>fragment_first.xml </code>中的代码:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.FirstFragment&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textview_first&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/hello_first_fragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toTopOf</span>=<span class="string">&quot;@id/button_first&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/button_first&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/next&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@id/textview_first&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>总结:</p>
<ul>
<li>理解了XML文件</li>
<li><code>findNavController()</code>方法</li>
<li><code>navigate()</code>方法</li>
<li><code>R.id</code>印象加深</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-9-25-Next.js目录文件</title>
    <url>/2023/09/25/2023-9-25-Next-js%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="What-is-Next-js"><a href="#What-is-Next-js" class="headerlink" title="What is Next.js ?"></a>What is Next.js ?</h2><p>Next.js is React framework for building full-stack web applications.</p>
<p> 翻译：Next.js是用于构建全栈web应用程序的React框架。 </p>
<h2 id="Main-Features"><a href="#Main-Features" class="headerlink" title="Main Features"></a>Main Features</h2><p>Some of the main Next.js features include:</p>
<ul>
<li>Routing 		也就是路由</li>
<li>Rendering             渲染</li>
<li>Data Fetching       数据获取</li>
<li>Styling                    样式</li>
<li>Optimizations       优化</li>
<li>TypeScript              支持TypeScript</li>
</ul>
<h2 id="App-Router-Pages-Router"><a href="#App-Router-Pages-Router" class="headerlink" title="App Router &amp;&amp; Pages Router"></a>App Router &amp;&amp; Pages Router</h2><p>Best newer is App Router, that allows use React’s latest features, such as Server Components and Streaming. </p>
<p>Older is Pages Router, that is the original Next.js router, which allowed you to build server-rendered React applications and continues to be supported for older Next.js applications. </p>
<p>两种路由方式，最新的 App路由，旧的是Pages路由，但仍然支持。</p>
<h2 id="Automatic-Installation"><a href="#Automatic-Installation" class="headerlink" title="Automatic Installation"></a>Automatic Installation</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx create-next-app@latest</span><br></pre></td></tr></table></figure>

<p>为什么只有自动安装？哦，手动安装暂时懒得学。</p>
<h2 id="Project-Structure"><a href="#Project-Structure" class="headerlink" title="Project Structure"></a>Project Structure</h2><h3 id="In-Top-level-Folders"><a href="#In-Top-level-Folders" class="headerlink" title="In Top-level Folders"></a>In Top-level Folders</h3><p>Look:
     - app <code>App Router</code> 
     - pages <code>Pages Router</code> 
     - public <code>Static assets to be served</code>
     - src <code>Optional application source folder </code></p>
<h3 id="Top-level-files"><a href="#Top-level-files" class="headerlink" title="Top-level files"></a>Top-level files</h3><hr>
<p>Next.js</p>
<hr>
<p><code>next.config.js</code> Next.js 的配置文件</p>
<p><code>package.json</code> 项目依赖项和脚本(scripts)</p>
<p><code>instrumentation.ts</code> 遥测框架配置文件</p>
<p><code>middleware.ts</code>Next.js 请求的中间件</p>
<p><code>.env</code> Environment variables 也就是环境变量</p>
<p><code>.env.production</code>production 的环境变量</p>
<p><code>.env.development</code>Development 的环境变量</p>
<hr>
<p>Tip: Development 意为开发，production 意为生产</p>
<ul>
<li>在开发时使用<code> .env.development</code>,而在实际的生产环境时应该用<code>.env.production</code></li>
</ul>
<hr>
<p><code>.eslintrc.json</code> ESLint的配置文件</p>
<hr>
<p>Tip: ESLint是一个用于识别ECMAScript并按照规则给出报告的代码检测工具，它可以用来避免低级错误和统一代码的风格</p>
<hr>
<p><code>.gitignore</code> Git文件及其文件夹（可忽略）</p>
<p><code>next0env.d.ts</code>Next.js 使用TypeScript 的声明文件</p>
<p><code>tsconfig.json</code> TypeScript 的配置文件</p>
<p><code>jsconfig.json</code> JavaScript 的配置文件</p>
<p><code>postcss.config.js</code>Tailwind CSS的配置文件</p>
<hr>
<p>Tip: Tailwind CSS是一个利用公用程序类(Utilize Class)的CSS框架。它是一个可定制化的、功能类优先的CSS框架，和我们知道的UI框架差不多。</p>
<hr>
<h2 id="app-Routing-Conventions"><a href="#app-Routing-Conventions" class="headerlink" title="app Routing Conventions"></a><code>app</code> Routing Conventions</h2><h2 id="RoutingFiles"><a href="#RoutingFiles" class="headerlink" title="RoutingFiles"></a>RoutingFiles</h2><p><code>layout</code> 	<code>.js</code> <code>.jsx</code>  <code>.tsx</code>    布局</p>
<p><code>page</code> 	<code>.js</code> <code>.jsx</code>  <code>.tsx</code> 	页面</p>
<p><code>loading</code> 	<code>.js</code> <code>.jsx</code>  <code>.tsx</code>	等待中的UI</p>
<p><code>not-found</code>	<code>.js</code> <code>.jsx</code>  <code>.tsx</code>	没搜索到的UI</p>
<p><code>error</code>		<code>.js</code> <code>.jsx</code>  <code>.tsx</code>	错误的UI</p>
<p><code>golobal-error</code>	<code>.js</code> <code>.jsx</code>  <code>.tsx</code>	全局错误的UI</p>
<p><code>route</code>	<code>.js</code> <code>.ts</code>	API endpoint</p>
<p><code>template</code>	<code>.js</code> <code>.jsx</code>  <code>.tsx</code>	重新渲染的布局</p>
<p><code>default</code>	 <code>.js</code> <code>.jsx</code>  <code>.tsx</code>	</p>
<h2 id="Nested-Routes"><a href="#Nested-Routes" class="headerlink" title="Nested Routes"></a>Nested Routes</h2><p>嵌套路由</p>
<p><code>folder</code> 	路由段</p>
<p><code>folder/folder</code> 嵌套路由段</p>
<h2 id="Dynamic-Routes"><a href="#Dynamic-Routes" class="headerlink" title="Dynamic Routes"></a>Dynamic Routes</h2><p>动态路由</p>
<p><code>[folder]</code>	动态路由线</p>
<p><code>[...folder] </code> 	捕获全部路由段</p>
<p><code>[[...folder]]</code>	可选捕获全部路由段</p>
<h2 id="Route-Groups-and-Private-Folders"><a href="#Route-Groups-and-Private-Folders" class="headerlink" title="Route Groups and Private Folders"></a>Route Groups and Private Folders</h2><p><code>(folder)</code>	分组路由而不影响路由</p>
<p><code>_folder</code>	 选择文件夹和所有子段退出路由 </p>
<h2 id="Parallel-and-Intercepted-Routes"><a href="#Parallel-and-Intercepted-Routes" class="headerlink" title="Parallel and Intercepted Routes"></a>Parallel and Intercepted Routes</h2><p><code>@folder</code>	命名插槽 Named slot</p>
<p><code>(.)folder</code>	拦截同一级别</p>
<p><code>(..)folder</code>	拦截一级以上</p>
<p><code>(..)(..)folder</code>	拦截两级以上</p>
<p><code>(...)folder</code>	从根目录开始拦截</p>
<h2 id="App-Icons"><a href="#App-Icons" class="headerlink" title="App Icons"></a>App Icons</h2><p><code>favicon</code>	<code>.ico</code>	Favicon 文件</p>
<p><code>icon</code>	<code>.ico</code> <code>.jpg</code> <code>.jpeg</code> <code>.png</code> <code>.svg</code>	App图标文件</p>
<p><code>icon</code>	<code>.js</code>  <code>.ts</code> <code>.tsx</code>	生成的应用程序图标</p>
<p><code>apple-icon</code>	<code>.jpg</code> <code>jpeg</code> <code>.png</code>	App应用程序图标文件</p>
<p><code>apple-icon</code>	<code>.js</code> <code>.ts</code> <code>.tsx</code>	生成的App应用程序图标</p>
<h2 id="Open-Graph-and-Twitter-Image"><a href="#Open-Graph-and-Twitter-Image" class="headerlink" title="Open Graph and Twitter Image"></a>Open Graph and Twitter Image</h2><p><code>opengraph-image</code>	<code>.jpg</code> <code>.jpeg</code> <code>.png</code> <code>.gif</code>	打开图像文件</p>
<p><code>opengraph-image</code>	<code>.js</code> <code>.ts</code> <code>.tsx</code>	生成打开的图像文件</p>
<p><code>twitter-image</code>	<code>.jpg</code> <code>.jpeg</code> <code>.png</code> <code>.gif</code>	打开推特图像文件</p>
<p><code>twitter-image</code>	<code>.js</code> <code>.ts</code> <code>.tsx</code>	生成打开的推特图像文件</p>
<h2 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h2><p><code>sitemap</code>	<code>.xml</code>	站点地图文件</p>
<p><code>sitemap</code>	<code>.js</code> <code>.ts</code>	生成站点地图</p>
<p><code>robots</code>	<code>.txt</code>	爬虫协议文件</p>
<p><code>robots</code>	<code>.js</code> <code>.ts</code>	生成爬虫协议文件</p>
<h2 id="pages-Routing-Conventions"><a href="#pages-Routing-Conventions" class="headerlink" title="pages Routing Conventions"></a><code>pages</code> Routing Conventions</h2><p><code>_app</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code>	自定义app</p>
<p><code>_document</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code> 	自定义Doc</p>
<p><code>_error</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code> 	自定义错误页面</p>
<p><code>404</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code> 	404 错误页面</p>
<p><code>500</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code> 	500 错误页面</p>
<h2 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a>Routes</h2><h3 id="Folder-convention"><a href="#Folder-convention" class="headerlink" title="Folder convention"></a>Folder convention</h3><p><code>index</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code> 	主页</p>
<p><code>folder/index</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code> 	嵌套页面</p>
<h3 id="File-convention"><a href="#File-convention" class="headerlink" title="File convention"></a>File convention</h3><p><code>index</code> 	<code>.js</code> <code>.jsx</code> <code>.tsx</code> 	主页</p>
<p><code>file</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code> 	嵌套页面</p>
<h2 id="Dynamic-Routes-1"><a href="#Dynamic-Routes-1" class="headerlink" title="Dynamic Routes"></a>Dynamic Routes</h2><h3 id="Folder-convention-1"><a href="#Folder-convention-1" class="headerlink" title="Folder convention"></a>Folder convention</h3><p><code>[folder]/index</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code> 	动态路由段</p>
<p><code>[...folder]/index</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code> 	捕获所有路由段</p>
<p><code>[[...folder]]/index</code>	<code>.js</code> <code>.jsx</code> <code>.tsx</code>	可选的捕获全部路由段</p>
<h3 id="File-convention-1"><a href="#File-convention-1" class="headerlink" title="File convention"></a>File convention</h3><p>| <a href="https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes"><code>[file]</code></a> | <code>.js</code> <code>.jsx</code> <code>.tsx</code> | Dynamic route segment            |
| ———————————————————— | ——————- | ——————————– |
| <a href="https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#catch-all-segments"><code>[...file]</code></a> | <code>.js</code> <code>.jsx</code> <code>.tsx</code> | Catch-all route segment          |
| <a href="https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#optional-catch-all-segments"><code>[[...file]]</code></a> | <code>.js</code> <code>.jsx</code> <code>.tsx</code> | Optional catch-all route segment |</p>
<h2 id="App-Router"><a href="#App-Router" class="headerlink" title="App Router"></a>App Router</h2><p><code>Next.js</code> 应用程序路由器为React的最新范例功能，应用路由是由基于文件系统的路由器在页面路由器中的自然演变。</p>
<p>一个应用程序中可以采取两种路由方式，但官方仍然建议使用应用路由器。</p>
<h2 id="Frequently-Asked-Questions"><a href="#Frequently-Asked-Questions" class="headerlink" title="Frequently Asked Questions"></a>Frequently Asked Questions</h2><h3 id="How-can-I-access-the-request-object-in-a-layout"><a href="#How-can-I-access-the-request-object-in-a-layout" class="headerlink" title="How can I access the request object in a layout?"></a>How can I access the request object in a layout?</h3><p>如何访问布局中的请求对象？</p>
<p>没有办法直接访问原始的请求对象，但是可以通过服务端函数访问请求头和Cookie，也可以设置Cookie。</p>
<p>布局不会重新渲染，可以缓存和复用，以减少页面之间进行导航的非必要计算。通过限制布局访问原始请求，<code>Next.js</code> 可以访问在布局中执行潜在的缓慢或昂贵的用户代码，这可能对性能造成负面影响。</p>
<h2 id="Build-Your-Application"><a href="#Build-Your-Application" class="headerlink" title="Build Your Application"></a>Build Your Application</h2><p>这种设计还强制不同页面之间的布局一致且可预测，以此来简化开发和调试，因为开发人员可以依靠布局以相同方式表现，而无需考虑所应用的特定页面。</p>
<p>根据正在构建的UI模式，Parallel 路由允许同一布局中呈现多个页面，并且页面可以访问路由段以</p>
<h2 id="How-can-I-access-the-URL-on-a-page"><a href="#How-can-I-access-the-URL-on-a-page" class="headerlink" title="How can I access the URL on a page?"></a>How can I access the URL on a page?</h2><p>如何访问页面上的URL？</p>
<p>默认情况下，页面是服务器组件。对于给定的页面可以通过 <code>params</code> 属性访问路由段，通过 <code>searchParams</code> 访问URL搜索参数。</p>
<p>如果使用的是客户端组件，对于更复杂的路由，可以使用 <code>usePathname</code>、<code>useSelectedLayout</code> 和<code>useSelectedLayoutSegments</code>。</p>
<p>此外，根据正在构建的UI模式 Parallel 路由允许在相同的布局呈现多个页面，并且页面可以访问路由段以及URL搜索参数。</p>
<h2 id="How-can-I-redirect-form-a-Server-Component"><a href="#How-can-I-redirect-form-a-Server-Component" class="headerlink" title="How can I redirect form a Server Component?"></a>How can I redirect form a Server Component?</h2><p>如何重定向服务器组件？</p>
<p>可以使用<code>redirect</code>将页面重定向到相对或绝对URL。<code>redirect</code>是临时（307）重定向，而<code>permanentRedirect</code>是永久（308）重定向。在流式UI中使用这些功能时，将会插入一个<code>meta</code>标签以客户端发出重定向。</p>
<h1 id="How-can-I-handle-authentication-with-the-App-Router"><a href="#How-can-I-handle-authentication-with-the-App-Router" class="headerlink" title="How can I handle authentication with the App Router."></a>How can I handle authentication with the App Router.</h1><p>如何使用 App 路由进行身份验证？</p>
<p>官方给出的方案：</p>
<pre><code>- [NextAuth.js](https://next-auth.js.org/configuration/nextjs#in-app-router)
- [Clerk](https://clerk.com/docs/quickstarts/nextjs)
- [Auth0](https://github.com/auth0/nextjs-auth0#app-router)
- Or manually handling sessions or JWTs
</code></pre>
<h2 id="How-can-I-set-cookies"><a href="#How-can-I-set-cookies" class="headerlink" title="How can I set cookies?"></a>How can I set cookies?</h2><p>可以使用 <code>cookies </code> 函数在<code>Server Actions</code> 或 <code>rOUTE hANDLERS</code> 中设置cookies。</p>
<p>由于 HTTP 不允许在流开始后设置 cookies ,因此不能从页面或者布局中之间设置 cookies。其他方法是从<code>Middleware</code>也就是中间件中设置。</p>
<h2 id="How-can-I-build-multi-tenant-apps"><a href="#How-can-I-build-multi-tenant-apps" class="headerlink" title="How can I build multi-tenant apps?"></a>How can I build multi-tenant apps?</h2><p>我该如何构建多用户应用程序？</p>
<p>例子 https:&#x2F;&#x2F;vercel.com&#x2F;templates&#x2F;next.js&#x2F;platforms-starter-kit</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Next.js</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Next学习手册（一）DOM</title>
    <url>/2023/09/25/2023-9-25-Next%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%88%E4%B8%80%EF%BC%89-%20DOM/</url>
    <content><![CDATA[<h3 id="React工作原理"><a href="#React工作原理" class="headerlink" title="React工作原理"></a>React工作原理</h3><p>当浏览器试图访问一个网页时，会得到诸如下图一样的响应内容：</p>
<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/html-to-dom.png" class="">

<p>然后浏览器将通过此响应内容，构造 DOM (文档对象模型)。</p>
<p>然后才是我们所看到的UI界面。</p>
<h3 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM?"></a>什么是DOM?</h3><p>对于什么是DOM，<code>Next.js</code> 官方给出了如下解释。</p>
<p>The DOM is an object representation of the HTML elements. It acts as a  bridge between your code and the user interface, and has a tree-like  structure with parent and child relationships.</p>
<p>翻译：DOM是HTML元素的对象表示。它充当代码和用户界面之间的桥梁，并具有具有父子关系的树状结构。</p>
<p>这意味着我们可以通过DOM界面以及程序来监听用户事件，并通过修改元素来操作DOM。</p>
<h4 id="示例一："><a href="#示例一：" class="headerlink" title="示例一："></a>示例一：</h4><p>  假设我们有一个HTML文件，内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个HTML中，我们给<code>&lt;div&gt;</code>加了一个唯一的id，为了方便针对。并且为了在HTML中编写javascript代码，添加了标记。</p>
<p>现在通过一个DOM方法，<code>getElementByID()</code>来根据<code>id</code>选择<code>&lt;div&gt;</code>标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> app = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后继续使用DOM方法创建一个新的元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 根据id 选择div标签</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> app = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 声明一个新的 h1 元素</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> header = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 声明新的文本内容</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> headerContent = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;Develop. Preview. Ship. 🚀&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      );</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 将刚才声明的文本内容添加给 h1 元素</span></span></span><br><span class="line"><span class="language-javascript">      header.<span class="title function_">appendChild</span>(headerContent);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 将刚才声明的 h1 元素 放置在 div中</span></span></span><br><span class="line"><span class="language-javascript">      app.<span class="title function_">appendChild</span>(header);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着我们可以看到如下页面：</p>
<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/page_image_1.png" class="">

<h3 id="HTML-AND-DOM"><a href="#HTML-AND-DOM" class="headerlink" title="HTML AND DOM"></a>HTML AND DOM</h3><p>通过查看页面DOM元素，我们会看到页面中包含<code>&lt;h1&gt;</code>元素，这与我们的源代码不同。</p>
<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/source-code.png" class="">

<p>原因就是，HTML表示的是初始页面内容，而DOM表示修改后的页面内容。之所以呈现不同，就是因为我们看到的页面已经被编写的javascript 代码修改过了。</p>
<p>使用简单的javascript代码来更新DOM非常强大，但代码很冗长。我们使用了如下7行代码来更新了一个<code>&lt;h1&gt;</code>元素及其内容。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> app = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> header = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> headerContent = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;Develop. Preview. Ship. 🚀&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  header.<span class="title function_">appendChild</span>(headerContent);</span></span><br><span class="line"><span class="language-javascript">  app.<span class="title function_">appendChild</span>(header);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>随着应用体积增长，使用这种方法编写应用会越来越难。但开发者通过编写指令，描述想现实的内容，让计算机知道该如何更新DOM，这是很不错的。</p>
<h3 id="命令式编程和声明式编程"><a href="#命令式编程和声明式编程" class="headerlink" title="命令式编程和声明式编程"></a>命令式编程和声明式编程</h3><p>上面的代码是命令式编程的例子，我们编写如何更新用户界面的步骤。但涉及到构建用户界面时，声明式编程是首选的，因为这可以加快开发过程。</p>
<p>In other words, <strong>imperative programming</strong> is like giving a chef step-by-step instructions on how to make a pizza. <strong>Declarative programming</strong> is like ordering a pizza without being concerned about the steps it takes to make the pizza. 🍕	— Next.js</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Next.js</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>联机教程</title>
    <url>/2023/09/05/2023-9-5-%E8%81%94%E6%9C%BA/</url>
    <content><![CDATA[<h3 id="【联机方式】"><a href="#【联机方式】" class="headerlink" title="【联机方式】"></a>【联机方式】</h3><p>铁锈战争非常的自由，支持多种联机方式。
下面按照使用难度从易到难，分别叙述。</p>
<h4 id="【公开服务器联机】难度-零星"><a href="#【公开服务器联机】难度-零星" class="headerlink" title="【公开服务器联机】难度: 零星"></a>【公开服务器联机】难度: 零星</h4><p>出现在多人游戏列表中的官方服务器以及第三方服务器，只需点击即可加入。</p>
<h4 id="【REPALY联机】难度-一星"><a href="#【REPALY联机】难度-一星" class="headerlink" title="【REPALY联机】难度: 一星"></a>【REPALY联机】难度: 一星</h4><p>RELAY, 又称继电器, 是在 Rusted Warfare 1.14.P8 (测试版) 加入的功能, 目的是在 不使用 任何工具的情况下, 使玩家作为 NAT 网络下的工具, 可以和玩家进行联机.
                                                                —- Dr</p>
<h5 id="官方REPALY"><a href="#官方REPALY" class="headerlink" title="[官方REPALY]:"></a>[官方REPALY]:</h5><p>多人游戏列表中选择Aisa&#x2F;US
Aisa为亚洲REPALY,US为美洲REPLAY</p>
<h5 id="第三方REPLAY"><a href="#第三方REPLAY" class="headerlink" title="[第三方REPLAY]:"></a>[第三方REPLAY]:</h5><p>RELAY-CN 是由 RW-HPS &amp; RCN Team 搭建的 中国区非官方 RELAY (ID: R) rcn[docs]: https:&#x2F;&#x2F;docs.der.kim&#x2F;web&#x2F;#&#x2F;5&#x2F;23
RELAY-RU 是由 Vulkan (RMT) 搭建的 俄区非官方 RELAY (ID: V) : </p>
<h4 id="【第三方联机服务】难度-一星"><a href="#【第三方联机服务】难度-一星" class="headerlink" title="【第三方联机服务】难度: 一星"></a>【第三方联机服务】难度: 一星</h4><p>蒲公英联机、水瓶联机、小火箭联机，等。
通过第三方联机平台进行的联机，具体情况视软件而不同，故不多赘述。</p>
<h4 id="【ipv6联机】难度-二星"><a href="#【ipv6联机】难度-二星" class="headerlink" title="【ipv6联机】难度: 二星"></a>【ipv6联机】难度: 二星</h4><p>ipv6对某些未普及的地区来说属于比较苛刻的条件，但随时间推移这也许将不再苛刻。
铁锈战争支持ipv6直连，如果你和你的朋友都支持ipv6话可以考虑。
一个IPV6检测网站: http:&#x2F;&#x2F;test-ipv6.com&#x2F;
如果检测不到ipv6可以尝试开启，开启后输入ipv6地址+5123端口直连即可。</p>
<h4 id="【自建第三方服务器联机】难度-三星"><a href="#【自建第三方服务器联机】难度-三星" class="headerlink" title="【自建第三方服务器联机】难度: 三星"></a>【自建第三方服务器联机】难度: 三星</h4><p>这需要你成为铁锈战争的服主，首先你需要有一台拥有公网的服务器，然后在你的服务器上运行联机服务软件即可。
一些开源的联机服务软件：
        - [RW-HPS]:https:&#x2F;&#x2F;github.com&#x2F;RW-HPS&#x2F;RW-HPS&#x2F;
        - [Rukkit]:https:&#x2F;&#x2F;github.com&#x2F;RukkitDev&#x2F;Rukkit
        - [RW-CPPS]:https:&#x2F;&#x2F;github.com&#x2F;shishanyue&#x2F;RW-CPPS</p>
<p>####【端口映射和端口转发】难度: 三星</p>
<h5 id="端口映射-将外网的一个端口完全映射给内网一个地址的指定端口-实现外网到内网和内网到外网双向的通信"><a href="#端口映射-将外网的一个端口完全映射给内网一个地址的指定端口-实现外网到内网和内网到外网双向的通信" class="headerlink" title="[端口映射]:将外网的一个端口完全映射给内网一个地址的指定端口,实现外网到内网和内网到外网双向的通信."></a>[端口映射]:将外网的一个端口完全映射给内网一个地址的指定端口,实现外网到内网和内网到外网双向的通信.</h5><pre><code>- 知乎：https://zhuanlan.zhihu.com/p/43233032
</code></pre>
<h5 id="端口转发-如果你有一台可以使用公网的设备-而你又无法直接在那个设备上进行游戏，可以借助工具进行端口转发，从而利用公网为你的游戏联机提供服务。这里仅推荐开源的跨平台端口转发工具–FRP。"><a href="#端口转发-如果你有一台可以使用公网的设备-而你又无法直接在那个设备上进行游戏，可以借助工具进行端口转发，从而利用公网为你的游戏联机提供服务。这里仅推荐开源的跨平台端口转发工具–FRP。" class="headerlink" title="[端口转发]:如果你有一台可以使用公网的设备,而你又无法直接在那个设备上进行游戏，可以借助工具进行端口转发，从而利用公网为你的游戏联机提供服务。这里仅推荐开源的跨平台端口转发工具–FRP。"></a>[端口转发]:如果你有一台可以使用公网的设备,而你又无法直接在那个设备上进行游戏，可以借助工具进行端口转发，从而利用公网为你的游戏联机提供服务。这里仅推荐开源的跨平台端口转发工具–FRP。</h5><pre><code>- FRP端口转发: https://gofrp.org/
</code></pre>
<h3 id="【自己写个联机软件】难度-满天星"><a href="#【自己写个联机软件】难度-满天星" class="headerlink" title="【自己写个联机软件】难度: 满天星"></a>【自己写个联机软件】难度: 满天星</h3><p>自己想。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>2023-9-25-了解Next.js</title>
    <url>/2023/09/25/2023-9-25-%E4%BA%86%E8%A7%A3Next-js/</url>
    <content><![CDATA[<h3 id="Next-js"><a href="#Next-js" class="headerlink" title="Next.js"></a>Next.js</h3><p>Next.js 是什么？</p>
<ul>
<li>官方：Next.js is a flexible React framework that gives you building blocks to create fast web applications.<ul>
<li>翻译：Next.js 是一个灵活的React框架，它为我们提供快速构建web应用程序的构建块。</li>
</ul>
</li>
</ul>
<h3 id="Building-Blocks-of-a-Web-Application"><a href="#Building-Blocks-of-a-Web-Application" class="headerlink" title="Building Blocks of a Web Application"></a>Building Blocks of a Web Application</h3><p>— 改编自 Next.js 官网</p>
<p>也就是web应用构建块。这仍然是个比较抽象的概念，我们需要知道，什么是web应用构建块。</p>
<p>构建web应用程序时，我们需要考虑以下几点：</p>
<pre><code>- 用户界面：提供应用程序，使用户与之交互。
- 路由：用户在应用程序不同部分之间导航。
- 数据获取：数据位于何处以及如何获取。
- 渲染：何时何地渲染静态或动态内容。
- 集成：使用的第三方服务（CMS、身份验证、支付等）以及如何连接它们。
- 基础架构：部署、存储和运行应用程序代码（Serverless、CDN、Edge等）的地方。
- 性能：如何为最终用户优化应用程序。
- 可扩展性：应用程序如何随着团队、数据和流量的增长而进行调整。
- 开发经验：团队构建和维护应用程序的经验。
</code></pre>
<p> 对于应用程序的每个部分，需要决定是自己构建解决方案，还是使用库和框架等其他工具。 </p>
<p>综上所述，用户界面、路由、数据获取、渲染…等，这些点，其实都算是一个个的构建块。而以上所有内容，我们都可以使用Next.js 实现。至于这些到底是什么，我们将一一细究。</p>
<p><strong>那么</strong></p>
<h3 id="React-是啥？"><a href="#React-是啥？" class="headerlink" title="React 是啥？"></a>React 是啥？</h3><p>官方说了： <a href="https://react.dev/learn">React</a> is a JavaScript <strong>library</strong> for building interactive <strong>user interfaces</strong>. </p>
<p>翻译： React是一个用于构建交互式用户界面的JavaScript库。 </p>
<ul>
<li><p>什么是用户界面：使用代码呈现给用户看的界面，就是用户界面。而一般用户界面有两种：CLI 和 GUI（命令行界面和图形化界面），而我们浏览器为我们提供的 WEB 界面，正是一种GUI界面。</p>
</li>
<li><p>Next.js 官方的解释是这样的：By user interfaces, we mean the elements that users see and interact with on-screen.</p>
<ul>
<li>翻译：所谓用户界面，我们指的是用户在屏幕上看到并与之交互的元素。</li>
</ul>
</li>
</ul>
<p>什么是库？</p>
<ul>
<li>官方：By library, we mean React provides helpful functions to build UI, but leaves it up to the developer where to use those functions in their  application.<ul>
<li>所谓库，我们的意思是React提供了有用的函数来构建UI，但将这些函数在应用程序中的使用交予开发人员。</li>
</ul>
</li>
</ul>
<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/user-interface.png" class="">

<p>有了库，我们可以直接引用已经开发好的函数来构建应用程序，这可以大幅度加快我们的开发效率。我们不必在开发时深究底层，什么功能都要自己从零开始写，也就是俗称的”造轮子“。引用前人的智慧，这亦是一种智慧。</p>
<p>官方原文：</p>
<ul>
<li>Part of React’s success is that it is relatively unopinionated about the other aspects of building applications. This has resulted in a flourishing ecosystem of third-party tools and solutions.<ul>
<li>React的成功部分在于，它对构建应用程序的其他方面相对不持偏见。这使得第三方工具和解决方案的生态系统蓬勃发展。</li>
</ul>
</li>
<li>It also means, however, that building a complete React application from the ground up requires some effort. Developers need to spend time configuring tools and reinventing solutions for common application requirements.<ul>
<li>然而，这也意味着，从头开始构建一个完整的React应用程序需要付出一些努力。开发人员需要花费时间配置工具，并根据常见的应用程序需求重新设计解决方案。</li>
</ul>
</li>
</ul>
<p>也就是说，这门技术海纳百川，非常强大，几乎啥都能干。这也意味着，想要开发一个React应用程序，就需要明白一个应用程序项目的各个关节，因为它非常的全面，而且是较为独立的一个技术栈，所以需要投入较多的精力去学习。</p>
<p>话说回来</p>
<h3 id="什么是Next-js-？"><a href="#什么是Next-js-？" class="headerlink" title="什么是Next.js ？"></a>什么是Next.js ？</h3><p>官方：Next.js is a React framework that gives you building blocks to create web applications.</p>
<ul>
<li>翻译： Next.js是一个React框架，它为您提供创建web应用程序的构建块。</li>
</ul>
<p>官方：By framework, we mean Next.js handles the tooling and configuration needed for React, and provides additional structure, features, and optimizations for your application.</p>
<ul>
<li>翻译： 所谓框架，我们的意思是Next.js处理React所需的工具和配置，并为您的应用程序提供额外的结构、功能和优化。</li>
</ul>
<p>官方：You can use React to build your UI, then incrementally adopt Next.js features to solve common application requirements such as routing, data fetching, integrations - all while improving the developer and end-user experience.</p>
<ul>
<li>翻译：您可以使用React构建UI，然后逐步采用Next.js功能来解决常见的应用程序需求，如路由、数据获取、集成，同时改善开发人员和最终用户体验。</li>
</ul>
<p>官方：Whether you’re an individual developer or part of a larger team, you can leverage React and Next.js to build fully interactive, highly dynamic, and performant web applications.</p>
<ul>
<li>翻译：无论您是个人开发人员还是更大团队的一员，都可以利用React和Next.js构建完全交互式、高度动态和高性能的web应用程序。</li>
</ul>
<img src="http://171.38.91.172:4666/MOON/blog%E5%9B%BE%E7%89%87%E7%B4%A0%E6%9D%90/next-app.png" class="">

<p>React是一个强大的js库，而Next.js 是一个React的框架，它为React而生！这就是Next.js，既然已经知道吾之真名了，那就！步入正题！向着开发，前进！</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Next.js</tag>
      </tags>
  </entry>
</search>
